<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>go 笔记 基础语法</title>

    <meta name="viewport" content="width=device-width">
    <meta name="description" content="">

    
    

    <link rel="canonical" href="http://localhost:4000/go-sequential-programming">
    <link rel="icon" type="image/png" href="/images/logo.png">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/monster.css">

    

</head>


    <body>
    
    <div class="wrapper">

      <header class="header">

  <div class="site-title">
    
    <h4 class="entry-title"><a href="/go-sequential-programming">go 笔记 基础语法</a></h4>
    
  </div>

<div class="links">
    
    <a href="/" class="page-link">Blog</a>
    
    
    
    
      <a class="page-link"
        href="/about/">About</a>
    
    
    
      <a class="page-link"
        href="/categories">Categories</a>
    
    
    
    
    
    
    
      <a class="page-link"
        href="/links/">Links</a>
    
    
    
    
    
      <a class="page-link"
        href="/tags">Tags</a>
    
    
    <a href="/feed.xml" target="_blank" class="page-link">RSS</a>
</div>
</header>

      
      <div class="navi">
    
    <a href="/" class="page-link">Blog</a>
    
    
    
    
      <a class="page-link"
        href="/about/">About</a>
    
    
    
      <a class="page-link"
        href="/categories">Categories</a>
    
    
    
    
    
    
    
      <a class="page-link"
        href="/links/">Links</a>
    
    
    
    
    
      <a class="page-link"
        href="/tags">Tags</a>
    
    
    <a href="/feed.xml" target="_blank" class="page-link">RSS</a>
</div>


      <div class="content">
        <div class="articles">
            <div class="article-meta">
    2018-03-01
     • Category: 
        
        <a href="/categories//#编程语言-ref" >编程语言</a>
        
    
     • Tag: 
        
            <a href="/tags//#go-ref" >Go</a>
        
    
</div>

<div class="entry post">

	<div class="entry-content">
	  <article class="entry-body">
	  	
	  		<p>Go语言最主要的特性：</p>

<ul>
  <li>自动垃圾回收</li>
  <li>更丰富的内置类型</li>
  <li>函数多返回值</li>
  <li>错误处理</li>
  <li>匿名函数和闭包</li>
  <li>类型和接口</li>
  <li>并发编程</li>
  <li>反射</li>
  <li>语言交互性</li>
</ul>

<p>Go 程序的代码注释与 C++保持一致，即同时支持以下两种用法:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/*
    块注释
*/</span>

<span class="c">// 行注释</span>
</code></pre></div></div>

<h1 id="一-变量">一、 变量</h1>

<p>Go 语言的变量声明方式与C和C++语言有明显的不同。对于纯粹的变量声明，Go语言引入了 关键字var，而类型信息放在变量名之后。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">var</span> <span class="n">v1</span> <span class="kt">int</span>
<span class="k">var</span> <span class="n">v2</span> <span class="kt">string</span> 
<span class="k">var</span> <span class="n">v3</span> <span class="p">[</span><span class="m">10</span><span class="p">]</span> <span class="kt">int</span>  <span class="c">// 数组 </span>
<span class="k">var</span> <span class="n">v4</span> <span class="p">[]</span> <span class="kt">int</span>    <span class="c">// 数组切片 </span>

<span class="k">var</span> <span class="n">v5</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">f</span> <span class="kt">int</span>
	<span class="n">v</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">var</span> <span class="n">v6</span> <span class="o">*</span> <span class="kt">int</span> <span class="c">// 指针</span>
<span class="k">var</span> <span class="n">v7</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span> <span class="kt">int</span>  <span class="c">// map，key为string类型，value为int类型</span>
<span class="k">var</span> <span class="n">v8</span> <span class="k">func</span> <span class="p">(</span><span class="n">a</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>

</code></pre></div></div>

<ul>
  <li>变量声明语句不需要使用分号作为结束符。</li>
  <li>var关键字的另一种用法是可以将若干个需要声明的变量放置在一起，免得程序员需要重复 写var关键字</li>
</ul>

<h2 id="变量初始化">变量初始化</h2>

<p>对于声明变量时需要进行初始化的场景，var关键字可以保留，但不再是必要的元素。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">v1</span> <span class="kt">int</span>  <span class="o">=</span> <span class="m">10</span> <span class="c">// 方法一，规范方式</span>
<span class="k">var</span> <span class="n">v2</span> <span class="o">=</span> <span class="m">10</span>      <span class="c">// 方法二</span>
<span class="n">v3</span> <span class="o">:=</span> <span class="m">10</span>         <span class="c">// 方法三，偷懒方法，常用</span>
</code></pre></div></div>

<p>冒号和等号的组合<code class="language-plaintext highlighter-rouge">:=</code>，用于明确表达同时进行变量声明和初始化的工作。</p>

<h2 id="变量赋值">变量赋值</h2>

<p>多重赋值：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span>
</code></pre></div></div>

<h3 id="匿名变量">匿名变量</h3>

<p>我们在使用传统的强类型语言编程时，经常会出现这种情况，即在调用函数时为了获取一个 值，却因为该函数返回多个值而不得不定义一堆没用的变量。在Go 中这种情况可以通过结合使 用多重返回和匿名变量来避免这种丑陋的写法，让代码看起来更加优雅。</p>

<p>如：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">nickName</span> <span class="o">:=</span> <span class="n">GetName</span><span class="p">()</span>
</code></pre></div></div>

<h1 id="二常量">二、常量</h1>

<p>常量是指编译期间就已知且不可改变的值。常量可以是数值类型(包括整型、浮点型和复数类型)、布尔类型、字符串类型等。</p>

<h2 id="字面常量">字面常量</h2>

<p>所谓字面常量(literal)，是指程序中硬编码的常量。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="m">3.14159265358979323846</span> <span class="c">// 浮点类型的常量</span>
<span class="s">"foo"</span>                  <span class="c">// 字符串常量</span>
<span class="no">true</span>                   <span class="c">// 布尔类型的常量</span>
</code></pre></div></div>

<h2 id="常量定义">常量定义</h2>

<p>通过const关键字，你可以给字面常量指定一个友好的名字:</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">Pi</span>  <span class="kt">float64</span>  <span class="o">=</span> <span class="m">3.14159265358979323846</span>

<span class="k">const</span> <span class="p">(</span>
    <span class="n">size</span> <span class="kt">int64</span> <span class="o">=</span> <span class="m">1024</span> 
    <span class="n">eof</span> <span class="o">=</span> <span class="o">-</span><span class="m">1</span>
<span class="p">)</span>
</code></pre></div></div>

<h2 id="预定义常量">预定义常量</h2>

<p>Go 语言预定义了这些常量: true、false 和iota。</p>

<p>iota 比较特殊，可以被认为是一个可被编译器修改的常量，在每一个 const 关键字出现时被重置为 0，然后在下一个const 出现之前，每出现一次 iota，其所代表的数字会自动增1。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">const</span> <span class="p">(</span>
    <span class="n">c0</span> <span class="o">=</span> <span class="no">iota</span>   <span class="c">// c0 = 0</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="no">iota</span>   <span class="c">// c1 = 1</span>
    <span class="n">c2</span> <span class="o">=</span> <span class="no">iota</span>   <span class="c">// c2 = 2</span>
<span class="p">)</span>

<span class="k">const</span> <span class="p">(</span>
    <span class="n">a</span> <span class="o">=</span> <span class="m">1</span> <span class="o">&lt;&lt;</span> <span class="no">iota</span>  <span class="c">// a == 1 </span>
    <span class="n">b</span> <span class="o">=</span> <span class="m">1</span> <span class="o">&lt;&lt;</span> <span class="no">iota</span>  <span class="c">// b == 2</span>
    <span class="n">c</span> <span class="o">=</span> <span class="m">1</span> <span class="o">&lt;&lt;</span> <span class="no">iota</span>  <span class="c">// c == 4</span>
<span class="p">)</span>
</code></pre></div></div>

<p>如果两个const的赋值语句的表达式是一样的，那么可以省略后一个赋值表达式。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="p">(</span>
    <span class="n">c0</span> <span class="o">=</span> <span class="no">iota</span>   <span class="c">// c0 = 0</span>
    <span class="n">c1</span>          <span class="c">// c1 = 1</span>
    <span class="n">c2</span>          <span class="c">// c2 = 2</span>
<span class="p">)</span>

<span class="k">const</span> <span class="p">(</span>
    <span class="n">a</span> <span class="o">=</span> <span class="m">1</span> <span class="o">&lt;&lt;</span> <span class="no">iota</span>  <span class="c">// a == 1 </span>
    <span class="n">b</span>              <span class="c">// b == 2</span>
    <span class="n">c</span>              <span class="c">// c == 4</span>
<span class="p">)</span>
</code></pre></div></div>

<h3 id="枚举">枚举</h3>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="p">(</span>
    <span class="n">Sunday</span> <span class="o">=</span> <span class="no">iota</span>
    <span class="n">Monday</span>
    <span class="n">Tuesday</span>
    <span class="n">Wednesday</span>
    <span class="n">Thursday</span>
    <span class="n">Friday</span>
    <span class="n">Saturday</span>
    <span class="n">numberOfDays</span>
<span class="p">)</span>
</code></pre></div></div>

<p>同 Go 语言的其他符号(symbol)一样，以大写字母开头的常量在包外可见。以上例子中 numberOfDays 为包内私有，其他符号则可被其他包访问。</p>

<h1 id="三类型">三、类型</h1>

<p>Go 语言内置以下这些基础类型:</p>

<ul>
  <li>布尔类型 : bool。</li>
  <li>整型 : int8、byte、int16、int、uint、uintptr等。</li>
  <li>浮点类型 : float32、float64。</li>
  <li>复数类型:complex64、complex128。</li>
  <li>字符串:string。</li>
  <li>字符类型:rune。</li>
  <li>错误类型:error。</li>
</ul>

<p>复合类型:</p>

<ul>
  <li>指针(pointer)</li>
  <li>数组(array)</li>
  <li>切片(slice)</li>
  <li>字典(map)</li>
  <li>通道(chan)</li>
  <li>结构体(struct)</li>
  <li>接口(interface)</li>
</ul>

<h2 id="布尔类型">布尔类型</h2>

<p>关键字为bool，可赋值为预定义的 true 和 false。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span>  <span class="n">v1</span> <span class="kt">bool</span>
<span class="n">v1</span> <span class="o">=</span> <span class="no">true</span>
<span class="n">v2</span> <span class="o">:=</span> <span class="p">(</span><span class="m">1</span> <span class="o">==</span> <span class="m">2</span><span class="p">)</span> <span class="c">// v2也会被推导为bool类型</span>
</code></pre></div></div>

<p>布尔类型不能接受其他类型的赋值，不支持自动或强制的类型转换。</p>

<h2 id="整型">整型</h2>

<p>go 所支持的类型和长度：</p>

<p><img src="/assets/programming-language/go-2022-12-01_00-54-53.png" alt="" /></p>

<p>使用强制类型转换：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">value2</span> <span class="o">=</span> <span class="kt">int32</span><span class="p">(</span><span class="n">value1</span><span class="p">)</span> <span class="c">// 编译通过</span>
</code></pre></div></div>

<p>在做强制类型转换时，需要注意数据长度被截短而发生的数据精度损失(比如将浮点数强制转为整数)和值溢出(值超过转换的目标类型的值范围时)问题。</p>

<p>数值运算： <code class="language-plaintext highlighter-rouge">+</code>、<code class="language-plaintext highlighter-rouge">-</code>、<code class="language-plaintext highlighter-rouge">*</code>、<code class="language-plaintext highlighter-rouge">/</code>  和<code class="language-plaintext highlighter-rouge">%</code></p>

<p>比较运算: <code class="language-plaintext highlighter-rouge">&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;</code>、<code class="language-plaintext highlighter-rouge">==</code>、<code class="language-plaintext highlighter-rouge">&gt;=</code>、<code class="language-plaintext highlighter-rouge">&lt;=</code> 和 <code class="language-plaintext highlighter-rouge">!=</code></p>

<p>位运算:</p>

<p>注意取反的方式和C语言不一样。</p>

<p><img src="/assets/programming-language/go-2022-12-01_01-02-06.png" alt="" /></p>

<h2 id="浮点型">浮点型</h2>

<p>Go 语言定义了两个类型 float32 和 float64 。</p>

<p>浮点数比较： 因为浮点数不是一种精确的表达方式，所以像整型那样直接用<code class="language-plaintext highlighter-rouge">==</code> 来判断两个浮点数是否相等 是不可行的，这可能会导致不稳定的结果。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="s">"math"</span>

<span class="c">// p为用户自定义的比较精度，比如0.00001 </span>
<span class="k">func</span> <span class="n">IsEqual</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">p</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span>  <span class="n">math</span><span class="o">.</span><span class="n">Fdim</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">p</span> 
<span class="p">}</span>

</code></pre></div></div>

<h2 id="复数类型">复数类型</h2>

<p>复数表示:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">value1</span> <span class="kt">complex64</span>

<span class="n">value1</span> <span class="o">=</span> <span class="m">3.2</span> <span class="o">+</span> <span class="m">12i</span>
<span class="n">value2</span> <span class="o">:=</span> <span class="m">3.2</span> <span class="o">+</span> <span class="m">12i</span>
<span class="n">value3</span> <span class="o">:=</span> <span class="nb">complex</span><span class="p">(</span><span class="m">3.2</span><span class="p">,</span> <span class="m">12</span><span class="p">)</span>

</code></pre></div></div>

<p>实部与虚部:</p>

<p>对于一个复数 <code class="language-plaintext highlighter-rouge">z = complex(x, y)</code>，就可以通过 Go 语言内置函数<code class="language-plaintext highlighter-rouge">real(z)</code>获得该复数的实 部，也就是 x，通过imag(z)获得该复数的虚部，也就是 y 。</p>

<h2 id="字符串">字符串</h2>

<p>字符串的声明和初始化如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">str</span> <span class="kt">string</span> <span class="c">// 声明一个字符串变量</span>
<span class="n">str</span> <span class="o">=</span> <span class="s">"Hello world"</span> <span class="c">// 字符串赋值</span>
<span class="n">ch</span> <span class="o">:=</span> <span class="n">str</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="c">// 取字符串的第一个字符</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"The length of </span><span class="se">\"</span><span class="s">%s</span><span class="se">\"</span><span class="s"> is %d </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">str</span><span class="p">))</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"The first character of </span><span class="se">\"</span><span class="s">%s</span><span class="se">\"</span><span class="s"> is %c.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">ch</span><span class="p">)</span>
</code></pre></div></div>

<p>字符串的内容可以用类似于数组下标的方式获取，但与数组不同，字符串的内容不能在初始 化后被修改。</p>

<h2 id="字符类型">字符类型</h2>

<p>在 Go 语言中支持两个字符类型，一个是 <code class="language-plaintext highlighter-rouge">byte</code> (实际上是uint8的别名) ， 代表UTF-8字符串的单个字节的值; 另一个是<code class="language-plaintext highlighter-rouge">rune</code>，代表单个 Unicode 字符。</p>

<h2 id="数组">数组</h2>

<p>数组中包含的每个数据被称为数组元素(element)，一个数组包含的元素个数被称为数 组的长度。</p>

<p>以下为一些常规的数组声明方法:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="m">32</span><span class="p">]</span> <span class="kt">byte</span>                     <span class="c">// 长度为32的数组，每个元素为一个字节 </span>
<span class="p">[</span><span class="m">2</span><span class="o">*</span><span class="n">N</span><span class="p">]</span> <span class="k">struct</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="n">_int32_</span> <span class="p">}</span> <span class="c">// 复杂类型数组</span>
<span class="p">[</span><span class="m">1000</span><span class="p">]</span> <span class="o">*</span> <span class="kt">float64</span>              <span class="c">// 指针数组</span>
<span class="p">[</span><span class="m">3</span><span class="p">][</span><span class="m">5</span><span class="p">]</span> <span class="kt">int</span>                    <span class="c">// 二维数组</span>
<span class="p">[</span><span class="m">2</span><span class="p">][</span><span class="m">2</span><span class="p">][</span><span class="m">2</span><span class="p">]</span> <span class="kt">float64</span>             <span class="c">// 等同于[2]([2]([2]float64))</span>
</code></pre></div></div>

<p>组长度在定义后就不可更改，在声明时长度可以为一个常量或者一个常量 表达式(常量表达式是指在编译期即可计算结果的表达式)。数组的长度是该数组类型的一个内 置常量，可以用 Go 语言的内置函数len()来获取。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">arrLength</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>元素访问</strong></p>

<p>可以使用数组下标来访问数组中的元素。与C语言相同，数组下标从0开始，len(array)-1 则表示最后一个元素的下标。下面的示例遍历整型数组并逐个打印元素内容:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Element"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s">"of array is "</span><span class="p">,</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>Go 语言还提供了一个关键字 range，用于便捷地遍历容器中的元素。当然，数组也是range 的支持范围。上面的遍历过程可以简化为如下的写法:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">array</span> <span class="p">{</span>
   <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Array element ["</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s">"]="</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>值类型</strong></p>

<p>在 Go 语言中数组是一个值类型(value type)。所有的值类型变量在赋值。和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该 参数将发生数据复制。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是所 传入数组的一个副本。</p>

<h2 id="切片-slice">切片 slice</h2>

<p>切片 slice 就像一个指向数组的指针。实际上它拥有自己的数据结构，而不仅仅是个指针。数组切片的数据结构可以抽象为以下3个变量:</p>

<ul>
  <li>一个指向原生数组的指针。</li>
  <li>数组切片中的元素个数。</li>
  <li>数组切片已分配的存储空间。</li>
</ul>

<p><strong>创建数组切片</strong></p>

<p>创建数组切片的方法主要有两种——基于数组和直接创建。</p>

<p><strong>基于数组</strong></p>

<p>数组切片可以基于一个已存在的数组创建。数组切片可以只使用数组的一部分元素或者整个数组来创建，甚至可以创建一个比所基于的数组还要大的数组切片。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 先定义一个数组</span>
<span class="k">var</span> <span class="n">myArray</span> <span class="p">[</span><span class="m">10</span><span class="p">]</span> <span class="kt">int</span> <span class="o">=</span> <span class="p">[</span><span class="m">10</span><span class="p">]</span> <span class="kt">int</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">6</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">8</span><span class="p">,</span> <span class="m">9</span><span class="p">,</span> <span class="m">10</span> <span class="p">}</span> <span class="c">// 基于数组创建一个数组切片</span>
<span class="k">var</span> <span class="n">mySlice</span> <span class="p">[]</span> <span class="kt">int</span> <span class="o">=</span> <span class="n">myArray</span><span class="p">[</span><span class="o">:</span><span class="m">5</span><span class="p">]</span>

</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">myArray[first:last]</code> 这样的方式来基于数组生成一 个数组切片。</p>

<p>基于myArray的所有元素创建数组切片:  <code class="language-plaintext highlighter-rouge">mySlice = myArray[:]</code></p>

<p>基于myArray的前5个元素创建数组切片:<code class="language-plaintext highlighter-rouge">mySlice = myArray[:5]</code></p>

<p>基于从第5个元素开始的所有元素创建数组切片: <code class="language-plaintext highlighter-rouge">mySlice = myArray[5:]</code></p>

<p><strong>直接创建</strong></p>

<p>并非一定要事先准备一个数组才能创建数组切片。Go 语言提供的内置函数 <code class="language-plaintext highlighter-rouge">make()</code> 可以用于灵活地创建数组切片。</p>

<p>创建一个初始元素个数为5的数组切片，元素初始值为0:</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mySlice1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span> <span class="kt">int</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span> 
</code></pre></div></div>

<p>创建一个初始元素个数为5的数组切片，元素初始值为0，并预留10个元素的存储空间:</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mySlice2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span> <span class="kt">int</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span> 
</code></pre></div></div>

<p>直接创建并初始化包含5个元素的数组切片:</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mySlice3</span> <span class="o">:=</span> <span class="p">[]</span> <span class="kt">int</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">}</span>
</code></pre></div></div>

<p><strong>元素遍历</strong></p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">mySlice</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span> 
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"mySlice["</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s">"] ="</span><span class="p">,</span> <span class="n">mySlice</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div></div>

<p>使用range关键字可以让遍历代码显得更整洁。range表达式有两个返回值，第一个是索引，第二个是元素的值:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">mySlice</span> <span class="p">{</span> 
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"mySlice["</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s">"] ="</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>动态增减元素</strong></p>

<p>当存储的数据比创建时设置的多时，数组切片会自动的重新分配。</p>

<p><code class="language-plaintext highlighter-rouge">cap()</code>:  返回的是数组切片分配的空间大小。</p>

<p><code class="language-plaintext highlighter-rouge">len()</code> :  返回的是 数组切片中当前所存储的元素个数。</p>

<p><code class="language-plaintext highlighter-rouge">append()</code>: 从后面追加数据。第二个参数其实是一个不定参数，我们可以按自己需求添加若干个元素，甚至直接将一个数组切片追加到另一个数组切片的末尾。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mySlice</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">mySlice</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>

<span class="n">mySlice2</span> <span class="o">:=</span> <span class="p">[]</span><span class="n">_int_</span><span class="p">{</span><span class="m">8</span><span class="p">,</span> <span class="m">9</span><span class="p">,</span> <span class="m">10</span><span class="p">}</span>

<span class="c">// 给mySlice后面添加另一个数组切片</span>
<span class="n">mySlice</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">mySlice</span><span class="p">,</span> <span class="n">mySlice2</span><span class="o">...</span><span class="p">)</span>
</code></pre></div></div>

<p>实现方式：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">appendInt</span><span class="p">(</span><span class="n">x</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">z</span> <span class="p">[]</span><span class="kt">int</span>
    <span class="n">zlen</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="m">1</span>
    
    <span class="k">if</span> <span class="n">zlen</span> <span class="o">&lt;=</span> <span class="nb">cap</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="p">[</span><span class="o">:</span><span class="nb">len</span><span class="p">]</span>
    <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
        <span class="n">zcap</span> <span class="o">:=</span> <span class="n">zlen</span>
        <span class="k">if</span> <span class="nb">cap</span> <span class="o">&lt;</span> <span class="m">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">zcap</span> <span class="o">=</span> <span class="m">2</span><span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">mak</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="n">zlen</span><span class="p">,</span> <span class="n">zcap</span><span class="p">)</span>
        <span class="nb">copy</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">z</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="o">=</span> <span class="n">y</span>
    <span class="k">return</span> <span class="n">z</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">copy()</code> : 将内容从一个数组切片复制到另一个数组切片。</p>

<p><strong>其他：</strong></p>

<p>1、slice 的语法和数据有很像，只是没有固定长度。</p>

<p>2、多个 slice 之间可以共享底层的数据，并全引用的数组部分区间可能重叠。</p>

<p>3、和数组不同的时是,slice 之间不能比较。因此我们不能使用<code class="language-plaintext highlighter-rouge">==</code>操作来判两个 slice 是否含有全部相等元素。</p>

<p>4、之所以不直接比较去运算符，有两方面，一是 slice 的元素是间接引用，一个 slice 甚至可以包含自身。二是 slice 在不同的时间可能包含不同元素，底层数据的元素可能会被修改。</p>

<p>5、测试一个slice是否是空的， <code class="language-plaintext highlighter-rouge">len(s) == 0</code>, 不应该用<code class="language-plaintext highlighter-rouge">s==nil</code> 来判断。</p>

<p>6、<code class="language-plaintext highlighter-rouge">x[m:n]</code> 切处操作对于字符串则生成一个新字符串，如果x是<code class="language-plaintext highlighter-rouge">[]byte</code>的话则生成一个新<code class="language-plaintext highlighter-rouge">[]byte</code>。</p>

<h2 id="map">map</h2>

<p>map是一堆键值对的未排序集合，底层是用哈希表做的。</p>

<p>变量声明：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">myMap</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span> <span class="n">PersonInfo</span>
</code></pre></div></div>

<p>内置的函数make()来创建:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">myMap</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span> <span class="n">PersonInfo</span><span class="p">)</span>
</code></pre></div></div>

<p>元素赋值:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">myMap</span><span class="p">[</span><span class="s">"1234"</span><span class="p">]</span> <span class="o">=</span> <span class="n">PersonInfo</span><span class="p">{</span><span class="s">"1"</span><span class="p">,</span> <span class="s">"Jack"</span><span class="p">,</span> <span class="s">"Room 101,..."</span><span class="p">}</span>
</code></pre></div></div>

<p>元素删除用内置函数<code class="language-plaintext highlighter-rouge">delete()</code></p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">delete</span><span class="p">(</span><span class="n">myMap</span><span class="p">,</span> <span class="s">"1234"</span><span class="p">)</span>
</code></pre></div></div>

<p>元素查找:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">value</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">myMap</span><span class="p">[</span><span class="s">"1234"</span><span class="p">]</span>
<span class="k">if</span> <span class="n">ok</span><span class="p">{</span><span class="c">// 找到了</span>

<span class="c">// 处理找到的value </span>
<span class="p">}</span>
</code></pre></div></div>

<p>其他：</p>

<p>1、不能对map的元素进行取址操作</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ages</span><span class="p">[</span><span class="s">"bob"</span><span class="p">]</span> <span class="c">// compile error :cannot take address of map `elemnet</span>
</code></pre></div></div>

<p>2、随着map的元素的增多，可能会重新进行分配空间。</p>

<p>3、和clice一样，map之间不能进行相等的比较，唯一的例外是和nil进行比较。要判断两个是否包含相同的key和value。要循环一个一个来。</p>

<h2 id="结构体">结构体</h2>

<p>通常一行对应一个结构体成员，成员的名字在前类型在后，不过如果相邻的成员类型如果相同的话，可以被合并到一行。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Employee</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">ID</span> <span class="kt">int</span>
    <span class="n">Name</span><span class="p">,</span> <span class="n">Address</span> <span class="kt">string</span>
    <span class="n">Dob</span> <span class="n">time</span><span class="o">.</span><span class="n">Time</span>
<span class="p">}</span>
</code></pre></div></div>

<p>1、结构体成员的输入顺序也有重要的意义。 如果要交换 Name 和 Address 出现的顺序，那么就是定义不同的结构类型。</p>

<p>2、如果结构体成员名字是以大写字母开头的，那么成员就是导出的，这是GO语言导出决定的。一个结构体可能同时包含导出和未导出的成员。</p>

<p>3、一个命名为 S 的结构体类型不能含有 S 类型的成员。因为一个聚合的值不能包含它自身。但是 S 类型的结构可以包含<code class="language-plaintext highlighter-rouge">*S</code>指针类型成员。</p>

<p>4、结构体的零值是每个成员都是零值。</p>

<p>5、结构体没有任何成员的是空结构体，写作<code class="language-plaintext highlighter-rouge">struct{}</code>`。它的大小为 0,不包含任何信息。</p>

<p>6、如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回。</p>

<p>7、结构体嵌入和匿名成员。Go 语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字，这类成员就是叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。</p>

<p>8、不能同进包含两个类型相同的匿名成员，这会导致名字冲突。成员的名字是由其类型隐匿地决定的。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Point</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Cirecle</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Point</span>
    <span class="n">Radius</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Wheel</span> <span class="k">struct</span><span class="p">{</span>
	<span class="n">Circle</span>
	<span class="n">Spokes</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="四流程控制">四、流程控制</h1>

<p>流程控制只是为了控制程序语句的执行顺序，一般需要与各种条件配合，因此， 在各种流程中，会加入条件判断语句。流程控制语句一般起以下3个作用：</p>

<ul>
  <li><strong>选择</strong>，即根据条件跳转到不同的执行序列。</li>
  <li><strong>循环</strong>，即根据条件反复执行某个序列，当然每一次循环执行的输入输出可能会发生变化。</li>
  <li><strong>跳转</strong>，即根据条件返回到某执行序列。</li>
</ul>

<p>Go 语言支持如下的几种流程控制语句:</p>

<ul>
  <li><strong>条件语句</strong>，对应的关键字为if、else 和 else if。</li>
  <li><strong>选择语句</strong>，对应的关键字为switch、case 和select (将在介绍channel的时候细说)。</li>
  <li><strong>循环语句</strong>，对应的关键字为 for 和 range。</li>
  <li><strong>跳转语句</strong>，对应的关键字为 goto。</li>
</ul>

<p>左花括号<code class="language-plaintext highlighter-rouge">{</code>必须与<code class="language-plaintext highlighter-rouge">for</code> 处于同一行。
如：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// if </span>
<span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="m">5</span> <span class="p">{</span> 
    <span class="k">return</span> <span class="m">0</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> 
    <span class="k">return</span> <span class="m">1</span>
<span class="p">}</span>

<span class="c">// switch </span>
<span class="k">switch</span> <span class="n">i</span> <span class="p">{</span> 
    <span class="k">case</span> <span class="m">0</span><span class="o">:</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"0"</span><span class="p">)</span> 
    <span class="k">case</span> <span class="m">1</span><span class="o">:</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"1"</span><span class="p">)</span> 
    <span class="k">case</span> <span class="m">2</span><span class="o">:</span>
        <span class="k">fallthrough</span> 
    <span class="k">case</span> <span class="m">3</span><span class="o">:</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"3"</span><span class="p">)</span> 
    <span class="k">case</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">6</span><span class="o">:</span>
         <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"4, 5, 6"</span><span class="p">)</span> 
    <span class="k">default</span><span class="o">:</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Default"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// for </span>
<span class="n">sum</span> <span class="o">:=</span> <span class="m">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span> 
<span class="p">}</span>

<span class="c">// break，可以选择中断哪一个循环</span>
<span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="m">5</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="m">5</span> <span class="p">{</span> 
            <span class="k">break</span> <span class="n">JLoop</span>
        <span class="p">}</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span> 
<span class="p">}</span>

<span class="n">JLoop</span><span class="o">:</span> 
<span class="c">// ...</span>

</code></pre></div></div>

<h1 id="五函数">五、函数</h1>

<p>函数的定义：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">mymath</span> 
<span class="k">import</span> <span class="s">"errors"</span>

<span class="k">func</span> <span class="n">Add</span><span class="p">(</span><span class="n">a</span> <span class="kt">int</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">ret</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="o">||</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="p">{</span> <span class="c">// 假设这个函数只支持两个非负数字的加法</span>
        <span class="n">err</span><span class="o">=</span> <span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s">"Should be non-negative numbers!"</span><span class="p">)</span>
       <span class="k">return</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="no">nil</span> <span class="c">// 支持多重返回值 </span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果参数列表中若干个相邻的参数类型的相同，比如上面例子中的a和b，则可以在参数列表中省略前面变量的类型声明，如果返回值列表中多个返回值的类型相同，也可以用同样的方式合并。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span>  <span class="n">Add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="n">_int_</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> 
   <span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>函数调用:</p>

<p>函数调用非常方便，只要事先导入了该函数所在的包。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="s">"mymath"</span><span class="c">// 假设Add被放在一个叫mymath的包中 // ...</span>

<span class="n">c</span> <span class="o">:=</span> <span class="n">mymath</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span>
</code></pre></div></div>

<p>Go 语言中函数名字的大小写不仅仅是风格，更直接体现了该函数的可见性。<strong>写字母开头的函数只在本包内可见，大写字母开头的函数才能被其他包使用。</strong></p>

<h2 id="不定参数">不定参数</h2>

<p><strong>1、不定参数类型</strong></p>

<p>不定参数是指函数传入的参数个数为不定数量。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">myfunc</span><span class="p">(</span><span class="n">args</span> <span class="o">...</span><span class="n">_int_</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">arg</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">args</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">// 方式调用:</span>
<span class="n">myfunc</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span>
<span class="n">myfunc</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">13</span><span class="p">)</span>
</code></pre></div></div>
<p>形如 <code class="language-plaintext highlighter-rouge">...type</code> 格式的类型只能作为函数的参数类型存在，并且必须是最后一个参数。</p>

<p>类型<code class="language-plaintext highlighter-rouge">...type</code> 本质上是一个数组切片，也就是[]type，这也是为 什么上面的参数 args 可以用 for 循环来获得每个传入的参数。</p>

<p><strong>2、 不定参数的传递</strong></p>

<p>有另一个变参函数叫做<code class="language-plaintext highlighter-rouge">myfunc3(args ...int)</code>，下面的例子演示了如何向其传递变参:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">myfunc</span><span class="p">(</span><span class="n">args</span> <span class="o">...</span><span class="n">_int_</span><span class="p">)</span> <span class="p">{</span> <span class="c">// 按原样传递</span>
    <span class="n">myfunc3</span><span class="p">(</span><span class="n">args</span><span class="o">...</span><span class="p">)</span>
   <span class="c">// 传递片段，实际上任意的int slice都可以传进去</span>
   <span class="n">myfunc3</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="m">1</span><span class="o">:</span><span class="p">]</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>3、任意类型的不定参数</strong></p>

<p>如果希望传任意类型，可以指定类型为 <code class="language-plaintext highlighter-rouge">interface{}</code>。下面是 Go 语言标准库中 <code class="language-plaintext highlighter-rouge">fmt.Printf()</code> 的函数原型:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Printf</span><span class="p">(</span><span class="n">format</span> <span class="n">_string_</span><span class="p">,</span> <span class="n">args</span> <span class="o">...</span><span class="k">interface</span><span class="p">{})</span> <span class="p">{</span> <span class="c">// ...</span>

<span class="p">}</span>
</code></pre></div></div>

<h2 id="多返回值">多返回值</h2>

<p>go 语言的函数可以用多个返回值如：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">file</span> <span class="o">*</span><span class="n">File</span><span class="p">)</span> <span class="n">Read</span><span class="p">(</span><span class="n">b</span> <span class="p">[]</span><span class="n">_byte_</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">,</span> <span class="n">err</span> <span class="n">Error</span><span class="p">)</span>
</code></pre></div></div>

<p>Go语言并不需要强制命名返回值，但是命名后的返回值可以让代码更清晰，可读性更强， 同时也可以用于文档。</p>

<h2 id="匿名函数与闭包">匿名函数与闭包</h2>

<p><strong>匿名函数</strong>是指不需要定义函数名的一种函数实现方式。函数可以像普通变量一样被传递或使用。匿名函数可以直接赋值给一个变量或者直接执行：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> 
   <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="p">}</span>
</code></pre></div></div>

<p>闭包: 是可以包含自由(未绑定到特定对象)变量的代码块，些变量不在这个代码块内或者 任何全局上下文中定义，而是在定义代码块的环境中定义。要执行的代码块(由于自由变量包含 在代码块中，所以这些自由变量以及它们引用的对象没有被释放)为自由变量提供绑定的计算环 境(作用域)。</p>

<h1 id="六错误处理">六、错误处理</h1>

<h2 id="error-接口">error 接口</h2>

<p>Go 语言引入了一个关于错误处理的标准模式，即 error 接口，该接口的定义如下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">error</span> <span class="k">interface</span> <span class="p">{</span> 
    <span class="n">Error</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="defer-函数">defer 函数</h2>

<p>当 defer 语句被执行时，跟在 defer 后面的函数会被延迟执行。直到包含该 defer 语句的函数执行完毕时，defer 后的函数才会被执行，不论包含 defer 语句的函数是通过 return 正常结束，还是由于 panic 导致的异常结束。你可以在一个函数中执行多条 defer 语句。如：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">CopyFile</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span> <span class="n">_string_</span><span class="p">)</span> <span class="p">(</span><span class="n">w</span> <span class="n">_int64_</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span> 

    <span class="n">srcFile</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="k">defer</span> <span class="n">srcFile</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
    <span class="n">dstFile</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Create</span><span class="p">(</span><span class="n">dstName</span><span class="p">)</span> 
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="k">defer</span> <span class="n">dstFile</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">io</span><span class="o">.</span><span class="n">Copy</span><span class="p">(</span><span class="n">dstFile</span><span class="p">,</span> <span class="n">srcFile</span><span class="p">)</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>defer 语句的调用是遵照 <strong>先进后出的原则，即最后一个defer语句将最先被执行</strong>。</p>

<p>defer 语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。释放资源的 defer 应该直接跟在请求资源的语句后。</p>

<p>调试复杂程序时，defer机制也常被用于记录何时进入和退出函数。下例中的bigSlowOperation函数，直接调用trace记录函数的被调用情况。通过这种方式，我们可以只通过一个语句控制函数的入口和所有的出口，甚至可以记录函数的运行时间，需要注意一点：不要忘记defer语句的圆的括号。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">func</span> <span class="n">bigSlowOperation</span><span class="p">()</span> <span class="p">{</span>

<span class="k">defer</span> <span class="n">trace</span><span class="p">(</span><span class="s">"bigSlowOperation"</span><span class="p">)()</span> <span class="c">// don't forget the</span>

<span class="n">extra</span> <span class="n">parentheses</span>

<span class="c">// ...lots of work…</span>

<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">10</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span> <span class="c">// simulate slow</span>

<span class="n">operation</span> <span class="n">by</span> <span class="n">sleeping</span>

<span class="p">}</span>

<span class="k">func</span> <span class="n">trace</span><span class="p">(</span><span class="n">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>

<span class="n">start</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span>

<span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"enter %s"</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

<span class="k">return</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>

<span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"exit %s (%s)"</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span><span class="n">time</span><span class="o">.</span><span class="n">Since</span><span class="p">(</span><span class="n">start</span><span class="p">))</span>

<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="panic-和-recover-函数">panic() 和 recover() 函数</h2>

<p>Go 语言引入了两个内置函数 <code class="language-plaintext highlighter-rouge">panic()</code> 和<code class="language-plaintext highlighter-rouge">recover()</code> 以报告和处理运行时错误和程序中的错误场景。简单的说是：抛出一个panic 的异常，然后在 defer 中通过 recover 捕获这个异常，然后正常处理。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"c"</span><span class="p">)</span>
     <span class="k">defer</span> <span class="k">func</span><span class="p">(){</span> <span class="c">// 必须要先声明defer，否则不能捕获到panic异常</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"d"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err</span><span class="o">:=</span><span class="nb">recover</span><span class="p">();</span><span class="n">err</span><span class="o">!=</span><span class="no">nil</span><span class="p">{</span>
            <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="c">// 这里的err其实就是panic传入的内容，55</span>
        <span class="p">}</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"e"</span><span class="p">)</span>
    <span class="p">}()</span>

    <span class="n">f</span><span class="p">()</span> <span class="c">//开始调用f</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"f"</span><span class="p">)</span> <span class="c">//这里开始下面代码不会再执行</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">f</span><span class="p">(){</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">"异常信息"</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"b"</span><span class="p">)</span> <span class="c">//这里开始下面代码不会再执行</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"f"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>输出结果：</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c
a
d
异常信息
e
</code></pre></div></div>

  		
	  </article>
    </div>

</div>





	<div class="article-author">
    <div class="avatar">
    <img width="50" height="50" src="/images/header.png" alt=" Avatar"/>
    </div>
    <div class="name">
        <h4><b>carlos</b> </h4>
        Just for fun!
    </div>
</div>


	<!--
	
	    <!--
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = '';
	(function() {
	    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	    dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
	    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
 -->
	
    -->


<!--
<div class="cnzz"><script src="http://s4.cnzz.com/z_stat.php?id=1255123325&web_id=1255123325" language="JavaScript"></script> </div>
 -->

        </div>
      </div>
    </div>

    </body>
</html>
