<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="author" content="xyecho" />
    <title>服务发现原理</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <link href="/feed/" rel="alternate" title="xyecho" type="application/atom+xml" />
    <link rel="stylesheet" href="/media/css/style.css" />
    <link rel="stylesheet" href="/media/css/highlight.css" />
    <script type="text/javascript" src="/media/js/jquery-1.7.1.min.js"></script>
  </head>
  <body>
    <div id="container">
      <div id="main" role="main">
        <header>
        <h1>服务发现原理</h1>
        </header>
        <nav>
        <span><a title="网站首页" class="" href="/">首页</a></span>
        <span><a title="文章分类" class="" href="/categories/">分类</a></span>
        <span><a title="标签索引" class="" href="/tags/">标签</a></span>
        <!--<span><a title="友情链接" class="" href="/links/">链接</a></span>-->
        <span><a title="留言交流" class="" href="/guestbook/">留言</a></span>
        <span><a title="关于站长" class="" href="/about/">关于</a></span>
        <span><a title="种子订阅" class="" href="/feed/" target="_blank">订阅</a></span>
        </nav>
        <article class="content">
        <section class="meta">
<span class="time">
  <time datetime="2022-01-26">2022-01-26</time>
</span>

 | 
<span class="categories">
  分类
  
  <a href="/categories/#系统设计" title="系统设计">系统设计</a>&nbsp;
  
</span>


 | 
<span class="tags">
  标签
  
  <a href="/tags/#工作经验" title="工作经验">工作经验</a>&nbsp;
  
</span>

</section>
<section class="post">
<h1 id="一概述">一、概述</h1>

<p>在微服务分布式框架中，服务被拆分成很微小服务，各自独立。由多个台机器组成，各服务之间相互调用，有管理各种服务的需求。 服务发现机制可以降低服务管理的成本。</p>

<p>在服务发现之前，服务之间的调用，可能要在各服务代码中写死IP 或者 通过配置文件读出服务之间的IP。</p>

<p>服务发现机制则一分两步:</p>

<p>1、服务注册。 在服务启动时，把自己的<strong>IP和端口</strong> 通过服务注册定入到服务管理平台中，以便提供给其他主调用。</p>

<p>2、服务发现。其他方调用时则要先通过服务平台拿到这个服务其中的一个<strong>IP和端口</strong>，然后再调用。</p>

<p>如图：</p>

<p><img src="/assets/system-design/service-discovery-2022-09-23_11-53-40.png" alt="" /></p>

<p>说明：</p>

<p>1、 server b 把自己注册到  service registry  叫做 <strong>服务注册</strong>。</p>

<p>2、 server  a  从 service registry 发现 server b 的节点信息叫做 <strong>服务发现</strong>。</p>

<p>3、最后 server a 调用 server b。</p>

<h1 id="二服务注册">二、服务注册</h1>

<p>服务注册，简单的说是，就是把自己的IP和端口写到服务管理平台上形成一组服务，告诉所有其他的服务，想调用我，可以通过服务管理平台上的服务名找到我的IP和端口。</p>

<p>服务注册的大概框架图：</p>

<p><img src="/assets/system-design/service-discovery-2022-09-23_00-58-18.png" alt="" /></p>

<p>一般一个服务会有多个 IP 和端口。 如：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="err">user</span><span class="w"> </span><span class="err">server</span><span class="w"> 
</span><span class="p">[</span><span class="w">
	</span><span class="p">{</span><span class="w"> 
		</span><span class="nl">"ip"</span><span class="p">:</span><span class="mf">127.0</span><span class="err">.</span><span class="mf">0.1</span><span class="p">,</span><span class="w">
		</span><span class="nl">"port"</span><span class="p">:</span><span class="mi">8800</span><span class="w">
	</span><span class="p">},</span><span class="w">
	</span><span class="p">{</span><span class="w"> 
		</span><span class="nl">"ip"</span><span class="p">:</span><span class="mf">127.0</span><span class="err">.</span><span class="mf">0.2</span><span class="p">,</span><span class="w">
		</span><span class="nl">"port"</span><span class="p">:</span><span class="mi">8800</span><span class="w">
	</span><span class="p">},</span><span class="w">
	</span><span class="p">{</span><span class="w"> 
		</span><span class="nl">"ip"</span><span class="p">:</span><span class="mf">127.0</span><span class="err">.</span><span class="mf">0.3</span><span class="p">,</span><span class="w">
		</span><span class="nl">"port"</span><span class="p">:</span><span class="mi">8800</span><span class="w">
	</span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="w">

</span><span class="err">#</span><span class="w"> </span><span class="err">live</span><span class="w"> </span><span class="err">server</span><span class="w"> 
</span><span class="p">[</span><span class="w">
	</span><span class="p">{</span><span class="w"> 
		</span><span class="nl">"ip"</span><span class="p">:</span><span class="mf">127.0</span><span class="err">.</span><span class="mf">1.1</span><span class="p">,</span><span class="w">
		</span><span class="nl">"port"</span><span class="p">:</span><span class="mi">8801</span><span class="w">
	</span><span class="p">},</span><span class="w">
	</span><span class="p">{</span><span class="w"> 
		</span><span class="nl">"ip"</span><span class="p">:</span><span class="mf">127.0</span><span class="err">.</span><span class="mf">1.2</span><span class="p">,</span><span class="w">
		</span><span class="nl">"port"</span><span class="p">:</span><span class="mi">8801</span><span class="w">
	</span><span class="p">},</span><span class="w">
	</span><span class="p">{</span><span class="w"> 
		</span><span class="nl">"ip"</span><span class="p">:</span><span class="mf">127.0</span><span class="err">.</span><span class="mf">1.3</span><span class="p">,</span><span class="w">
		</span><span class="nl">"port"</span><span class="p">:</span><span class="mi">8801</span><span class="w">
	</span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="w">

</span></code></pre></div></div>

<p>说明：</p>

<p>1、业务服务会向服务平台注册一个服务名，把自己的 IP和端口号写入。</p>

<p>2、一般情况下，同一个服务，所有端口最好一样，方便管理。</p>

<p>3、以现在docker 的技术，一般是一个实例只能跑一个业务服务。但也有企业了节约成本，也会在同一个docker 跑多个服务。</p>

<p>4、有的解决方案是在服务管理平台手动的写入服务名和对应的IP列表。 服务名要全局惟一。</p>

<h1 id="三服务发现">三、服务发现</h1>

<p>服务发现，即当server a 想请求 serve b 时，应该如何找到合适的IP和端口呢？如：</p>

<p>user sever 这个服务 有三台机器，  live server  也有三台机器。 live sever1  想请求 user server  的业务接口。它就应该先请求服务管理平台。</p>

<p>服务管理平台返回了 user server 中的一个IP和端口。 （负载均衡后的结果）</p>

<p><img src="/assets/system-design/service-discovery-2022-09-23_11-09-13.png" alt="" /></p>

<p>上图说明：</p>

<p>1、 live server1 想请求 user server 中的接口。</p>

<p>2、live server1 要请求服务管理平台，服务管理平台返回了 user server 其中的一个IP 和 端口。 （user server2）</p>

<p>3、live server1 再请求 user server2</p>

<p>这样就完成一个服务的调用。</p>

<h1 id="四活跃检测">四、活跃检测</h1>

<p>服务发现机制，除了在微服务分布式系统中方便服务之间的调用后，还是功能就两个是活跃检测和负载均衡。</p>

<p>即服务管理平台会向注册的服务发送请求，确认服务是否可用，如果服务不可用或机器已挂机。即标记该 IP 不可用，或者直接摘机。</p>

<p>另一种方式是注册的服务定时的向服务管理平台发送确认的状态。告诉服务管理平台，自己还是活跃的。</p>

<p>当时发现服务不通时，可以进行摘机。即把IP从列表中移除掉。</p>

<p>所以，服务提供方一般都要求两个机器以上，这样可以起到容灾的作用。 要求高一点，可以要求机器在不同机房。当一个机房出问题时，另一个机器的服务可以支持着服务。</p>

<p><img src="/assets/system-design/service-discovery-2022-09-23_01-04-49.png" alt="" /></p>

<h1 id="五负载均衡">五、负载均衡</h1>

<p>服务请求时，提供方的服务是无状态的，会存在多个IP，我们只需求访问其中一个IP即可。 所以，服务管理平台同时也起了负载均衡的作用，只返回一个合适的IP。</p>

<p>当然，也有的策略是返回多个 IP， 让调用方自己去选择那个IP访问。</p>

<p>这里也导致一个问题，即所有请求都会预先请求服务管理平台。流量大的时侯会有瓶颈。解决的方案的是，请求到一个IP后，可以在本地缓存几秒钟，减少因流量峰值而带来服务管理平台的压力。</p>

<p><a href="http://blog.xyecho.com/load-balancing-and-reverse-proxy/">负载均衡策略：http://blog.xyecho.com/load-balancing-and-reverse-proxy/</a></p>

<h1 id="五服务发现技术点">五、服务发现技术点</h1>

<p>一套完整的服务发现平台，所需要的技术点：</p>

<p>1、 集群、分布式。 要应对大流量的服务，就一定要用到分布式集群。同时也起到容灾的作用。</p>

<p>2、强一致性、数据同步。由于分布式， 所以数据的一定要同步到每一台机器上，同时也要保证每一台机器的上的数据是一致的。</p>

<p>3、高并发、高可用。服务请求都要预先请求一次服务管理平台，所以流量会比较大。不能因为服务发现的加入而导致整体的性能下降太多。</p>

<p>4、部署管理简单。 简单的管理和好的体验，会让更多开发者去运用它。</p>

<h1 id="六开源的解决方案">六、开源的解决方案</h1>

<p>有资源的企业会基于源开放的解决方案上做一些二次开发，以适用于本企业的研发文化。 github 上也有一些比较靠谱的解决方案。如：
<code class="language-plaintext highlighter-rouge">etcd</code> 、<code class="language-plaintext highlighter-rouge">zookeeper</code> 、<code class="language-plaintext highlighter-rouge">consul</code> 等。都具有安全稳定，高可用，高并发。强一致性的特点。</p>

<p>1、<code class="language-plaintext highlighter-rouge">etcd</code>  : <a href="https://github.com/etcd-io/etcd">https://github.com/etcd-io/etcd</a></p>

<p>2、<code class="language-plaintext highlighter-rouge">zookeeper</code> : <a href="https://github.com/apache/zookeeper">https://github.com/apache/zookeeper</a></p>

<p>3、<code class="language-plaintext highlighter-rouge">consul</code> :<a href="https://github.com/hashicorp/consul">https://github.com/hashicorp/consul</a></p>

<hr />
<p>1、<a href="https://zhuanlan.zhihu.com/p/161277955">深入了解服务注册与发现 : https://zhuanlan.zhihu.com/p/161277955</a></p>

<p>2、<a href="https://zhuanlan.zhihu.com/p/409154290">服务注册与发现的原理和实现 : https://zhuanlan.zhihu.com/p/409154290</a></p>


</section>
<section align="right">
<br/>
<span>
	<a  href="/server-system-design-idea/" class="pageNav"  >上一篇</a>
	&nbsp;&nbsp;&nbsp;
	<a  href="/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/" class="pageNav"  >下一篇</a>
</span>
</section>
<!-- JiaThis Button BEGIN -->
<script type="text/javascript">
var jiathis_config = {data_track_clickback:'true'};
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jiathis_r.js?move=0&amp;uid=2121774" charset="utf-8"></script>
<!-- JiaThis Button END -->


	
	<div class="ds-thread" />
		
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"xyecho"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = 'http://static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		|| document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>


<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fc91691cf4004b194f7847896cca17dbb' type='text/javascript'%3E%3C/script%3E"));
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-56673760-1', 'auto');
  ga('send', 'pageview');

</script>

        </article>
      </div>

    <footer>
        <p>
          <script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fc91691cf4004b194f7847896cca17dbb' type='text/javascript'%3E%3C/script%3E"));
</script>

          <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-56673760-1', 'auto');
  ga('send', 'pageview');

</script>
        </p>
        <p><small>
            <a href="http://github.com/CarlosFang/CarlosFang.github.io/new/gh-pages/_posts" target="_blank" title="撰写文章">Po</a>wer<a href="http://github.com/CarlosFang/CarlosFang.github.io/edit/gh-pages/_posts/it-note/2022-01-25-server-service-discovery.md" target="_blank" title="编辑页面">ed</a> by <a href="http://jekyllrb.com" target="_blank">Jekyll</a> @ <a href="http://github.com/CarlosFang/CarlosFang.github.io" target="_blank" title="项目主页">GitHub</a>
             | <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank" title="许可协议">©</a> 2014 - 2022 <a href="/about/">xyecho</a>
             | <a href="http://blog.xyecho.com" target="_blank">@cnblogs</a>


         </small></p>
    </footer>

    </div>
  </body>
</html>
