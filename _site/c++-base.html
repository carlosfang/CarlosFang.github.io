<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>c++ 基础知识</title>

    <meta name="viewport" content="width=device-width">
    <meta name="description" content="">

    
    

    <link rel="canonical" href="http://localhost:4000/c++-base">
    <link rel="icon" type="image/png" href="/images/logo.png">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/monster.css">

    

</head>


    <body>
    
    <div class="wrapper">

      <header class="header">

  <div class="site-title">
    
    <h4 class="entry-title"><a href="/c++-base">c++ 基础知识</a></h4>
    
  </div>

<div class="links">
    
    <a href="/" class="page-link">Blog</a>
    
    
    
    
      <a class="page-link"
        href="/about/">About</a>
    
    
    
      <a class="page-link"
        href="/categories">Categories</a>
    
    
    
    
    
    
    
      <a class="page-link"
        href="/links/">Links</a>
    
    
    
    
    
      <a class="page-link"
        href="/tags">Tags</a>
    
    
    <a href="/feed.xml" target="_blank" class="page-link">RSS</a>
</div>
</header>

      
      <div class="navi">
    
    <a href="/" class="page-link">Blog</a>
    
    
    
    
      <a class="page-link"
        href="/about/">About</a>
    
    
    
      <a class="page-link"
        href="/categories">Categories</a>
    
    
    
    
    
    
    
      <a class="page-link"
        href="/links/">Links</a>
    
    
    
    
    
      <a class="page-link"
        href="/tags">Tags</a>
    
    
    <a href="/feed.xml" target="_blank" class="page-link">RSS</a>
</div>


      <div class="content">
        <div class="articles">
            <div class="article-meta">
    2017-04-03
     • Category: 
        
        <a href="/categories//#c++-ref" >C++</a>
        
    
     • Tag: 
        
            <a href="/tags//#c++-ref" >C++</a>
        
    
</div>

<div class="entry post">

	<div class="entry-content">
	  <article class="entry-body">
	  	
	  		<h1 id="一-变量">一 变量</h1>

<h2 id="11--全局变量">1.1  全局变量</h2>

<p>具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量。</p>

<h2 id="12-局部变量">1.2 局部变量</h2>

<p>具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</p>

<h2 id="13-静态全局变量">1.3 静态全局变量</h2>

<p>有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。
一般被分配在到栈中。</p>

<ul>
  <li>静态存储区：全局变量，静态局部变量，静态全局变量。</li>
  <li>栈：局部变量。</li>
  <li>静态变量和全局变量的区别：静态变量用 <code class="language-plaintext highlighter-rouge">static</code> 告知编译器，自己仅仅在变量的作用范围内可见。</li>
</ul>

<p>如果在头文件中定义全局变量，当该头文件被多个文件 <code class="language-plaintext highlighter-rouge">include</code> 时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能再头文件中定义全局变量。</p>

<p>这个重复定义是在链接时就报错误的。</p>

<p>在头文件中定义全局变量即使用 <code class="language-plaintext highlighter-rouge">#ifndef</code>  是解决同一个 cpp 文件 include 多次头文件。而不是多个 cpp 文件 include 同一个应文件。</p>

<h2 id="14-几种制类型转换">1.4 几种制类型转换</h2>

<p><strong>static_cast</strong>：用于数据的强制类型转换，强制将一种数据类型转换为另一种数据类型。</p>

<p>用于基本数据类型的转换：</p>

<p>1、  用于类层次之间的基类和派生类之间 指针或者引用 的转换（不要求必须包含虚函数，但必须是有相互联系的类），进行上行转换（派生类的指针或引用转换成基类表示）是安全的；进行下行转换（基类的指针或引用转换成派生类表示）由于没有动态类型检查，所以是不安全的，最好用 dynamic_cast 进行下行转换。</p>

<p>2、 可以将空指针转化成目标类型的空指针。</p>

<p>3、 可以将任何类型的表达式转化成 void 类型。</p>

<p>4、 const_cast：强制去掉常量属性，不能用于去掉变量的常量性，只能用于去除指针或引用的常量性，将常量指针转化为非常量指针或者将常量引用转化为非常量引用（注意：表达式的类型和要转化的类型是相同的）。</p>

<p><strong>reinterpret_cast</strong>：改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转化为指针或引用类型。</p>

<p><strong>dynamic_cast</strong>：</p>

<p>1、 其他三种都是编译时完成的，动态类型转换是在程序运行时处理的，运行时会进行类型检查。</p>

<p>2、 只能用于带有虚函数的基类或派生类的指针或者引用对象的转换，转换成功返回指向类型的指针或引用，转换失败返回 NULL；不能用于基本数据类型的转换。</p>

<p>3、 在向上进行转换时，即派生类类的指针转换成基类类的指针和 static_cast 效果是一样的，（注意：这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）。</p>

<p>4、在下行转换时，基类的指针类型转化为派生类类的指针类型，只有当要转换的指针指向的对象类型和转化以后的对象类型相同时，才会转化成功。</p>

<h2 id="15--参数传递时值传递引用传递指针传递的区别">1.5  参数传递时，值传递、引用传递、指针传递的区别</h2>

<p>参数传递的三种方式：</p>

<p>1、 值传递：形参是实参的拷贝，函数对形参的所有操作不会影响实参。</p>

<p>2、 指针传递：本质上是值传递，只不过拷贝的是指针的值，拷贝之后，实参和形参是不同的指针，通过指针可以间接的访问指针所指向的对象，从而可以修改它所指对象的值。</p>

<p>3、 引用传递：当形参是引用类型时，我们说它对应的实参被引用传递。</p>

<h1 id="二-c11-的新特性">二 c++11 的新特性</h1>

<h2 id="21--auto-自动类型推导">2.1  <code class="language-plaintext highlighter-rouge">auto</code> 自动类型推导</h2>
<p>如：</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">var</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="p">;</span> 

<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">item</span> <span class="o">:</span> <span class="n">list</span><span class="p">){</span>

<span class="p">}</span>
</code></pre></div></div>

<h2 id="22-decltype类型推导">2.2 <code class="language-plaintext highlighter-rouge">decltype</code> 类型推导</h2>

<p>和 auto 的功能一样，都用来在编译时期进行自动类型推导。如果希望从表达式中推断出要定义的变量的类型，但是不想用该表达式的值初始化变量，这时就不能再用 auto。decltype 作用是选择并返回操作数的数据类型。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">var</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> 
<span class="k">decltype</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="n">var</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="23-lambda表达式">2.3 <code class="language-plaintext highlighter-rouge">lambda</code> 表达式</h2>

<p><code class="language-plaintext highlighter-rouge">lambda</code> 函数或者 <code class="language-plaintext highlighter-rouge">lambda</code> 匿名函数。</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 表达式：</span>
<span class="c1">// capture list：捕获列表，指 lambda 所在函数中定义的局部变量的列表，通常为空。</span>
<span class="c1">// return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。</span>


<span class="p">[</span><span class="n">capture</span> <span class="n">list</span><span class="p">]</span> <span class="p">(</span><span class="n">parameter</span> <span class="n">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">return</span> <span class="n">type</span>
<span class="p">{</span> 
	<span class="n">function</span> <span class="n">body</span><span class="p">;</span> 
<span class="p">};</span>

<span class="c1">// 例子</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="c1">//对 a 数组中的元素进行升序排序</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="o">+</span><span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span> <span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">:</span> <span class="n">arr</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>用来捕获上下文或者作用域中变量到lamda表达式函数体中使用，［=］意思是全部按值捕获变量，[&amp;]全部按引用捕获变量。</p>

<h2 id="24-范围for语句">2.4 范围 <code class="language-plaintext highlighter-rouge">for</code> 语句</h2>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 表达式：</span>
<span class="c1">// expression：必须是一个序列，例如用花括号括起来的初始值列表、数组、vector ，string 等，</span>
<span class="c1">// 这些类型的共同特点是拥有能返回迭代器的 beign、end 成员。</span>
<span class="c1">// declaration：此处定义一个变量，序列中的每一个元素都能转化成该变量的类型，常用 auto 类型说明符。</span>


<span class="k">for</span> <span class="p">(</span><span class="n">declaration</span> <span class="o">:</span> <span class="n">expression</span><span class="p">)</span>
<span class="p">{</span> 
	<span class="n">statement</span> 
<span class="p">}</span>


<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"hello world!"</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>  
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
程序执行结果为：
hello world!
*/</span>
</code></pre></div></div>

<h2 id="25-delete-函数和-default-函数">2.5 <code class="language-plaintext highlighter-rouge">delete</code> 函数和 <code class="language-plaintext highlighter-rouge">default</code> 函数</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">delete</code> 函数：<code class="language-plaintext highlighter-rouge">= delete</code> 表示该函数不能被调用。</li>
  <li><code class="language-plaintext highlighter-rouge">default</code> 函数：<code class="language-plaintext highlighter-rouge">= default</code> 表示编译器生成默认的函数，例如：生成默认的构造函数。</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">A</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// 表示使用默认的构造函数</span>
	<span class="o">~</span><span class="n">A</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>	<span class="c1">// 表示使用默认的析构函数</span>
	<span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// 表示类的对象禁止拷贝构造</span>
	<span class="n">A</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// 表示类的对象禁止拷贝赋值</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">A</span> <span class="n">ex1</span><span class="p">;</span>
	<span class="n">A</span> <span class="n">ex2</span> <span class="o">=</span> <span class="n">ex1</span><span class="p">;</span> <span class="c1">// error: use of deleted function 'A::A(const A&amp;)'</span>
	<span class="n">A</span> <span class="n">ex3</span><span class="p">;</span>
	<span class="n">ex3</span> <span class="o">=</span> <span class="n">ex1</span><span class="p">;</span> <span class="c1">// error: use of deleted function 'A&amp; A::operator=(const A&amp;)'</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="25--右值引用">2.5  右值引用</h2>
<ul>
  <li>左值引用的对象是变量</li>
  <li>右值引用的对象是常量</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">rr1</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>        <span class="c1">//正确，字面值常量是右值</span>
<span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">rr2</span> <span class="o">=</span> <span class="n">rr1</span><span class="p">;</span>        <span class="c1">//错误，表达式rr1是左值</span>
<span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">rr3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">rr1</span><span class="p">);</span>    <span class="c1">//正确</span>

</code></pre></div></div>

<h2 id="26-其他-constexprfinaloverridemove">2.6 其他 <code class="language-plaintext highlighter-rouge">constexpr</code>, <code class="language-plaintext highlighter-rouge">final</code>, <code class="language-plaintext highlighter-rouge">override</code>，<code class="language-plaintext highlighter-rouge">move()</code>,</h2>

<h1 id="三-面向对象">三 面向对象</h1>

<h2 id="31-面向对象的三大特性">3.1 面向对象的三大特性</h2>

<ul>
  <li><strong>封装</strong>：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。</li>
  <li><strong>继承</strong>：子类继承父类的特征和行为。</li>
  <li><strong>多态</strong>：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。</li>
</ul>

<p>这篇讲多态和虚继承讲得非常透彻。 <a href="https://leetcode.cn/link/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F65410057">https://zhuanlan.zhihu.com/p/65410057</a> </p>

<h2 id="32-重载重写隐藏的区别">3.2 重载、重写、隐藏的区别</h2>

<ul>
  <li><strong>重载</strong>：是指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。</li>
  <li><strong>隐藏</strong>：是指派生类的函数屏蔽了与其同名的基类函数，主要只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。</li>
  <li><strong>重写(覆盖)</strong>：是指派生类中存在重新定义的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 virtual 修饰。</li>
</ul>

<p><strong>重写和重载的区别</strong></p>

<p>范围区别：对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间（子类和父类之间）。</p>

<p>参数区别：重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有 virtual 修饰。</p>

<p>virtual 关键字：重写的函数基类中必须有 virtual关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有。</p>

<p><strong>隐藏和重写，重载的区别</strong></p>

<p>范围区别：隐藏与重载范围不同，隐藏发生在不同类中。</p>

<p>参数区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被 virtual 修饰，基类函数都是被隐藏，而不是重写。</p>

<h3 id="33-多态">3.3 多态</h3>

<p>多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。</p>

<p>在基类的函数前加上 virtual 关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。</p>

<p>如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</p>

<p>实现方法：多态是通过虚函数实现的，虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。</p>

<p><strong>实现过程</strong>：</p>

<p>在类中用 virtual 关键字声明的函数叫做虚函数；</p>

<p>存在虚函数的类都有一个虚函数表，当创建一个该类的对象时，该对象有一个指向虚函数表的虚表指针（虚函数表和类对应的，虚表指针是和对象对应）；
当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。</p>

<h1 id="四-其他">四 其他</h1>

<h2 id="41-include---和--的区别">4.1 include <code class="language-plaintext highlighter-rouge">" "</code> 和<code class="language-plaintext highlighter-rouge"> &lt;&gt; </code>的区别</h2>

<p>查找文件的位置：<code class="language-plaintext highlighter-rouge">include&lt;文件名&gt;</code> 在标准库头文件所在的目录中查找，如果没有，再到当前源文件所在目录下查找；#include”文件名” 在当前源文件所在目录中进行查找，如果没有；再到系统目录中查找。</p>

<p>使用习惯：对于标准库中的头文件常用<code class="language-plaintext highlighter-rouge"> include&lt;文件名&gt;</code><code class="language-plaintext highlighter-rouge">，对于自己定义的头文件，常用 </code>#include”文件名”`</p>

<hr />
<p>from leetcode <a href="https://leetcode.cn/leetbook/detail/cmian-shi-tu-po/">C++ 面试突破 https://leetcode.cn/leetbook/detail/cmian-shi-tu-po/</a></p>

  		
	  </article>
    </div>

</div>





	<div class="article-author">
    <div class="avatar">
    <img width="50" height="50" src="/images/header.png" alt=" Avatar"/>
    </div>
    <div class="name">
        <h4><b>carlos</b> </h4>
        Just for fun!
    </div>
</div>


	<!--
	
	    <!--
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = '';
	(function() {
	    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	    dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
	    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
 -->
	
    -->


<!--
<div class="cnzz"><script src="http://s4.cnzz.com/z_stat.php?id=1255123325&web_id=1255123325" language="JavaScript"></script> </div>
 -->

        </div>
      </div>
    </div>

    </body>
</html>
