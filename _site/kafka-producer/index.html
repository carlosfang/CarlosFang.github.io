<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="author" content="kane" />
    <title>Kafka 生产者和分区策略</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <link href="/feed/" rel="alternate" title="kane" type="application/atom+xml" />
    <link rel="stylesheet" href="/media/css/style.css" />
    <link rel="stylesheet" href="/media/css/highlight.css" />
    <script type="text/javascript" src="/media/js/jquery-1.7.1.min.js"></script>
  </head>
  <body>
    <div id="container">
      <div id="main" role="main">
        <header>
        <h1>Kafka 生产者和分区策略</h1>
        </header>
        <nav>
        <span><a title="Blog" class="content" href="/">Blog</a></span>
        <span><a title="Categories" class="content" href="/categories/">Categories</a></span>
        <span><a title="Tags" class="content" href="/tags/">Tags</a></span>
        <span><a title="Links" class="content" href="/links/">Link</a></span>
        <!--<span><a title="留言交流" class="" href="/guestbook/">Link</a></span>-->
        <span><a title="About" class="content" href="/about/">About</a></span>
        <span><a title="RSS" class="content" href="/feed/" target="_blank">RSS</a></span>
        </nav>
        <article class="content">
        <section class="meta">
<span class="time">
  <time datetime="2022-02-27">2022-02-27</time>
</span>

 | 
<span class="categories">
  分类
  
  <a href="/categories/#MQ" title="MQ">MQ</a>&nbsp;
  
</span>


 | 
<span class="tags">
  标签
  
  <a href="/tags/#kafka" title="kafka">kafka</a>&nbsp;
  
  <a href="/tags/#技术学习笔记" title="技术学习笔记">技术学习笔记</a>&nbsp;
  
</span>

</section>
<section class="post">
<h1 id="producer">Producer</h1>

<p>kafka 生产者的流程大致如下图：</p>

<p><img src="/assets/mq/kafka-mq-2023-02-17-22-07-19.png" alt="" /></p>

<p>1、 <code class="language-plaintext highlighter-rouge">Producer</code> 通过 <code class="language-plaintext highlighter-rouge">RroducerPecord</code> 封装消息 主要的数据有:topic、partition、key、value、timestamp 等数据。</p>

<p>2、通过序列化器把数据序列化，序列化器可以在初始化时指定。 然后再到分区器，由分区器分配到哪个 partition。</p>

<p>3、这个数据被记录到对应的 <code class="language-plaintext highlighter-rouge">topic</code> 和 <code class="language-plaintext highlighter-rouge">partition</code> 分类的缓冲区中, 多条消息会被封装成为一个批次（batch），默认一个批次的大小是 16K。</p>

<p>4、再由独立的线程 Sender 把这些数据发到对应的 <code class="language-plaintext highlighter-rouge">broker</code> 中。</p>

<p>5、如果服务器（<code class="language-plaintext highlighter-rouge">broker</code>） 将消息成功写入，就返回 <code class="language-plaintext highlighter-rouge">RecordMetaData</code> 对象，告诉 <code class="language-plaintext highlighter-rouge">Producer</code> 客户端主题、分区信息和偏移量。</p>

<p>6、主题的分区只能增加，不能减少。</p>

<p>7、如果写入失败，则返回错误信息，让 Producer 重试。</p>

<p>如果没有指明 partition 值，但有 key 的情况下，将 key hash 后与topic 的 partition 数目进行取余操作，得到 partition 值。</p>

<p>工作中，我会把业务一个惟一标识当作 key。像 sku、商家ID 等。</p>

<p>没有 partition 值又没有 key 的情况下，第一次调用时随机生成一个整数（后面每次调用在这个整数上自增），将这个值与 topic 可用的 partition 总数取余得到 partition 值，也就是 round-robin 算法。</p>

<h1 id="分区策略">分区策略</h1>

<p>kafka 的分区策略有：</p>

<ul>
  <li>轮询策略（Round-robin）</li>
  <li>随机策略（Randomness）</li>
  <li>按消息键保序策略（Key-ordering）</li>
</ul>

<p>kafka 也开放性的提供了自定义分区策略 <code class="language-plaintext highlighter-rouge">org.apache.kafka.clients.producer.Partitioner</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Partitioner</span> <span class="kd">extends</span> <span class="nc">Configurable</span><span class="o">,</span> <span class="nc">Closeable</span> <span class="o">{</span>

    <span class="cm">/**
     * Compute the partition for the given record.
     *
     * @param topic The topic name
     * @param key The key to partition on (or null if no key)
     * @param keyBytes The serialized key to partition on( or null if no key)
     * @param value The value to partition on or null
     * @param valueBytes The serialized value to partition on or null
     * @param cluster The current cluster metadata
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">partition</span><span class="o">(</span><span class="nc">String</span> <span class="n">topic</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">key</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">keyBytes</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">value</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">valueBytes</span><span class="o">,</span> <span class="nc">Cluster</span> <span class="n">cluster</span><span class="o">);</span>

    <span class="cm">/**
     * This is called when partitioner is closed.
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">();</span>

<span class="o">}</span>

</code></pre></div></div>

<h2 id="轮询策略">轮询策略</h2>

<p>Round-robin 策略，就是按序分配，这是一种默认的策略。 如果 RroducerPecord 没有 partition 值又没有 key。</p>

<p>假如有四个 partition, 第一个消息分配到 分区 0， 第二消息分配到 分区1 依次类推。到第五个消息又分配到分区0。如下图：</p>

<p><img src="/assets/mq/kafka-mq-2023-02-28-18-05-23.png" alt="" /></p>

<p>这种策略表现非常好，负载比较均衡。</p>

<h2 id="随机策略">随机策略</h2>

<p>Randomness 策略。就是我们随意地将消息放置到任意一个分区上</p>

<p><img src="/assets/mq/kafka-mq-2023-02-28-18-16-58.png" alt="" /></p>

<p>实现随机策略方法: 拿到 topic 的 partition 数，然后用  ThreadLocalRandom 随机出一个比它小的数。</p>

<p>这种方法可能会出不均衡的情况。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span> <span class="n">partitions</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="na">partitionsForTopic</span><span class="o">(</span><span class="n">topic</span><span class="o">);</span>
<span class="k">return</span> <span class="nc">ThreadLocalRandom</span><span class="o">.</span><span class="na">current</span><span class="o">().</span><span class="na">nextInt</span><span class="o">(</span><span class="n">partitions</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
</code></pre></div></div>
<h2 id="按消息键保序策略">按消息键保序策略</h2>

<p>Key-ordering 策略。就是为每一条消息定义一个消息键（key），可以有明确的业务含义，如果 业务编码、部门ID等。</p>

<p>相同的消息键（key)会被放到相同的 partition 中。这个策略有一个缺点就是导致数据倾斜。 如下图：</p>

<p><img src="/assets/mq/kafka-mq-2023-02-28-18-29-52.png" alt="" /></p>

<p>代码实现是 用 key hash 之后 对 partition 取模。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span> <span class="n">partitions</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="na">partitionsForTopic</span><span class="o">(</span><span class="n">topic</span><span class="o">);</span>
<span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">())</span> <span class="o">%</span> <span class="n">partitions</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
</code></pre></div></div>
<p>在分区器上执行策略之后，就会被分发到对应的 partition 上。</p>

<h1 id="缓冲区">缓冲区</h1>

<p><a href="https://cloud.tencent.com/developer/article/1698563">深度剖析 Kafka Producer 的缓冲池机制</a>
这个篇文章写的很好，后面自己再分析一下。</p>

<hr />


</section>
<section align="right">
<br/>
<span>
	<a  href="/kafka-summarize/" class="pageNav"  >上一篇</a>
	&nbsp;&nbsp;&nbsp;
	<a  href="/kafka-consumer/" class="pageNav"  >下一篇</a>
</span>
</section>
<!-- JiaThis Button BEGIN -->
<script type="text/javascript">
var jiathis_config = {data_track_clickback:'true'};
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jiathis_r.js?move=0&amp;uid=2121774" charset="utf-8"></script>
<!-- JiaThis Button END -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fc91691cf4004b194f7847896cca17dbb' type='text/javascript'%3E%3C/script%3E"));
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-56673760-1', 'auto');
  ga('send', 'pageview');

</script>

        </article>
      </div>

    <footer>
        <p>
          <script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fc91691cf4004b194f7847896cca17dbb' type='text/javascript'%3E%3C/script%3E"));
</script>

          <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-56673760-1', 'auto');
  ga('send', 'pageview');

</script>
        </p>
        <p><small>
            <a href="http://github.com/kakabei/kakabei.github.io/new/gh-pages/_posts" target="_blank" title="撰写文章">Po</a>wer<a href="http://github.com/kakabei/kakabei.github.io/edit/gh-pages/_posts/it/2022-02-27-kafka-producer.md" target="_blank" title="编辑页面">ed</a> by <a href="http://jekyllrb.com" target="_blank">Jekyll</a> @ <a href="http://github.com/kakabei/kakabei.github.io/kakabei.github.io" target="_blank" title="项目主页">GitHub</a>
             | <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank" title="许可协议">©</a> 2014 - 2024 <a href="/about/">kane</a>
             | <a href="https://github.com/kakabei/kakabei.github.io" target="_blank">@github</a>


         </small></p>
    </footer>

    </div>
  </body>
</html>
