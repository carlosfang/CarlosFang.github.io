<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="author" content="xyecho" />
    <title>xyecho - linux 零拷贝技术</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <link href="/feed/" rel="alternate" title="xyecho" type="application/atom+xml" />
    <link rel="stylesheet" href="/media/css/style.css" />
    <link rel="stylesheet" href="/media/css/highlight.css" />
    <script type="text/javascript" src="/media/js/jquery-1.7.1.min.js"></script>
  </head>
  <body>
    <div id="container">
      <div id="main" role="main">
        <header>
        <h1>linux 零拷贝技术</h1>
        </header>
        <nav>
        <span><a title="网站首页" class="" href="/">首页</a></span>
        <span><a title="文章分类" class="" href="/categories/">分类</a></span>
        <span><a title="标签索引" class="" href="/tags/">标签</a></span>
        <!--<span><a title="友情链接" class="" href="/links/">链接</a></span>-->
        <span><a title="留言交流" class="" href="/guestbook/">留言</a></span>
        <span><a title="关于站长" class="" href="/about/">关于</a></span>
        <span><a title="种子订阅" class="" href="/feed/" target="_blank">订阅</a></span>
        </nav>
        <article class="content">
        <section class="meta">
<span class="time">
  <time datetime="2021-06-22">2021-06-22</time>
</span>

 | 
<span class="categories">
  分类
  
  <a href="/categories/#Linux" title="Linux">Linux</a>&nbsp;
  
</span>


 | 
<span class="tags">
  标签
  
  <a href="/tags/#系统编程" title="系统编程">系统编程</a>&nbsp;
  
</span>

</section>
<section class="post">
<h4 id="前言">前言</h4>

<p>零拷贝（zero-copy）技术是一种Linux I/O 的读写方式。指的是CPU不参与拷贝数据，通过I/O设备的DMA控制器，数据不用再通过用户态的就拷贝到目的地 。</p>

<p>linux 中的零拷贝，<code class="highlighter-rouge">用mmap()</code>  、<code class="highlighter-rouge">sendfile()</code>、 DMA gather copy等的方式 ，从而减少数据的拷贝次数。</p>

<p>开源项目Kafka 有很高的I/O吞吐率，其中一个原因是用到了“零拷贝”技术。</p>

<h4 id="linux-io-读写方式">Linux I/O 读写方式</h4>

<p>Linux对于磁盘与主存之间的数据传输有三种机制， 分别是轮询、I/O 中断以及 DMA 。</p>

<ul>
  <li>
    <p>询方式是基于死循环对 I/O 端口进行不断检测。</p>
  </li>
  <li>
    <p>I/O 中断方式是指当数据到达时，磁盘主动向 CPU 发起中断请求，由 CPU 自身负责数据的传输过程。</p>
  </li>
  <li>
    <p>DMA 传输则在 I/O 中断的基础上引入了 DMA 磁盘控制器，由 DMA 磁盘控制器负责数据的传输，降低了 I/O 中断操作对 CPU 资源的大量消耗。</p>
  </li>
</ul>

<h5 id="io-中断原理">I/O 中断原理</h5>

<p>以系统调用<code class="highlighter-rouge">read()</code>为例. 程序只是一个简单的函数调用，但背面却发生了多次的数据拷贝。如下图。</p>

<ol>
  <li>进程调用<code class="highlighter-rouge">read()</code>时，发现系统调用，用户态切换到内核态，进程被阻塞。</li>
  <li>CPU接到指令后，会磁盘发起IO请求，然后返回。</li>
  <li>磁盘把数据放入到磁盘控制器的缓冲区中，然后向CPU发起IO中断信息。</li>
  <li>CPU收到中断信息后，把数据从磁盘控制器缓冲区拷贝到内核缓冲区。</li>
  <li>再将数据从 内核缓冲区拷贝到用户缓冲区。</li>
  <li>然后从内核态切换到用户态， <code class="highlighter-rouge">read()</code>返回。</li>
</ol>

<p><img src="assets\2021-06-21-linux-zero-copy-001.png" alt="" /></p>

<p>从这个流程上看，一共发生了两次的数据拷贝，即：将数据从磁盘的控制器缓冲区拷贝到内核缓冲区，将数据从内核缓冲区拷贝到用户缓冲区。这个过程是在内核态进行，CPU参与了数据拷贝。</p>

<p>如果是数据量比较大的传输，那么就仍占用大量的CPU用到拷贝数据，影响机器的性能。</p>

<h5 id="dma-原理">DMA 原理</h5>

<p>DMA 全称<strong>直接内存访问</strong>（<strong>D</strong>irect <strong>M</strong>emory <strong>A</strong>ccess）</p>

<blockquote>
  <p>是计算机科学中的一种内存访问技术。它允许某些电脑内部的硬件子系统（电脑外设），可以独立地直接读写系统内存，而不需CPU介入处理 。在同等程度的处理器负担下，DMA是一种快速的数据传送方式。很多硬件的系统会使用DMA，包含硬盘控制器、绘图显卡、网卡和声卡。[1]</p>
</blockquote>

<p>从这个定义上我们可以看出释放CPU的算力。</p>

<p>DMA技术的运用，改变了传统数据零拷贝时的传输流程。这个流程中比上面的多了一个DMA 角色，处在CPU和磁盘的中间。如下图:</p>

<p><img src="assets\2021-06-21-linux-zero-copy-002.png" alt="" /></p>

<p>具体过程：</p>

<ol>
  <li>
    <p>CPU向DMA发起IO请求，然后返回。CPU得到释放。</p>
  </li>
  <li>
    <p>DMA再向磁盘发起IO请求，磁盘将数据放入磁盘缓冲区，CPU 不参与此过程。然后通知回DMA。</p>
  </li>
  <li>
    <p>DMA将数从磁盘的缓冲区拷贝到内核缓冲区。CPU 不参与此过程。</p>
  </li>
  <li>
    <p>DMA拷贝完成后，向CPU发送完成信号。</p>
  </li>
  <li>
    <p>CPU收到中断信息后，将数据从内核缓冲区拷贝到用户缓冲区。CPU参与这个过程的数据拷贝。</p>
  </li>
</ol>

<p>这个数据的传输流程，加入了DMA角色，帮忙CPU完成数据拷贝，不再占用CPU。CPU只负责通知DMA的干活。</p>

<p>现在。很多硬件的系统会使用DMA，包含硬盘控制器、绘图显卡、网卡和声卡。所以DMA能不能用，也要看硬件设备。</p>

<h4 id="传统io方式">传统I/O方式</h4>

<p>linux的传统I/O方式，是通过<code class="highlighter-rouge">read()</code>、<code class="highlighter-rouge">write()</code>两个系统调用完成的。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">read</span><span class="p">(</span><span class="n">file_fd</span><span class="p">,</span> <span class="n">tmp_buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="n">write</span><span class="p">(</span><span class="n">socket_fd</span><span class="p">,</span> <span class="n">tmp_buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</code></pre></div></div>

<p>程序调用时只是两个很简单的函数调用，便背后也有复杂的数据传输流程。如下图：</p>

<p><img src="assets\2021-06-21-linux-zero-copy-003.png" alt="" /></p>

<p>具体过程：</p>

<ol>
  <li>程序调用<code class="highlighter-rouge">read()</code>函数，发起系统调用，从用户态切换到内核态。</li>
  <li>CPU通知DMA拷贝数据，DMA从硬件的缓冲区中把数据拷贝到内核缓冲区。</li>
  <li>CPU再数据从内核的缓冲区拷贝到用缓冲区。 从内核态切换到用户态。</li>
  <li>程序调用<code class="highlighter-rouge">write()</code>函数，发起系统调用，从用户态切换到内核态。</li>
  <li>CPU把数据拷贝从用户缓冲区socket缓冲区，通知DMA。</li>
  <li>DMA把数据从socket缓冲区把数据拷贝到网卡。</li>
  <li>完成后返回，从内核态切换用户态。</li>
</ol>

<p>这个过程，2次系统调用，4次上下文的切换。2次CPU拷贝，2次DMA拷贝，一共4次拷贝。</p>

<ul>
  <li>CPU拷贝：由 CPU 直接处理数据的传送，数据拷贝时会一直占用 CPU 的资源。</li>
  <li>DMA拷贝：由 CPU 向DMA下达指令，让 DMA 控制器来处理数据的传送，数据传送完毕再把信息反馈给 CPU，从而减轻了 CPU 资源的占有率。</li>
</ul>

<h4 id="零拷贝技术">零拷贝技术</h4>

<p>零拷贝技术在linux的实现主要有 3 个思路：用户态直接 I/O、减少数据拷贝次数以及写时复制技术。</p>

<h5 id="用户态直接-io">用户态直接 I/O</h5>

<p>应用程序可以直接访问硬件存储，操作系统内核只是辅助数据传输。这种方式依旧存在用户空间和内核空间的上下文切换，硬件上的数据直接拷贝至了用户空间，不经过内核空间。因此，直接 I/O 不存在内核空间缓冲区和用户空间缓冲区之间的数据拷贝。</p>

<p><img src="assets/2021-06-21-linux-zero-copy-004.png" alt="" /></p>

<p>应用程序通常在进程地址空间有自己的数据缓存机制，称为自缓存应用程序，如<strong>数据库管理系统</strong>就是一个代表。</p>

<p>这种零拷贝机制会直接操作磁盘 I/O，由于 CPU 和磁盘 I/O 之间的执行时间差距，会造成大量资源的浪费，解决方案是配合异步 I/O 使用。</p>

<h5 id="mmap-方式">mmap() 方式</h5>

<p>这是一种减少数据拷贝次数的方式。linux下，可以使用<code class="highlighter-rouge">mmap()</code> 、<code class="highlighter-rouge">write()</code>的方式，替换的<code class="highlighter-rouge">read()</code>、<code class="highlighter-rouge">write()</code>方式。<code class="highlighter-rouge">mmap()</code>在进程空间和内核空间进行了映射，从而使缓冲区的数据可以在用户态和内核态下形成数据共享。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tmp_buf</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="n">file_fd</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="n">write</span><span class="p">(</span><span class="n">socket_fd</span><span class="p">,</span> <span class="n">tmp_buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</code></pre></div></div>

<p>通过数据共享，减少了CPU的拷贝次数。数据传输的流程变化成如下图：</p>

<p><img src="assets\2021-06-21-linux-zero-copy-005.png" alt="" /></p>

<p>具体过程：</p>

<ol>
  <li>
    <p>流程主要的变化是，DMA把数据零拷贝到内核区之后，CPU不用再把数据拷贝到用户空间的缓冲区。这一次由<code class="highlighter-rouge">mmap()</code>的映射机制共享了内存数据。从而，在这个地方减少了一次的CPU拷贝。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">write()</code>写数据时，从用户空间的缓冲区拷贝数据，其实就是从内核缓冲区拷贝数据，因为数据是共享的。</p>
  </li>
  <li>
    <p>所以，总的来说，这种方式减少了一次的数据拷贝。</p>
  </li>
</ol>

<p><code class="highlighter-rouge">mmap()</code>和<code class="highlighter-rouge">write()</code> 这种方式，数据传输的流程有，4次上下文切换，1次CPU拷贝，2次DMA拷贝。</p>

<p><code class="highlighter-rouge">mmap()</code> 主要的于提高对大文件的I/O性能，对于小文件，容易产生内存碎片。</p>

<p><code class="highlighter-rouge">mmap()</code>隐藏了一个并发问题， 当 <code class="highlighter-rouge">mmap()</code> 一个文件时，如果这个文件被另一个进程所截获，那么 <code class="highlighter-rouge">write()</code> 系统调用会因为访问非法地址被 <code class="highlighter-rouge">SIGBUS</code> 信号终止，<code class="highlighter-rouge">SIGBUS</code> 默认会杀死进程并产生一个  coredump ，服务器可能因此被终止。</p>

<h5 id="sendfile-方式">sendfile() 方式</h5>

<p>Linux2.1版本以后有一个方式 <code class="highlighter-rouge">sendfile()</code>，不仅减少了拷贝的次数，也减少了上下文的切换次数。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sendfile</span><span class="p">(</span><span class="n">socket_fd</span><span class="p">,</span> <span class="n">file_fd</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</code></pre></div></div>

<p>这个系统调用目的就是简化网络间的数据传输过程。通过<code class="highlighter-rouge">sendfile()</code>  ,数据可以内核空间直接被拷贝传输，不用经过用户空间。对于用户态不可见，所以减少了上下文的切换。</p>

<p><img src="assets\2021-06-21-linux-zero-copy-006.png" alt="" /></p>

<p>具体过程：</p>

<ol>
  <li>
    <p>进程调用<code class="highlighter-rouge">sendfile()</code> 后，从用户态切换到内核态，CPU通知DMA 拷贝数据。数据被拷贝到内核缓冲区。</p>
  </li>
  <li>
    <p>CPU再把数据从内核的缓冲区拷贝到Socket缓冲区，这一步并不经过用户缓存区。对用户空间无感知。</p>
  </li>
  <li>
    <p>再通知DMA把数据拷贝到网卡。</p>
  </li>
  <li>
    <p>成功后返回，从内核态切换到用户态。</p>
  </li>
</ol>

<p>通过<code class="highlighter-rouge">sendfile()</code>方式，数据传输的过程有：2次上下文的切换，1次CPU的拷贝，2次的DMA拷贝。</p>

<h5 id="sendfile--dma-gather-copy-方式">sendfile()  DMA gather copy 方式</h5>

<p>Linux 2.4 版本的内核对 <code class="highlighter-rouge">sendfile()</code> 系统调用进行修改，为 DMA 拷贝引入了 gather 操作。它将内核空间的读缓冲区中对应的数据描述信息（内存地址、地址偏移量）记录到相应的socket缓冲区。由 DMA 根据内存地址、地址偏移量将数据批量地从读缓冲区（read buffer）拷贝到网卡设备中，这样就省去了内核空间中仅剩的 1 次 CPU 拷贝操作。如图：</p>

<p><img src="assets\2021-06-21-linux-zero-copy-007.png" alt="" /></p>

<p>具体过程：</p>

<ol>
  <li>进程调用<code class="highlighter-rouge">sendfile()</code> 后，从用户态切换到内核态，CPU通知DMA 拷贝数据。数据被拷贝到内核缓冲区。</li>
  <li>CPU只是把内核缓冲区读的缓冲区的文件描述符和数据长度被记录到Socket缓冲区，所以这里并没有发现数据拷贝。</li>
  <li>DMA从socket缓冲区拿到文件描述符和数据长度后，把数据从内核缓冲区拷贝到网卡。数据并没有通过Socket缓冲区，只有文件描述符和数据长度需要通过Socket缓冲区。</li>
  <li>成功后返回，从内核态切换到用户态。</li>
</ol>

<p>这种方式，用户空间同样无知觉，同时也要硬件scatter-gather 特性支持。同时，它也只适用将文件拷贝socket上会传输。</p>

<p>Linux系统可以查看网卡是否支持scatter-gather 特性。</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ethtool -k eth0 | grep scatter-gather
scatter-gather: on
</code></pre></div></div>

<p>腾讯的云服务器</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>root@VM-0-15-centos ~]# ethtool <span class="nt">-k</span> eth0 | <span class="nb">grep </span>scatter-gather
scatter-gather: off
        tx-scatter-gather: off <span class="o">[</span>fixed]
        tx-scatter-gather-fraglist: off <span class="o">[</span>fixed]
</code></pre></div></div>

<p>改不了 scatter-gather</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>root@VM-0-15-centos ~]# ethtool <span class="nt">-K</span> eth0 tx-scatter-gather on
Could not change any device features

</code></pre></div></div>

<p>这个过程，有2次上下文的切换，2次DMA拷贝，0次CPU拷贝。</p>

<h5 id="splice方式">splice()方式</h5>

<p><code class="highlighter-rouge">sendfile()</code> 、DMA gather 拷贝方式要硬件支持，同时也只能在socket上才适用。</p>

<p><code class="highlighter-rouge">splice()</code> 系统调用，不仅不需要硬件支持，还实现了两个文件描述符之间的数据零拷贝。<code class="highlighter-rouge">splice()</code> 的伪代码如下：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">splice</span><span class="p">(</span><span class="n">fd_in</span><span class="p">,</span> <span class="n">off_in</span><span class="p">,</span> <span class="n">fd_out</span><span class="p">,</span> <span class="n">off_out</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</code></pre></div></div>

<p>Linux  2.6.17 版本引用。</p>

<p>splice 系统调用可以在内核空间的读缓冲区（read buffer）和网络缓冲区（socket buffer）之间建立管道（pipeline），从而避免了两者之间的 CPU 拷贝操作。</p>

<p>通过映射页面来工作，实际上并不复制任何数据。[3]</p>

<p><img src="assets\2021-06-21-linux-zero-copy-008.png" alt="" /></p>

<p>具体过程：</p>

<ol>
  <li>进程调用<code class="highlighter-rouge">splice()</code> 后，从用户态切换到内核态，CPU通知DMA 拷贝数据。数据被拷贝到内核缓冲区。</li>
  <li>CPU在内核缓冲区和Socket缓冲区建立成Pipeline。</li>
  <li>DMA从Socket缓冲区拷贝到网卡。</li>
  <li>成功后返回，从内核态切换到用户态。</li>
</ol>

<p>这个过程，有2次上下文的切换，2次DMA拷贝，0次CPU拷贝。</p>

<p>写时复制技术：写时复制指的是当多个进程共享同一块数据时，如果其中一个进程需要对这份数据进行修改，那么将其拷贝到自己的进程地址空间中，如果只是数据读取操作则不需要进行拷贝操作。</p>

<h5 id="几种方式的对比">几种方式的对比</h5>

<table>
  <thead>
    <tr>
      <th>拷贝方式</th>
      <th style="text-align: center">CPU拷贝</th>
      <th style="text-align: center">DMA拷贝</th>
      <th style="text-align: center">上下文切换</th>
      <th>备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">read()</code> 、 <code class="highlighter-rouge">write()</code></td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">4</td>
      <td>传统方式</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">mmap()</code>、 <code class="highlighter-rouge">write()</code></td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">4</td>
      <td>内存映射方式</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">sendfile()</code></td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
      <td>linux内核版本2.1以后才有</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">sendfile()</code> 、 DMA gather copy</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
      <td>Linux 2.4 版本，硬件支持,只能在socket运用</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">splice()</code></td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
      <td>内核空间pipeline，通过重新映射页面来工作，实际上并不复制任何数据。</td>
    </tr>
  </tbody>
</table>

<p><code class="highlighter-rouge">sendfile()</code> 、 DMA gather copy 和 splice() CPU的拷贝次数已经是0次了。</p>

<h4 id="实现">实现</h4>

<p>写了一个测试程序，<code class="highlighter-rouge">sendfile()</code>  比<code class="highlighter-rouge">read()</code> 、 <code class="highlighter-rouge">write()</code>是要快一点。 对同一个小文件进行读写900w次。</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>root@VM-0-15-centos zorecopy]# ./test_zorecopy test1.txt  test2.txt test3.txt
use_sendfile <span class="nb">time </span>is: 35567 ms
use_read_and_write <span class="nb">time </span>is: 36985 ms
</code></pre></div></div>

<h4 id="总结">总结</h4>

<p>在日常工作中，除非你是做基础组件，不然很多时候,这一些比基础的技术可能不会直接用到。但是，却会时常间接用到。如：我们要选方案，要做出判断那种方案合适，依据是什么。这就要求我们对基础原理所有了解。 再如，这种大原理的优化思路过程。我们可否借鉴，业务需求中数据有多次复制，是否有办法减少复制的次数提高效率。当然，具体问题要具体分析。多了解一些原理拓展知识面，扩大自己的能力圈，可以更好更准确的做判断。</p>

<h4 id="参考">参考</h4>

<p>[1] <a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%8E%A5%E8%A8%98%E6%86%B6%E9%AB%94%E5%AD%98%E5%8F%96">维基百科-直接内存访问</a></p>

<p>[2] <a href="https://man7.org/linux/man-pages/man2/splice.2.html">splice(2) — Linux manual pag</a></p>

<p>[3] <a href="https://en.wikipedia.org/wiki/Splice_(system_call)">wiki - splice (system call)</a></p>


</section>
<section align="right">
<br/>
<span>
	<a   class="pageNavInvalid"  >上一篇</a>
	&nbsp;&nbsp;&nbsp;
	<a   class="pageNavInvalid"  >下一篇</a>
</span>
</section>
<!-- JiaThis Button BEGIN -->
<script type="text/javascript">
var jiathis_config = {data_track_clickback:'true'};
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jiathis_r.js?move=0&amp;uid=2121774" charset="utf-8"></script>
<!-- JiaThis Button END -->


	
	<div class="ds-thread" />
		
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"xyecho"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = 'http://static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		|| document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>


<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fc91691cf4004b194f7847896cca17dbb' type='text/javascript'%3E%3C/script%3E"));
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-56673760-1', 'auto');
  ga('send', 'pageview');

</script>

        </article>
      </div>

    <footer>
        <p>
          <script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fc91691cf4004b194f7847896cca17dbb' type='text/javascript'%3E%3C/script%3E"));
</script>

          <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-56673760-1', 'auto');
  ga('send', 'pageview');

</script>
        </p>
        <p><small>
            <a href="http://github.com/CarlosFang/CarlosFang.github.io/new/gh-pages/_posts" target="_blank" title="撰写文章">Po</a>wer<a href="http://github.com/CarlosFang/CarlosFang.github.io/edit/gh-pages/doc/kkn/2021-06-21 linux-zore-copy.md" target="_blank" title="编辑页面">ed</a> by <a href="http://jekyllrb.com" target="_blank">Jekyll</a> @ <a href="http://github.com/CarlosFang/CarlosFang.github.io" target="_blank" title="项目主页">GitHub</a>
             | <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/cn/" target="_blank" title="许可协议">©</a> 2014 - 2021 <a href="/about/">xyecho</a>
             | <a href="http://blog.xyecho.com" target="_blank">@cnblogs</a>


         </small></p>
    </footer>

    </div>
  </body>
</html>
