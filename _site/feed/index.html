<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>xyecho</title>
    <link href="http://localhost:4000/feed/" rel="self" />
    <link href="http://localhost:4000" />
    <lastBuildDate>2022-09-26T17:26:26+08:00</lastBuildDate>
    <webMaster>1447675994@qq.com</webMaster>
    
    <item>
      <title>《麦肯锡结构化战略思维》by 周国元</title>
      <link href="http://localhost:4000/%E9%BA%A6%E8%82%AF%E9%94%A1%E7%BB%93%E6%9E%84%E5%8C%96%E6%88%98%E7%95%A5%E6%80%9D%E7%BB%B4/"/>
      <pubDate>2022-05-28T19:13:00+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/麦肯锡结构化战略思维</guid>
      <content:encoded><![CDATA[<p>近些年，职场上发现，非技术的能力成了发展的短板。如良好的沟通，系统的思考。内心抗拒和陌生人接触。这个性格就是技术型的。</p>

<p>领导介绍了这本书《麦肯锡结构化战略思维》，感觉不错，在职场迷茫不知道怎么做个好人的可以看一下。</p>

<p>主要讲的是：对于一个新问题，新领域，用什么的原则和方法去切入，自上而下，有自己的洞见，用数据和逻辑讲故事，最后做出一个漂亮的交付。</p>

<p>事后也对思辨者做一些总结，形成习惯，方便以后可持续的输出。</p>

<p>它更像是一些职场的方法论。当然也可延生到生活，学习的等场景。</p>

<p><img src="/assets/reading/reading-book-jghsw20220528.jpeg" alt="" /></p>

<p>书主要从 <strong>原则、方法、习惯</strong> 三方面介绍。</p>

<h2 id="原则">原则</h2>
<hr />

<p>结构化思考的过程，我们要定一些原则，以免在这个过程中掉到坑里。</p>

<p>1、数字</p>

<p>当我们看到数据时，第一反应是质疑。是数据是否有问题。第二个反应是，这数据是否可以推出来这样的结论。</p>

<p>另外， 数据一定是和逻辑在一起的，有数据，没有逻辑是死数据，无用的。</p>

<p>如果数据都没有问题，数据中却出现特例，那可能就是问题所在了。 数据的异常点可能就是背后的支撑逻辑有问题。</p>

<p>数据只能说明过去的，而我们追求的时未来，价值在未来。</p>

<p>2、洞见</p>

<p>从数据加逻辑，我们可能得到信息，从信息中，我提炼出洞见。 洞见就是我们要所要的结果。</p>

<p>洞见的来源：</p>

<p>数据的替身和数据趋势， 数据背后的实体是什么，将走向何处，提炼出来就是洞见。</p>

<p>数据的异常点，极端点，以及其他合理背后的逻辑，就是洞见。</p>

<p>数据对比的结果，差异就是洞见。</p>

<p>数据周边的相关信息，也可以是洞见。</p>

<p>以后，所有的推化和提炼都可以成洞见。</p>

<p>3、MECE 原则</p>

<p>MECE原则，就是一种切问题的方法。 或者说分拆问题的原则。</p>

<ul>
  <li>子分类相互独立无重叠</li>
  <li>子分类加起来穷尽全部可能</li>
</ul>

<p>这个两个原则，我的理解是子问题要解藕，方便独立解决。</p>

<p>4、 假设</p>

<p>个人觉得假设很重要。假设是探讨问题的一个开始。<strong>假设，论证，再假设，再论证。</strong> 几个轮回之后，很多背后的逻辑也浮出了水面。</p>

<p>过程不介绍探讨假设。很多人不喜欢假设。一开口就是说“你别给我假设”，“这只是你的假设”。可能太急燥了，就想一开始就能切中问题所在吧。</p>

<h2 id="方法">方法</h2>
<hr />

<p>把一个问题搞懂的方法论，就是如下图这个步骤了。</p>

<p><img src="/assets/reading/reading-book-jghsw2022-05-28_14-16-01.png" alt="" /></p>

<h3 id="定义问题">定义问题</h3>

<p>1、之所以要重新定义问题，因为我们拿到手的问题，可能是个假问题。所以第一步要确认问题的正确性。</p>

<p>2、 所以用一些手段，即定义问题的工具：</p>

<ul>
  <li>问题的背景，从全局的角度看待这个问题。</li>
  <li>问题的边界，解决问题约束。即，问题的不能无限扩大，解决的资源不是无限的。</li>
  <li>解决问题的标准是什么，即达到什么程度，这个问题才算解决。</li>
  <li>问题的相关人，责任人。</li>
</ul>

<p>书上写的工具不只四个，但我觉得有一些可以合并。这几项，大概就可以把问题圈定在一定的范围内。我们目标也明确了。后面的假设不会超过这个范围遨游太虚去了。</p>

<p>3、MECE 原则</p>

<p>如上面已讲，这个原则就是切问题的，把问题拆分成子问题。</p>

<p>4、多维图谱</p>

<p>可以用思维导图呈现你的思考过程，当有你很多假设、验证过程时会更加清晰的呈现出思考对错。</p>

<h3 id="结构化分析">结构化分析</h3>

<p>结构化分析和切问题估计应该就是本书的核心章节了，如下图，就是结构化思维最基本的主流程了。其实前面的所有步骤做之后，就已经进入分析状态了。</p>

<p><img src="/assets/reading/reading-book-jghsw2022-05-28_14-52-53.png" alt="" /></p>

<h4 id="1切问题">1、切问题</h4>

<p>个人觉得切问题，怎么样切，要看个人的能力，对所在领域的业务能力。如果你什么都不了解，不清楚。想切也无从下手。所以，结构化分化要有领域专业基础能力做支撑。</p>

<p>书中讲的只一些通用方法，具体问题还要具体分析。</p>

<ul>
  <li>公式法</li>
  <li>子目录列举法</li>
  <li>流程法</li>
  <li>逻辑框架法</li>
</ul>

<h4 id="2逻辑思维">2、逻辑思维</h4>

<p>这个已经上升到逻辑学层面了，可能算是基本法则了。但因果性和相关性可能是很多容易犯的错而不自知。</p>

<ul>
  <li>归纳法（自下而上）</li>
  <li>演绎法（自上而下）</li>
  <li>因果性和相关性</li>
</ul>

<h4 id="3提出假设">3、提出假设</h4>

<p>切出子问题之后，对子问题的解决，就是多次假设，多次验证。 假设也不是天马行空的，上面在问题的准备时已经就做限制。 提出假设的方法主要有：</p>

<ul>
  <li>假设清单。 所有的过程都不应该外露，这个假设清单也是，很多会被证伪。</li>
  <li>头脑风暴。 提出有差异、平等、发散的各种意见。</li>
  <li>杜绝专家过早参与。专家过早参与，有可能被画地为牢。专家应该在验证过程会更好。</li>
</ul>

<h4 id="4验证假设">4、验证假设</h4>

<p>验证假设应该是整个过程最花精力的地方了。主要通过调研和访谈两方面。</p>

<p>调研的分类有：</p>

<ul>
  <li>案头调研。收集相关的资料，当然是越多越好。但这只是第一步，很多人只做到这一步。</li>
  <li>实地调研。 案头调研之后，再深入的就是实地调研。如投资，不单要看财报，要市场做调研。</li>
</ul>

<p>人个觉得调研的技巧，可以专门找书籍来学习。 调研技巧：</p>

<ul>
  <li>商业敏感度</li>
  <li>表达沟通能力</li>
  <li>自驱力</li>
  <li>情商、同理心</li>
  <li>数据字分析技能</li>
</ul>

<p>访谈就是沟通，如何很好的沟通，是一门很能难的学问，也是不被看重的能力。 也因当专门学习。</p>

<p>访谈技巧：</p>

<ul>
  <li>对被访者的尊重，注意情绪的波动</li>
  <li>聆听后的提炼，重述</li>
  <li>对话要输入新的增值信息</li>
  <li>以结果为导向的访谈态度</li>
  <li>培养建立长期信任关系</li>
  <li>保护好被访问者</li>
</ul>

<h4 id="5交付">5、交付</h4>

<p>切问题是这个过程中最核心的技术，验证是最花精力的过程，那么交付就是最重要的结果了。</p>

<p>前面的所有努力都在这里呈现，如果呈现不出了，估计别人觉得你什么都没做了。</p>

<p>交付分为三个阶段： 交付前，交付时，交付后。</p>

<p>交付后， 是我个人加进去了。 因为真的交付后，还有很多事情可以做的，如总结，复盘，优化以后的流程，分享等。</p>

<p>交付前：</p>

<ul>
  <li>只有充分的准备，没有过度的准备。</li>
  <li>对自己的心理建设。</li>
</ul>

<p>交付时：</p>

<ul>
  <li>商务沟通：讲故事</li>
  <li>沟通是双向，多向的</li>
  <li>沟通是多层面的， 信息，洞见，个性化，情绪，情感</li>
  <li>沟通多形式</li>
  <li>沟通的外部影响</li>
  <li>沟通的3S 原则</li>
  <li>沟通的金字塔原则</li>
</ul>

<p>自己总结一点，平时，可以用电机叙述的方式用5W2H分析法把事情讲清楚。</p>

<h2 id="习惯">习惯</h2>
<hr />

<p>最后，对于一个结构化思辨者，我们应该养成什么样的习惯呢？</p>

<ul>
  <li>反对的责任</li>
  <li>解决正确的问题</li>
  <li>下一层面的细节</li>
  <li>总结提炼， 电梯陈述，讲清5W2H</li>
  <li>第一天的答案， 可以快速理清框架，出思路，可以过掉细节</li>
  <li>问正确的问题</li>
  <li>认为还是知道</li>
  <li>移动时间轴</li>
  <li>数据和逻辑</li>
  <li>知道边界</li>
</ul>

<p>如果， 只能记住三点，那么我会选择：</p>

<p>1、质疑数据，数据一定要有逻辑。</p>

<p>2、正确的问题</p>

<p>3、总结提炼， 电梯陈述，讲清5W2H</p>

<h2 id="总结">总结</h2>
<hr />

<p>像《查理穷宝典》中芒格说的，我们要一些思维模型，用这一些工具来对世界上的事物进行思考。 学习的过程就是不断的建议自己的思维模型。</p>

<p>结构化思维对于职场来说是一个很好的思维模型，可以以这个为基础，不断打磨自己的方法论。形成自己的思维工具。</p>

<p>人不固执己见，终身学习才是王者，这个和年纪没有什么关系。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>如何处理一个系统设计</title>
      <link href="http://localhost:4000/server-how-to-design-systerm/"/>
      <pubDate>2022-03-21T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/server-how-to-design-systerm</guid>
      <content:encoded><![CDATA[<p>这是一个开放性问题， 这文章中提供了一个大概的思考步骤。<a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98">如何处理一个系统设计的面试题</a>
后续学习工作中，可以不断的完善这一些思考。</p>

<h2 id="第一步描述使用场景约束和假设">第一步：描述使用场景，约束和假设</h2>

<p>把所有需要的东西聚集在一起，审视问题。不停的提问，以至于我们可以明确使用场景和约束。讨论假设。</p>

<ul>
  <li>谁会使用它？</li>
  <li>他们会怎样使用它？</li>
  <li>有多少用户？</li>
  <li>系统的作用是什么？</li>
  <li>系统的输入输出分别是什么？</li>
  <li>我们希望处理多少数据？</li>
  <li>我们希望每秒钟处理多少请求？</li>
  <li>我们希望的读写比率？分别什么场景？</li>
</ul>

<h2 id="第二步创造一个高层级的设计">第二步：创造一个高层级的设计</h2>

<p>使用所有重要的组件来描绘出一个高层级的设计。</p>

<ul>
  <li>画出主要的组件和连接。 画出框架图，不宜太细仔。主要体现出组件的关系和数据流。</li>
  <li>证明你的想法。 根据框架图，推演一下，能不能解决问题。</li>
</ul>

<h2 id="第三步设计核心组件">第三步：设计核心组件</h2>

<p>对每一个核心组件进行详细深入的分析。举例来说，如果你被问到设计一个 url 缩写服务，开始讨论：</p>

<ul>
  <li>生成并储存一个完整 url 的 hash
    <ul>
      <li>MD5 和 Base62</li>
      <li>Hash 碰撞</li>
      <li>SQL 还是 NoSQL</li>
      <li>数据库模型</li>
    </ul>
  </li>
  <li>将一个 hashed url 翻译成完整的 url
    <ul>
      <li>数据库查找</li>
    </ul>
  </li>
  <li>API 和面向对象设计</li>
</ul>

<h2 id="第四步扩展设计">第四步：扩展设计</h2>

<p>确认和处理瓶颈以及一些限制。举例来说就是你需要下面的这些来完成扩展性的议题吗？</p>

<ul>
  <li>负载均衡</li>
  <li>水平扩展</li>
  <li>缓存</li>
  <li>数据库分片</li>
</ul>

<p>论述可能的解决办法和代价。每件事情需要取舍。可以使用可扩展系统的设计原则来处理瓶颈。</p>

<h2 id="预估计算量">预估计算量</h2>

<p>你或许会被要求通过手算进行一些估算。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>服务发现原理</title>
      <link href="http://localhost:4000/server-service-discovery/"/>
      <pubDate>2022-01-26T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/server-service-discovery</guid>
      <content:encoded><![CDATA[<h1 id="一概述">一、概述</h1>

<p>在微服务分布式框架中，服务被拆分成很微小服务，各自独立。由多个台机器组成，各服务之间相互调用，有管理各种服务的需求。 服务发现机制可以降低服务管理的成本。</p>

<p>在服务发现之前，服务之间的调用，可能要在各服务代码中写死IP 或者 通过配置文件读出服务之间的IP。</p>

<p>服务发现机制则一分两步:</p>

<p>1、服务注册。 在服务启动时，把自己的<strong>IP和端口</strong> 通过服务注册定入到服务管理平台中，以便提供给其他主调用。</p>

<p>2、服务发现。其他方调用时则要先通过服务平台拿到这个服务其中的一个<strong>IP和端口</strong>，然后再调用。</p>

<p>如图：</p>

<p><img src="/assets/system-design/service-discovery-2022-09-23_11-53-40.png" alt="" /></p>

<p>说明：</p>

<p>1、 server b 把自己注册到  service registry  叫做 <strong>服务注册</strong>。</p>

<p>2、 server  a  从 service registry 发现 server b 的节点信息叫做 <strong>服务发现</strong>。</p>

<p>3、最后 server a 调用 server b。</p>

<h1 id="二服务注册">二、服务注册</h1>

<p>服务注册，简单的说是，就是把自己的IP和端口写到服务管理平台上形成一组服务，告诉所有其他的服务，想调用我，可以通过服务管理平台上的服务名找到我的IP和端口。</p>

<p>服务注册的大概框架图：</p>

<p><img src="/assets/system-design/service-discovery-2022-09-23_00-58-18.png" alt="" /></p>

<p>一般一个服务会有多个 IP 和端口。 如：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="err">user</span><span class="w"> </span><span class="err">server</span><span class="w"> 
</span><span class="p">[</span><span class="w">
	</span><span class="p">{</span><span class="w"> 
		</span><span class="nl">"ip"</span><span class="p">:</span><span class="mf">127.0</span><span class="err">.</span><span class="mf">0.1</span><span class="p">,</span><span class="w">
		</span><span class="nl">"port"</span><span class="p">:</span><span class="mi">8800</span><span class="w">
	</span><span class="p">},</span><span class="w">
	</span><span class="p">{</span><span class="w"> 
		</span><span class="nl">"ip"</span><span class="p">:</span><span class="mf">127.0</span><span class="err">.</span><span class="mf">0.2</span><span class="p">,</span><span class="w">
		</span><span class="nl">"port"</span><span class="p">:</span><span class="mi">8800</span><span class="w">
	</span><span class="p">},</span><span class="w">
	</span><span class="p">{</span><span class="w"> 
		</span><span class="nl">"ip"</span><span class="p">:</span><span class="mf">127.0</span><span class="err">.</span><span class="mf">0.3</span><span class="p">,</span><span class="w">
		</span><span class="nl">"port"</span><span class="p">:</span><span class="mi">8800</span><span class="w">
	</span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="w">

</span><span class="err">#</span><span class="w"> </span><span class="err">live</span><span class="w"> </span><span class="err">server</span><span class="w"> 
</span><span class="p">[</span><span class="w">
	</span><span class="p">{</span><span class="w"> 
		</span><span class="nl">"ip"</span><span class="p">:</span><span class="mf">127.0</span><span class="err">.</span><span class="mf">1.1</span><span class="p">,</span><span class="w">
		</span><span class="nl">"port"</span><span class="p">:</span><span class="mi">8801</span><span class="w">
	</span><span class="p">},</span><span class="w">
	</span><span class="p">{</span><span class="w"> 
		</span><span class="nl">"ip"</span><span class="p">:</span><span class="mf">127.0</span><span class="err">.</span><span class="mf">1.2</span><span class="p">,</span><span class="w">
		</span><span class="nl">"port"</span><span class="p">:</span><span class="mi">8801</span><span class="w">
	</span><span class="p">},</span><span class="w">
	</span><span class="p">{</span><span class="w"> 
		</span><span class="nl">"ip"</span><span class="p">:</span><span class="mf">127.0</span><span class="err">.</span><span class="mf">1.3</span><span class="p">,</span><span class="w">
		</span><span class="nl">"port"</span><span class="p">:</span><span class="mi">8801</span><span class="w">
	</span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="w">

</span></code></pre></div></div>

<p>说明：</p>

<p>1、业务服务会向服务平台注册一个服务名，把自己的 IP和端口号写入。</p>

<p>2、一般情况下，同一个服务，所有端口最好一样，方便管理。</p>

<p>3、以现在docker 的技术，一般是一个实例只能跑一个业务服务。但也有企业了节约成本，也会在同一个docker 跑多个服务。</p>

<p>4、有的解决方案是在服务管理平台手动的写入服务名和对应的IP列表。 服务名要全局惟一。</p>

<h1 id="三服务发现">三、服务发现</h1>

<p>服务发现，即当server a 想请求 serve b 时，应该如何找到合适的IP和端口呢？如：</p>

<p>user sever 这个服务 有三台机器，  live server  也有三台机器。 live sever1  想请求 user server  的业务接口。它就应该先请求服务管理平台。</p>

<p>服务管理平台返回了 user server 中的一个IP和端口。 （负载均衡后的结果）</p>

<p><img src="/assets/system-design/service-discovery-2022-09-23_11-09-13.png" alt="" /></p>

<p>上图说明：</p>

<p>1、 live server1 想请求 user server 中的接口。</p>

<p>2、live server1 要请求服务管理平台，服务管理平台返回了 user server 其中的一个IP 和 端口。 （user server2）</p>

<p>3、live server1 再请求 user server2</p>

<p>这样就完成一个服务的调用。</p>

<h1 id="四活跃检测">四、活跃检测</h1>

<p>服务发现机制，除了在微服务分布式系统中方便服务之间的调用后，还是功能就两个是活跃检测和负载均衡。</p>

<p>即服务管理平台会向注册的服务发送请求，确认服务是否可用，如果服务不可用或机器已挂机。即标记该 IP 不可用，或者直接摘机。</p>

<p>另一种方式是注册的服务定时的向服务管理平台发送确认的状态。告诉服务管理平台，自己还是活跃的。</p>

<p>当时发现服务不通时，可以进行摘机。即把IP从列表中移除掉。</p>

<p>所以，服务提供方一般都要求两个机器以上，这样可以起到容灾的作用。 要求高一点，可以要求机器在不同机房。当一个机房出问题时，另一个机器的服务可以支持着服务。</p>

<p><img src="/assets/system-design/service-discovery-2022-09-23_01-04-49.png" alt="" /></p>

<h1 id="五负载均衡">五、负载均衡</h1>

<p>服务请求时，提供方的服务是无状态的，会存在多个IP，我们只需求访问其中一个IP即可。 所以，服务管理平台同时也起了负载均衡的作用，只返回一个合适的IP。</p>

<p>当然，也有的策略是返回多个 IP， 让调用方自己去选择那个IP访问。</p>

<p>这里也导致一个问题，即所有请求都会预先请求服务管理平台。流量大的时侯会有瓶颈。解决的方案的是，请求到一个IP后，可以在本地缓存几秒钟，减少因流量峰值而带来服务管理平台的压力。</p>

<p><a href="http://blog.xyecho.com/load-balancing-and-reverse-proxy/">负载均衡策略：http://blog.xyecho.com/load-balancing-and-reverse-proxy/</a></p>

<h1 id="五服务发现技术点">五、服务发现技术点</h1>

<p>一套完整的服务发现平台，所需要的技术点：</p>

<p>1、 集群、分布式。 要应对大流量的服务，就一定要用到分布式集群。同时也起到容灾的作用。</p>

<p>2、强一致性、数据同步。由于分布式， 所以数据的一定要同步到每一台机器上，同时也要保证每一台机器的上的数据是一致的。</p>

<p>3、高并发、高可用。服务请求都要预先请求一次服务管理平台，所以流量会比较大。不能因为服务发现的加入而导致整体的性能下降太多。</p>

<p>4、部署管理简单。 简单的管理和好的体验，会让更多开发者去运用它。</p>

<h1 id="六开源的解决方案">六、开源的解决方案</h1>

<p>有资源的企业会基于源开放的解决方案上做一些二次开发，以适用于本企业的研发文化。 github 上也有一些比较靠谱的解决方案。如：
<code class="language-plaintext highlighter-rouge">etcd</code> 、<code class="language-plaintext highlighter-rouge">zookeeper</code> 、<code class="language-plaintext highlighter-rouge">consul</code> 等。都具有安全稳定，高可用，高并发。强一致性的特点。</p>

<p>1、<code class="language-plaintext highlighter-rouge">etcd</code>  : <a href="https://github.com/etcd-io/etcd">https://github.com/etcd-io/etcd</a></p>

<p>2、<code class="language-plaintext highlighter-rouge">zookeeper</code> : <a href="https://github.com/apache/zookeeper">https://github.com/apache/zookeeper</a></p>

<p>3、<code class="language-plaintext highlighter-rouge">consul</code> :<a href="https://github.com/hashicorp/consul">https://github.com/hashicorp/consul</a></p>

<hr />
<p>1、<a href="https://zhuanlan.zhihu.com/p/161277955">深入了解服务注册与发现 : https://zhuanlan.zhihu.com/p/161277955</a></p>

<p>2、<a href="https://zhuanlan.zhihu.com/p/409154290">服务注册与发现的原理和实现 : https://zhuanlan.zhihu.com/p/409154290</a></p>

]]></content:encoded>
    </item>
    
    <item>
      <title>系统设计方案注意事项</title>
      <link href="http://localhost:4000/server-system-design-idea/"/>
      <pubDate>2022-01-25T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/server-system-design-idea</guid>
      <content:encoded><![CDATA[<h1 id="一需求背景">一、需求背景</h1>

<p>1、 清晰掌握需求的各个场景，以业务为导向，检验技术和系统能否很好支持需求的各个场景。</p>

<p>2、了解需求背景，有助于从技术角度上看，需求是否存在漏洞</p>

<h1 id="二系统架构">二、系统架构</h1>

<p>1、画出清晰的高层框架图，主要体现出用什么组件，之间是怎么连接的，数据流向。</p>

<p>2、证明你的思路，用框架图进行推演，是否可以解决需求问题。</p>

<p>3、各个组件节点，是否存在关键点，是否有备用方案，即容错容灾。</p>

<p>4、 估算业务数据，并发，数据总量，系统是否可以满足。</p>

<h1 id="三关键业务流程图">三、关键业务流程图</h1>

<p>1、深入描述清楚关键组件节点的核心业务逻辑。</p>

<p>2、本地缓存防止热点出现。 本地缓存考虑空标情况。</p>

<p>3、处理外部接口异常情况。</p>

<p>4、防止流程出现阻塞情况。</p>

<p>5、关键接口，或读写缓存/db是否有重试机制。</p>

<p>6、业务或第三方接口是否考虑可重入。</p>

<p>7、关键数据一致性考虑。</p>

<p>8、关键流程是否存在并发，是否需要加锁。极端情况也不能忽略，觉得量少不可能会有并发情况，但极端情况果可以由其他bug导致的。</p>

<p>9、对外接口做频限保护。</p>

<p>10、核心业务流程记录流水。</p>

<h1 id="四业务">四、业务</h1>

<p>1、活动和时间相关的，注意零点和跨年的边界问题。</p>

<h1 id="五数据结构-mysql表设计redis缓存数据">五、数据结构  （mysql 表设计，redis 缓存数据）</h1>

<p>1、<code class="language-plaintext highlighter-rouge">mysql</code> 表设计是否合理，相关字段的索引；字段类型定义；是否有扩展字段；业务的数据总量是否考虑分表，用什么维度分表。</p>

<p>2、<code class="language-plaintext highlighter-rouge">mysql</code> <code class="language-plaintext highlighter-rouge">dao</code> 考虑连接数多少。防止对数据库压力过大，是否要加一层redis缓存。</p>

<p>3、<code class="language-plaintext highlighter-rouge">mysql</code> 优先考虑写主，读从。但也要防止主从同步的时间差可能导致业务逻辑的问题。</p>

<p>4、<code class="language-plaintext highlighter-rouge">mysql</code> sql 效率问题，如:  是否让索引失效，是否有必要连表，连表的是否表设计有问题。</p>

<p>5、<code class="language-plaintext highlighter-rouge">redis</code> 缓存是否存在热点， 是否存在大key， 是否考虑缓存空标，空标有效时间和正常的有效时间要区别出来。有效时间是否考虑打散，防止数据同时失效出现雪崩。</p>

<p>6、<code class="language-plaintext highlighter-rouge">redis</code> 数据结构设计注意版本号或扩展字段。反过来，在迭代新增扩展字段时，要考虑数据序列化问题，即版本号等问题。</p>

<h1 id="六协议">六、协议</h1>

<p>1、协议要简洁易懂，字段命名不要出现歧义，注释清楚。一定要有初始化，且初始化的值要合理。</p>

<p>2、协议要有对应的文档。文档说明清晰。文档要用 <code class="language-plaintext highlighter-rouge">source</code> 记录调用业务来源，预估请量，相关负责人。</p>

<p>3、请求协议要有source字段定义业务来源。</p>

<p>4、服务的协议要注意可扩展，新增字段要在mapExt中添加。</p>

<p>5、服务的协议初始化，序列化要对应正确。</p>

<p>6、响应协议要有错误码和错误信息。在文档要对错误码做出释义。</p>

<h1 id="七配置监控">七、配置监控</h1>

<p>1、对所有第三方接口要单独监控。</p>

<p>2、<code class="language-plaintext highlighter-rouge">dao</code> 操作要做单独监控。</p>

<p>3、<code class="language-plaintext highlighter-rouge">redis</code> 缓存/进程内缓存要监控命中率。</p>

<p>4、对外接口做全局监控。</p>

<p>5、<code class="language-plaintext highlighter-rouge">daemon</code> 也要做全局监控。</p>

<p>6、对外部参数的校验可以不做告警。</p>

<p>7、集中建立个性化视图，写清楚紧急联系人，方便快速找到对应的负责人。</p>

<p>8、接口调用来源做统计监控。</p>

<p>9、关键业务做出错告警。</p>

<p>10、 监控让服务有可观察性。</p>

<h1 id="八异常处理">八、异常处理</h1>

<p>1、考虑兜底方案，降级方案，补偿机制。</p>

<p>2、重试，告警。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>引流活动九宫格抽奖系统设计</title>
      <link href="http://localhost:4000/server-acitivity-ninebox/"/>
      <pubDate>2022-01-24T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/server-acitivity-ninebox</guid>
      <content:encoded><![CDATA[<h1 id="一-背景">一 背景</h1>

<p>在用户购买商品后，完成支付，可以一个抽奖活动。很多线上线下的都会搞类似这样的活动。这个位置是一个很好引流活动。可以把流量引向不同的业务。</p>

<p>如华为运动中的活动：</p>

<p><img src="/assets/system-design/server-activity-ninebox-2022-09-21_17-19-20.png" alt="" /></p>

<p>产品的业务逻辑：</p>

<p>1、九宫格中展示7个坑位的奖品，中间一个是抽奖按钮。第8个坑位是“谢谢参与”。</p>

<p>2、这是一个引流推广活动，所以业务逻辑上要求是奖品必中。之所以留一个坑位“谢谢参与”，是为兜底系统错误（如：网络问题）以避免客诉。</p>

<p>3、活动会接入不同业务线，以达到把流量导入到不同业务线的目的。</p>

<p>4、用户进入页面后，会根据不同的策略展示不同业务的奖品，最多7个奖品。</p>

<p>5、当用户点击“立即抽奖”后，根据不同奖品的不同权重，随机出抽中的奖品，发送领取落地页链接，用户在落地页点击领取。</p>

<p>6、奖品都是来不同的业务线。不存储本地。所以业务方一般要提供两个接口。 查询是可以发奖然后显示，中奖时通知业务方发奖。</p>

<p>如何把不同的业务的接入进来才是这个需求的难点。 不同的业务有不同类型的状态，如红包，试用券， 会员积分，  体验卡，  品牌会员等。</p>

<p>每个业务方都要提供一个查询奖励的接口和一个领奖品的接口。 奖励的数量和库存由对业务方自己决定。</p>

<p><strong>这种方式有好有坏：</strong></p>

<p>1）好处是：奖品的类型和库存可以由各个业务自己配置控制。 活动只是做一个中间路由，只是控制展示策略和命中权重，外加一个兜底奖品。</p>

<p>2）坏处是：过于发散，沟通成本太大，后期活动接入的业务越来越多，性能依赖各个业务的接口的性能。如遇大的调整，每个业务都回归测试一下。</p>

<p>其实，大部分奖品都是可以通知奖池来配置完成。 但这样子业务方无法自己把控奖品。同时也增加了我们运营， 九宫格活动不是京喜的业务，是京东的业务，所以人力成本也是一个原因。</p>

<h1 id="二服务框架">二、服务框架</h1>

<p>所用技术  <code class="language-plaintext highlighter-rouge">c++</code> ,<code class="language-plaintext highlighter-rouge">redis</code>, <code class="language-plaintext highlighter-rouge">http</code> 。</p>

<p>服务整体框架：</p>

<p><img src="/assets/system-design/server-activity-ninebox-2022-09-21_16-55-36.png" alt="" /></p>

<p>说明：</p>

<p>1、 活动通过 <code class="language-plaintext highlighter-rouge">http</code>  的方式提供服务。 两个接口： 一个是查询奖品（query），一个抽奖(draw)。</p>

<p>2、App client 是 京东App。收银台支付页完成后展示出来的是一个h5的页面。 App server是，京东App的服务端，跨团队，客户端没有直接接到我们这边的接口。</p>

<p>3、用户抽奖的相关数据用 <code class="language-plaintext highlighter-rouge">Redis</code> 存储。 中奖信息只保留7天。活动本身并不涉及奖品存储，都是通知业务方发放奖品的。奖品的历史查询是业务方自己的业务逻辑了。</p>

<p>4、业务上要求这个活动是必中活动。所以加入自己的奖池做为兜底。当有业务的奖品库存已经耗尽时，可以用到自己的奖品顶上去。</p>

<p>5、对于请求业务方的奖品，要先按策略选出7个业务的奖品，再通过并发调用接口，提高调用性能。这样，一次并发调用7个接口。</p>

<h2 id="21-展示奖品query">2.1  展示奖品（Query）</h2>

<p>主要逻辑流程图：</p>

<p><img src="/assets/system-design/server-activity-ninebox_2022-09-21_16-20-18.png" alt="" /></p>

<p>说明：</p>

<p>1、 关于奖品的展示策略通过配置中心定义，方便对于策略随时更新。所以服务一开始就要加载配置信息。</p>

<p>2、风险控制方面：１）要求登录，２）查询风控系统　３）判断是否重请求，防止被刷，同一个单多次刷新接口展示一点的奖品。</p>

<p>3、兜底逻辑，在筛选各个业务后如果出现不足七个奖品时，要用查询奖口列表做兜底，满足七个坑位。</p>

<p>4、比较极端的情况下，如果不足7个坑位的奖品，则要求前不展示活动。</p>

<h2 id="22-抽奖接口draw">2.2 抽奖接口（draw） </h2>

<p>主要逻辑流程图：</p>

<p><img src="/assets/system-design/server-activity-ninebox_2022-09-21_16-29-08.png" alt="" /></p>

<p>说明：</p>

<p>1、 抽奖时，要做登录检验，数据从redis中读出，保证数据的一致性。数据缓存redis有7天的时效，这个没有必要重新查询风控。因为写入reids的数据是在查询奖品时就写入的，查询奖品时就已经查询过风控了。</p>

<p> 2、 如果出现异常，返回“谢谢参与“，避免客诉。</p>

<p>3、抽奖后会记录在用户的历史记录中。防止用户重复刷新抽奖。</p>

<p>4、 加redis的乐观锁，防止快速刷时，被不同进程处理。</p>

<h1 id="三总结">三、总结</h1>

<p>这个活动需求最有挑战的，不是开发技术问题，而是沟通问题。随着活动的展开，业务的发展，要求接入的业务越来越多。一个业务的背后是一个不同的团队。沟通起来比较耗时，效率也比较低。 团队也是分散易地办公，很难要规范统一起来，沟通过程出现各种推诿。</p>

<p>当然活动可以做起更加通用一些。 查询接口和通知发奖接口按统一标准接入。可以有一个后台管理系统配置接入业务。配置完成生效后，就可以用。不用每一次新填业务都要去做开发。但做成通知性的难度不低，而且要各个业务方按九宫格的标准备开发接口。我们这边是省事了。他们很难受了。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>java 基本重点知识</title>
      <link href="http://localhost:4000/java-base-learn1/"/>
      <pubDate>2021-07-16T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/java-base-learn1</guid>
      <content:encoded><![CDATA[<p>解释虚拟机指令肯定会比全速运行机器指令慢很多。然而，虚拟机有一个选项，可以将执行最频繁的字节码序列翻译成机器码，这一过程被称为即时编译。</p>

<p>Java虚拟机还有一些其他的优点。它可以检测指令序列的行为，从而增强其安全性。</p>

<h2 id="java的特点">Java的特点</h2>

<ul>
  <li>可移植性</li>
  <li>解释型</li>
  <li>高性能</li>
  <li>多线程</li>
  <li>动态性</li>
</ul>

<h2 id="java-官方的一些源码和文档">Java 官方的一些源码和文档</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">javasrc</code> 在JDK的路径上，有一个src.zip，解开后，含了所有公共类库的源代码。</li>
  <li><code class="language-plaintext highlighter-rouge">javadoc</code>  可以从官网下载文档 https://www.oracle.com/java/technologies/javase-downloads。解压后，可以访问目录上的<code class="language-plaintext highlighter-rouge">jdk-16.0.2_doc-all\docs\index.html</code> 可以在浏览器打开，保存标签，这里可找到所有公共类库的说明。</li>
</ul>

<p><img src="../../assets/java/2021-07-26-java-learn-202449.png" alt="" /></p>

<ul>
  <li>编译器、虚拟机、本地方法以及私有辅助类 http://jdk.java.net/8/ 暂时不看吧。</li>
  <li>书籍代码学习 https://horstmann.com/corejava/ 可以下载。</li>
</ul>

<h2 id="java应用程序">Java应用程序</h2>

<p><strong>注释</strong></p>

<p>有三种注释方式， <code class="language-plaintext highlighter-rouge">//</code>     <code class="language-plaintext highlighter-rouge">/*  */</code>  第三种注释可以生成文档  <code class="language-plaintext highlighter-rouge">/** */</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1、todo </span>

<span class="cm">/* 2、comment */</span>

<span class="cm">/**
* 3、This is a doc comment
*/</span>
</code></pre></div></div>

<h2 id="数据类型">数据类型</h2>

<p>Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型， 8种基本类型。</p>

<p><code class="language-plaintext highlighter-rouge">big number </code> 大数，是一种对象，不是类型。</p>

<p>8种基本类型</p>

<p>整型 <code class="language-plaintext highlighter-rouge">int</code>  4个字节</p>

<p>整型 <code class="language-plaintext highlighter-rouge">short</code> 2个字节</p>

<p>整型 <code class="language-plaintext highlighter-rouge">long</code> 8个字节</p>

<p>整型 <code class="language-plaintext highlighter-rouge">byte</code> 1字节</p>

<p>长整型数值有一个后缀L或l（如4000000000L）。 从Java 7开始，加上前缀0b或0B就可以写二进制数。</p>

<p>浮点型 <code class="language-plaintext highlighter-rouge">float</code> 4个字节</p>

<p>浮点型 <code class="language-plaintext highlighter-rouge">double</code> 8个字节</p>

<p>float类型的数值有一个后缀F或f（例如，3.14F）。没有后缀F的浮点数值（如3.14）默认为double类型。当然，也可以在浮点数值后面添加后缀D或d（例如，3.14D）。</p>

<p>三个特殊的值。</p>

<p>正无穷大  <code class="language-plaintext highlighter-rouge">Double.POSITIVE_INFINITY</code></p>

<p>负无穷大 <code class="language-plaintext highlighter-rouge">Double.NEGATIVE_INFINITY</code></p>

<p>NaN （不是一个数字） <code class="language-plaintext highlighter-rouge">Double.NaN</code></p>

<p>不能这样检测一个特定值是否等于Double.NaN：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">==</span> <span class="nc">Double</span><span class="o">.</span><span class="na">NaN</span><span class="o">)</span> <span class="c1">// is ture </span>
   
<span class="k">if</span> <span class="o">(</span><span class="nc">Double</span><span class="o">.</span><span class="na">isNaN</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="c1">// check x is "not a number"</span>
</code></pre></div></div>

<p>char类型 单个字符， 字面量值要用单引号括起来。<code class="language-plaintext highlighter-rouge">'A'</code>  , <code class="language-plaintext highlighter-rouge">"A"</code> 是一个字符串。可以表示为十六进制值。其范围从<code class="language-plaintext highlighter-rouge">\u0000</code>到<code class="language-plaintext highlighter-rouge">\Uffff</code>。除了转义序列<code class="language-plaintext highlighter-rouge">\u</code>之外，还有一些用于表示特殊字符的转义序列</p>

<p>Unicode类型 另讲。</p>

<p>boolean类型。有两个值：false和true，用来判定逻辑条件。<strong>整型值和布尔值之间不能进行相互转换，这一点要注意和C++不一样</strong>。</p>

<p><strong>枚举类型</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="nc">Size</span><span class="o">{</span><span class="no">SMALL</span><span class="o">,</span> <span class="no">MEDIUM</span><span class="o">,</span> <span class="no">LARGE</span><span class="o">,</span> <span class="no">EXTRA_LARGE</span><span class="o">}</span> <span class="o">;</span> 
</code></pre></div></div>

<h2 id="变量">变量</h2>

<p>在Java中，每个变量都有一个类型（type）。在声明变量时，变量的类型位于变量名之前。 每个声明以分号结束。</p>

<p>变量名必须是一个以字母开头并由字母或数字构成的序列。</p>

<p>不能使用Java保留字作为变量名。</p>

<p>变量名对大小写敏感。</p>

<p>声明一个变量之后，必须用赋值语句对变量进行<strong>显式初始化</strong>。</p>

<p>利用关键字final指示常量。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kt">double</span> <span class="no">CM_PER_INCH</span> <span class="o">=</span> <span class="mf">2.54</span><span class="o">;</span> 
</code></pre></div></div>

<p>类常量的定义位于main方法的外部。</p>

<p><code class="language-plaintext highlighter-rouge">const</code>是 Java 保留的关键字，但目前并没有使用。在Java中，必须使用final定义常量。</p>

<h2 id="运算符">运算符</h2>

<p>在Java中，使用算术运算符<code class="language-plaintext highlighter-rouge">+、-、*、/</code>表示加、减、乘、除运算。</p>

<p>整数的求余操作（有时称为取模）用<code class="language-plaintext highlighter-rouge">%</code>s表示.</p>

<p><strong>数值类型之间的转换</strong></p>

<p>数值类型之间的合法转换.。 6个实心箭头，表示无信息丢失的转换；有3个虚箭头，表示可能有精度损失的转换。</p>

<p><img src="../../assets/java/2021-07-26-java-learn-2024459.png" alt="" /></p>

<p><strong>强制类型转换</strong></p>

<p>可能会丢失一些信息。如</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">9.997</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">x</span><span class="o">;</span> 
</code></pre></div></div>

<p>变量 <code class="language-plaintext highlighter-rouge">nx = 9</code> 小数被截断掉，如果四舍五入用</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">9.997</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="nc">Math</span><span class="o">.</span><span class="na">round</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
</code></pre></div></div>

<p>round方法返回的结果为long类型。所以最后要<code class="language-plaintext highlighter-rouge">（int）</code>转换一下。</p>

<p><strong>结合赋值和运算符</strong></p>

<p>和c++ 一样， <code class="language-plaintext highlighter-rouge">+=</code> 等操作。如：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">+=</span> <span class="mi">4</span><span class="o">;</span> 
</code></pre></div></div>

<p><strong>自增与自减运算符</strong></p>

<p>和c++一样。 如 <code class="language-plaintext highlighter-rouge">x++</code> 、<code class="language-plaintext highlighter-rouge">x--</code> 、<code class="language-plaintext highlighter-rouge">++n</code>、 <code class="language-plaintext highlighter-rouge">--n</code> 。 <code class="language-plaintext highlighter-rouge">++</code>在前在后有区别， 用在表达式中时，前缀形式会先完成加1；而后缀形式会使用变量原来的值。</p>

<p><strong>关系和boolean运算符</strong></p>

<p>基本都沿用了C++的做法。</p>

<p><code class="language-plaintext highlighter-rouge">&amp;&amp;</code>和<code class="language-plaintext highlighter-rouge">||</code>运算符是按照“短路”方式来求值的：如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。</p>

<p>同样支持三元操作符<code class="language-plaintext highlighter-rouge">？:</code></p>

<p>boolean 类型不要做转换。</p>

<h2 id="位运算符">位运算符</h2>

<table>
  <tbody>
    <tr>
      <td>应用在布尔值上时，&amp;和</td>
      <td>运算符也会得到一个布尔值。这些运算符与&amp;&amp;和</td>
      <td> </td>
      <td>运算符很类似，不过&amp;和</td>
      <td>运算符不采用“短路”方式来求值，也就是说，得到计算结果之前两个操作数都需要计算。</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">&gt;&gt;</code>和<code class="language-plaintext highlighter-rouge">&lt;&lt;</code>运算符将位模式左移或右移</p>

<p>有一个新知识：** <code class="language-plaintext highlighter-rouge">&gt;&gt;&gt;</code>运算符会用0填充高位，这与»不同，它会用符号位填充高位。不存在«&lt;运算符。**</p>

<p><strong>括号与运算符级别</strong></p>

<p>与C或C++不同，Java不使用逗号运算符。不过，可以在for语句的第1和第3部分中使用逗号分隔表达式列表。</p>

<h2 id="字符串">字符串</h2>

<p>标准Java类库中提供了一个预定义类，很自然地叫做String。每个用双引号括起来的字符串都是String类的一个实例。</p>

<p>String类的substring方法可以从一个较大的字符串提取出一个子串。</p>

<p>substring的工作方式有一个优点：容易计算子串的长度。字符串s.substring(a, b)的长度为b-a。例如，子串“Hel”的长度为3-0=3。</p>

<p>使用+号连接（拼接）两个字符串。 后面可以是int型。</p>

<p>把多个字符串放在一起，用一个定界符分隔，可以使用静态join方法。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">all</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">" /"</span><span class="o">,</span> <span class="s">"S"</span><span class="o">,</span> <span class="s">"M"</span><span class="o">,</span> <span class="s">"L"</span><span class="o">,</span> <span class="s">"XL"</span><span class="o">);</span> 
<span class="c1">// all is the string  "S / M / L / XL"</span>
</code></pre></div></div>

<p>String类没有提供用于修改字符串的方法。要从原字符串中获取后，重新组成，然后再覆盖回原来的字符串。</p>

<p>不可变字符串却有一个优点：编译器可以让字符串共享</p>

<p>字符串存放在公共的存储池中。字符串变量指向存储池中相应的位置。如果复制一个字符串变量，原始字符串与复制的字符串共享相同的字符。</p>

<p>使用equals方法检测两个字符串是否相等。如果字符串s与字符串t相等，则返回true；否则，返回false。需要注意，s与t可以是字符串变量，也可以是字符串字面。</p>

<p>要想检测两个字符串是否相等，而不区分大小写，可以使用<code class="language-plaintext highlighter-rouge">equalsIgnoreCase</code>方法。</p>

<p>一定不要使用==运算符检测两个字符串是否相等！这个运算符只能够确定两个字符串是否放置在同一个位置上。</p>

<p><strong>空串与Null串</strong></p>

<p>空串”“是长度为0的字符串。可以调用以下代码检查一个字符串是否为空。 空串是一个Java对象，有自己的串长度（0）和内容（空）。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">str</span><span class="o">,</span><span class="n">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
    <span class="c1">// empty string</span>
<span class="o">}</span>

<span class="k">if</span> <span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">""</span><span class="o">)){</span>
    <span class="c1">// empty string</span>
<span class="o">}</span>
</code></pre></div></div>

<p>String变量还可以存放一个特殊的值，名为null，这表示目前没有任何对象与该变量关联。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">str</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
	<span class="c1">// string is null </span>
<span class="o">}</span>
</code></pre></div></div>

<p>检查一个字符串既不是null也不为空串，这种情况下就需要使用以下条件：<strong>首先要检查str不为null</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">str</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
    <span class="c1">// string is not null or empty</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>码点与代码单元</strong></p>

<p>Java字符串由char值序列组成。char数据类型是一个采用UTF-16编码表示Unicode码点的代码单元。大多数的常用Unicode字符使用一个代码单元就可以表示，而辅助字符需要一对代码单元表示。</p>

<p><strong>构建字符串</strong></p>

<p>有些时候，需要由较短的字符串构建字符串，例如，按键或来自文件中的单词。采用字符串连接的方式达到此目的效率比较低。每次连接字符串，都会构建一个新的String对象，既耗时，又浪费空间。使用<strong>StringBuilder</strong>类就可以避免这个问题的发生。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">StringBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span> 

<span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span> <span class="c1">// appends a single character </span>
<span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">str</span><span class="o">)</span> <span class="c1">// appends a string </span>
    
<span class="nc">String</span> <span class="n">completeString</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span> 
</code></pre></div></div>

<h2 id="格式化输出">格式化输出</h2>

<p>使用<code class="language-plaintext highlighter-rouge">System.out.print(x)</code>将数值x输出到控制台上。和C语言中的方法一样的。 <code class="language-plaintext highlighter-rouge">printf</code>和C语言一样。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%8.2f"</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>  <span class="c1">//  same to c printf </span>
</code></pre></div></div>

<p>可以使用静态的String.format方法创建一个格式化的字符串，而不打印输出：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"Hello, %s. Next year, you'll be %d"</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">);</span> 
</code></pre></div></div>

<p><strong>文件输入与输出</strong></p>

<p>对文件进行读取，就需要一个用File对象构造一个Scanner对象。如下所示：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Scanner</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"myfile.txt"</span><span class="o">),</span> <span class="s">"UTF-8"</span><span class="o">);</span> 
</code></pre></div></div>

<p>要想写入文件，就需要构造一个PrintWriter对象。在构造器中，只需要提供文件名：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">PrintWriter</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintWriter</span><span class="o">(</span><span class="s">"myfile.txt"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span> 
</code></pre></div></div>

<h2 id="控制流程">控制流程</h2>

<p>Java的控制流程结构与C和C++的控制流程结构一样，只有很少的例外情况。没有goto语句，但break语句可以带标签。 foreach循环。</p>

<h3 id="块作用域">块作用域</h3>

<p>块（即复合语句）是指由一对大括号括起来的若干条简单的Java语句。块确定了变量的作用域。</p>

<p>不能在嵌套的两个块中声明同名的变量。例如</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
<span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">;</span> 
    <span class="c1">// ...</span>
    <span class="o">{</span>
        <span class="kt">int</span> <span class="n">k</span><span class="o">;</span> 
        <span class="kt">int</span> <span class="n">n</span><span class="o">;</span> <span class="c1">// Error  can't redefine n in inner block</span>
        <span class="c1">// ... </span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="条件语句">条件语句</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">condition</span><span class="o">){</span>
    <span class="n">statement</span> 
<span class="o">}</span><span class="k">else</span> <span class="o">{</span>
    <span class="n">statement</span> 
<span class="o">}</span>
</code></pre></div></div>

<h3 id="循环">循环</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="o">(</span><span class="n">condition</span><span class="o">){</span>
    <span class="n">statement</span> 
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="o">{</span>
    <span class="n">statement</span> 
<span class="o">}</span><span class="k">while</span><span class="o">(</span><span class="n">condition</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span> 
<span class="o">}</span>
</code></pre></div></div>
<h2 id="foreach循环">foreach循环</h2>

<p>Java有一种功能很强的循环结构，可以用来依次处理数组中的每个元素（其他类型的元素集合亦可）而不必为指定下标值而分心.。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="n">variable</span> <span class="o">:</span> <span class="n">collection</span><span class="o">){</span>
    <span class="n">statement</span> 
<span class="o">}</span>
</code></pre></div></div>

<h2 id="多重选择switch语句">多重选择：switch语句</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">choice</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span> 
<span class="k">switch</span><span class="o">(</span><span class="n">choice</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> 
        <span class="c1">// ...</span>
        <span class="k">break</span><span class="o">;</span> 
    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> 
        <span class="c1">// ...</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="k">default</span><span class="o">:</span> 
        <span class="c1">// bad input </span>
        <span class="k">break</span><span class="o">;</span> 
<span class="o">}</span>
</code></pre></div></div>

<h2 id="中断控制流程语句">中断控制流程语句</h2>

<p>break , goto ，continue 等。</p>

<p>与C++不同，Java还提供了一种带标签的break语句，用于跳出多重嵌套的循环语句。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">test</span><span class="o">()</span>
<span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">;</span> 
    <span class="nl">read_data:</span>
    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
        <span class="c1">// ...</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"enter anumber &gt;=0:"</span><span class="o">);</span> 
            <span class="n">n</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span> 
            <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">){</span> <span class="c1">// should never  happend-can't go to </span>
                <span class="k">break</span> <span class="n">read_data</span><span class="o">;</span> <span class="c1">// break out fo read_data loop </span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="大数值">大数值</h2>

<p>如果基本的整数和浮点数精度不能够满足需求，那么可以使用<code class="language-plaintext highlighter-rouge">java.math</code>包中的两个很有用的类：<code class="language-plaintext highlighter-rouge">BigInteger</code>  和 <code class="language-plaintext highlighter-rouge">BigDecimal</code>。</p>

<p>这两个类可以处理包含任意长度数字序列的数值。<code class="language-plaintext highlighter-rouge">BigInteger</code>类实现了任意精度的整数运算，<code class="language-plaintext highlighter-rouge">BigDecimal</code>实现了任意精度的浮点数运算。</p>

<p>使用静态的valueOf方法可以将普通的数值转换为大数值：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BigInteger</span> <span class="n">a</span> <span class="o">=</span> <span class="nc">BigInteger</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span> 
<span class="nc">BigInteger</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">b</span><span class="o">);</span> <span class="c1">// c = a+b</span>
<span class="nc">BigInteger</span> <span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">multiply</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">BigInteger</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">2</span><span class="o">)))</span><span class="c1">// d = c * (b+2)</span>
</code></pre></div></div>

<h3 id="数组">数组</h3>

<p>数组是一种数据结构，用来存储同一类型值的集合。通过一个整型下标可以访问数组中的每一个值。</p>

<p>声明了整型数组a：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">;</span>  <span class="c1">// 声明变更a  或 int a[]</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">100</span><span class="o">]</span> <span class="o">;</span> 
</code></pre></div></div>

<p>有个更加简单的方式打印数组中的所有值，即利用Arrays类的toString方法。调用Arrays.toString(a)，返回一个包含数组元素的字符串，这些元素被放置在括号内，并用逗号分隔，例如，“[2,3,5,7,11,13]”。要想打印数组，可以调用:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">,</span><span class="n">toString</span><span class="o">(</span><span class="n">a</span><span class="o">));</span> 
</code></pre></div></div>

<p><strong>数组初始化以及匿名数组</strong></p>

<p>提供了一种创建数组对象并同时赋予初始值的简化书写形式</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">smallPrimes</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">13</span><span class="o">};</span> 
</code></pre></div></div>

<p>不需要调用 new。</p>

<p>初始化一个匿名的数组：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">13</span><span class="o">};</span> 

<span class="n">smallPrimes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">13</span><span class="o">};</span> 
</code></pre></div></div>

<p><strong>数组拷贝</strong></p>

<p>在Java中，允许将一个数组变量拷贝给另一个数组变量。这时，两个变量将引用同一个数组.。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">[]</span> <span class="n">luckyNumbers</span> <span class="o">=</span> <span class="n">smallPrimes</span><span class="o">;</span> 
<span class="n">luckyNumbers</span><span class="o">[</span><span class="mi">5</span><span class="o">]</span> <span class="o">=</span> <span class="mi">12</span><span class="o">;</span> <span class="c1">// noew smallPrimes[5] is also 12 </span>
</code></pre></div></div>

<p>如果希望将一个数组的所有值拷贝到一个新的数组中去，就要使用Arrays类的<code class="language-plaintext highlighter-rouge">copyOf</code>方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">copiedLickyNumbers</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">luckyNumbers</span><span class="o">,</span> <span class="n">lickyNumbers</span><span class="o">.</span><span class="na">length</span><span class="o">);</span> 
</code></pre></div></div>

<p>第2个参数是新数组的长度。这个方法通常用来增加数组的大小：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">copiedLickyNumbers</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">luckyNumbers</span><span class="o">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">lickyNumbers</span><span class="o">.</span><span class="na">length</span><span class="o">);</span> 
</code></pre></div></div>

<p>Java数组与C++数组在堆栈上有很大不同，但基本上与<strong>分配在堆（heap）</strong>上的数组指针一样。</p>

<h2 id="命令行参数">命令行参数</h2>

<p>每一个Java应用程序都有一个带Stringarg[]参数的main方法。这个参数表明main方法将接收一个字符串数组，也就是命令行参数。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> 
<span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> 
    <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">arg</span> <span class="o">:</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="s">"-version"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"v10000.0"</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

]]></content:encoded>
    </item>
    
    <item>
      <title>java 技术栈学习脉络</title>
      <link href="http://localhost:4000/java-learn-map/"/>
      <pubDate>2021-07-16T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/java-learn-map</guid>
      <content:encoded><![CDATA[<p>继续整理更新中~</p>

<h3 id="一-java基础">一、 java基础</h3>

<ol>
  <li>Linux常用命令</li>
  <li>Shell 脚本编程</li>
  <li>数据结构</li>
  <li>算法</li>
  <li>集合</li>
  <li>IO/NIO</li>
  <li>并发编程
    <ul>
      <li>并发基石线程基础</li>
      <li>synchronized</li>
      <li>JUC</li>
    </ul>
  </li>
  <li>JVM</li>
  <li>JDBC 连接池</li>
  <li>编码规范</li>
</ol>

<h3 id="二jave-web-略过">二、jave web 略过</h3>

<p>JSP、Servlet 、Html、CSS、JavaScript、JQuery、Tomcat</p>

<h3 id="三-重构设计">三 重构设计</h3>

<p>设计原则</p>

<ol>
  <li>开闭原则总则</li>
  <li>依赖倒置原则</li>
  <li>接口隔离原则</li>
  <li>单一职责原则</li>
  <li>里氏替换原则</li>
  <li>最少知道原则</li>
  <li>合成复用原则</li>
</ol>

<p>常用设计模式</p>

<ul>
  <li>创建型模式
    <ul>
      <li>单例模式</li>
      <li>工厂模式</li>
    </ul>
  </li>
  <li>结构型模式
    <ul>
      <li>代理模式</li>
      <li>装饰模式</li>
      <li>适配器模式</li>
    </ul>
  </li>
  <li>行为型模式
    <ul>
      <li>策略模式</li>
      <li>命令模式</li>
      <li>责任链模式</li>
      <li>观察者模式</li>
      <li>模板方法模式</li>
    </ul>
  </li>
</ul>

<p>重构-改善既有代码的设计</p>

<h3 id="三开源框架-重点">三、开源框架 （重点）</h3>

<ol>
  <li>NET 框架 
​    - Netty 
​    - HttpClient 
​    - Mina</li>
  <li>MVC框架
    <ul>
      <li>Sping</li>
      <li>Structs</li>
    </ul>
  </li>
  <li>ORM 框架
    <ul>
      <li>MyBatis</li>
      <li>Hibernate</li>
    </ul>
  </li>
  <li>RPC 框架
    <ul>
      <li>Dubbo</li>
      <li>springCloud</li>
      <li>Thrift</li>
    </ul>
  </li>
  <li>模板引擎
    <ul>
      <li>Velocity</li>
      <li>Freemarker</li>
    </ul>
  </li>
</ol>

<h3 id="四数据存储">四、数据存储</h3>

<ol>
  <li>SQL数据库
    <ul>
      <li>MySQL</li>
      <li>Oracle</li>
      <li>DB2</li>
      <li>分库分表 
ShardingSphere 
MyCat 
TDDL</li>
    </ul>
  </li>
  <li>NoSQL
    <ul>
      <li>Redis</li>
      <li>Hbase</li>
      <li>MongoDB</li>
    </ul>
  </li>
</ol>

<h3 id="五测试技能">五、测试技能</h3>

<ol>
  <li>单元测试MockSpringTest</li>
  <li>压力测试 JMeter</li>
</ol>

<h3 id="六中间件">六、中间件</h3>

<ol>
  <li>Redis</li>
  <li>RocketMQ</li>
  <li>Zookerper</li>
  <li>elasticStack</li>
  <li>etcd</li>
  <li>kafka</li>
  <li>memcashed</li>
</ol>

<h3 id="七性能优化">七、性能优化</h3>

<ol>
  <li>web 前端性能优化 （略过）</li>
  <li>应用服务性能优化
    <ul>
      <li>集群</li>
      <li>缓存</li>
      <li>异步</li>
      <li>代码
        <ul>
          <li>并发</li>
          <li>编程</li>
          <li>资源得胜</li>
          <li>数据结构</li>
        </ul>
      </li>
      <li>JVM</li>
    </ul>
  </li>
  <li>数据存取性能优化
    <ul>
      <li>SQL优化</li>
      <li>索引优化</li>
      <li>数据库架构 + 分库分表</li>
    </ul>
  </li>
</ol>

<h3 id="八架构技能">八、架构技能</h3>

<ol>
  <li>分布式架构
    <ul>
      <li>keepalive + nginx/lvs</li>
      <li>Zooperper</li>
      <li>RPC
        <ul>
          <li>Dubbo</li>
          <li>SpringCloud</li>
        </ul>
      </li>
      <li>服务治理
        <ul>
          <li>服务熔断</li>
          <li>服务降级</li>
          <li>服务限流</li>
          <li>服务隔离</li>
        </ul>
      </li>
      <li>MQ
        <ul>
          <li>RockerMQ</li>
          <li>kafka</li>
        </ul>
      </li>
      <li>缓存
        <ul>
          <li>redis</li>
          <li>memchached</li>
        </ul>
      </li>
      <li>分布数据一致性</li>
      <li>微服务架构</li>
      <li>Docker</li>
      <li>数据库架构
        <ul>
          <li>主备架构</li>
          <li>主从架构</li>
          <li>双主架构 （什么场景会有这个？）</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h3 id="九大数据">九、大数据</h3>

<ol>
  <li>数据收集
    <ul>
      <li>网络爬虫</li>
      <li>Flume/Logstash</li>
    </ul>
  </li>
  <li>数据存储
    <ul>
      <li>HDFSHive (这个算是存储吗？)</li>
      <li>Hbase</li>
      <li>MongoDB</li>
    </ul>
  </li>
  <li>数据检索
    <ul>
      <li>Elasticsearch</li>
    </ul>
  </li>
  <li>数据处理
    <ul>
      <li>Hive</li>
      <li>Storm</li>
      <li>ParkFlink</li>
    </ul>
  </li>
  <li>数据挖掘
    <ul>
      <li>机器学习</li>
    </ul>
  </li>
</ol>

<h3 id="十解决方案">十、解决方案</h3>

<ol>
  <li>技术实践方案</li>
  <li>业务实现方案</li>
</ol>

<h3 id="十一其他技能">十一、其他技能</h3>

<ol>
  <li>开发工具
    <ul>
      <li>Intellij</li>
      <li>IDEA</li>
      <li>Eclipse</li>
    </ul>
  </li>
  <li>项目构建
    <ul>
      <li>MavenGradle</li>
    </ul>
  </li>
  <li>版本控制
    <ul>
      <li>Git</li>
      <li>SVN</li>
    </ul>
  </li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>腾讯云容器团队内部Istio 笔记</title>
      <link href="http://localhost:4000/tencent-cloud-container-team-istio/"/>
      <pubDate>2020-10-17T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/tencent-cloud -container-team-istio</guid>
      <content:encoded><![CDATA[<p>文章来源： <a href="https://www.servicemesher.com/blog/istio-the-king-of-service-mesh/">腾讯云容器团队内部Istio专题分享</a>
作者：钟华</p>

<p>微服务架构是更为复杂的分布式系统，它给运维带来了更多挑战, 这些挑战主要包括资源的有效管理和服务之间的治理, 如:</p>

<p>新的分布式系统:微服务架构 带来了新挑战， 资源的有效管理和服务之间的治理。 其实分布式系统本质上都有这样的挑战，但微服务架构快速发展，让这一些问更加突出了。</p>

<ul>
  <li>服务注册, 服务发现</li>
  <li>服务伸缩</li>
  <li>健康检查</li>
  <li>快速部署</li>
  <li>服务容错: 断路器, 限流, 隔离舱, 熔断保护, 服务降级等等</li>
  <li>认证和授权</li>
  <li>灰度发布方案</li>
  <li>服务调用可观测性, 指标收集</li>
  <li>配置管理</li>
</ul>

<p>在很多微服务架构中，都是通过架构api、sdk。做入侵式的开发，在架构中屏蔽了底层网络的复杂性，提供服务注册发现、服务RPC通信、服务配置管理、服务负载均衡、路由限流、容错、服务监控及治理、服务发布及升级等通用能力。</p>

<p>比较典型的产品有:</p>
<ul>
  <li>分布式RPC通信框架: COBRA, WebServices, Thrift, GRPC 等</li>
  <li>服务治理特定领域的类库和解决方案: Hystrix, Zookeeper, Zipkin, Sentinel 等</li>
  <li>对多种方案进行整合的微服务框架: SpringCloud、Finagle、Dubbox 等</li>
</ul>

<p>service mesh 提供了一种 <strong>Sidecar 模式</strong></p>

<p>这其实不是什么新东西，以前叫做agent, 在两个节点之前加一个代理。 微服务的大部分需要解决的问题，在这sidecar 实现。提供服务注册发现、服务RPC通信、服务配置管理、服务负载均衡、路由限流、容错、服务监控及治理、服务发布及升级等通用能力</p>

<p>Linkerd的CEO Willian Morgan给出的Service Mesh的定义:</p>

<blockquote>
  <p>A Service Mesh is a dedicated infrastructure layer for handling service-to-service communication. It’s responsible for the reliable &gt; delivery of requests through the complex topology of services that comprise a modern, cloud native application. In practice, the
Service Mesh is typically implemented as an array of lightweight network proxies that are deployed alongside application code,
without the application needing to be aware.</p>
</blockquote>

<p>关键字：基础设施层　轻量级网络代理　对应用程序透明</p>

<p>第二代 Service Mesh　在数据平面的基础上添加了控制平面。</p>

<p>国内Service Mesh 发展情况：</p>

<ul>
  <li>蚂蚁金服开源SOFAMesh：
    <ul>
      <li>https://github.com/alipay/sofa-mesh</li>
      <li>从istio fork</li>
      <li>使用Golang语言开发全新的Sidecar，替代Envoy</li>
      <li>为了避免Mixer带来的性能瓶颈，合并Mixer部分功能进入Sidecar</li>
      <li>Pilot和Citadel模块进行了大幅的扩展和增强</li>
      <li>扩展RPC协议: SOFARPC/HSF/Dubbo</li>
    </ul>
  </li>
  <li>华为:
    <ul>
      <li>go-chassis: https://github.com/go-chassis/go-chassis golang 微服务框架, 支持istio平台</li>
      <li>mesher: https://github.com/go-mesh/mesher mesh 数据面解决方案</li>
      <li>国内首家提供Service Mesh公共服务的云厂商
目前(2019年1月)公有云Istio 产品线上已经支持申请公测, 产品形态比较完善
腾讯云 TSF:
基于 Istio、envoy 进行改造
支持 Kubernetes、虚拟机以及裸金属的服务
对 Istio 的能力进行了扩展和增强, 对 Consul 的完整适配
对于其他二进制协议进行扩展支持
唯品会
OSP (Open Service Platform)
新浪:
Motan: 是一套基于java开发的RPC框架, Weibo Mesh 是基于Motan</li>
    </ul>
  </li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>service mesh 学习资料收集</title>
      <link href="http://localhost:4000/service-mesh-refer/"/>
      <pubDate>2020-10-17T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/service-mesh-refer</guid>
      <content:encoded><![CDATA[<h3 id="资料收集">资料收集</h3>

<ul>
  <li><a href="https://zhuanlan.zhihu.com/p/61901608">什么是Service Mesh</a></li>
  <li><a href="https://philcalcado.com/2017/08/03/pattern_service_mesh.html">Pattern: Service Mesh</a></li>
  <li><a href="https://philcalcado.com/">Phil Calçado: https://philcalcado.com/</a></li>
  <li><a href="https://www.servicemesher.com/istio-handbook/">Istio Handbook——Istio 服务网格进阶实战</a></li>
  <li><a href="https://istio.io/">istio官网 https://istio.io/</a></li>
  <li><a href="https://www.servicemesher.com/envoy/">Envoy 官方文档中文版</a></li>
  <li><a href="https://istio.io/latest/zh/docs/ops/deployment/architecture/">Istio</a></li>
  <li><a href="https://github.com/sofastack/sofa-mesh">蚁金服开源SOFAMesh</a></li>
  <li><a href="https://www.servicemesher.com/blog/istio-the-king-of-service-mesh/">腾讯云容器团队内部Istio专题分享</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/38994623">企业级应用弹性伸缩的最佳方式：Service Mesh</a></li>
  <li><a href="https://zjj2wry.github.io/network/iptables/">理解 kube-proxy 中 iptables 规则</a></li>
  <li><a href="https://www.qikqiak.com/post/how-to-use-ipvs-in-kubernetes/">ipvs vs. iptables</a></li>
  <li><a href="https://jimmysong.io/kubernetes-handbook/">Kubernetes Handbook——Kubernetes 中文指南/云原生应用架构实践手册</a></li>
  <li> <a href="https://skyao.io/">敖小剑的博客</a></li>
  <li> <a href="https://www.infoq.cn/article/azCFGyTDGakZqaLEEDMN">蚂蚁金服 API Gateway Mesh 思考与实践</a></li>
  <li> <a href="https://www.servicemesher.com/blog/do-i-need-an-api-gateway-if-i-have-a-service-mesh/">使用了 Service Mesh 后我还需要 API 网关吗</a></li>
  <li><a href="http://blog.itpub.net/69904796/viewspace-2648816/">蚂蚁金服 Service Mesh 落地实践与挑战，附全套PPT下载</a></li>
  <li><a href="http://xiaorui.cc/archives/6051">技术分享之service mesh (k8s&amp;istio)的那些事儿</a></li>
</ul>

<p>书箱：</p>

<p>《Service Mesh实战：用Istio软负载实现服务网格 》</p>

<p>作者：周遥 http://seflerzhou.net</p>

<p>微信读书：https://weread.qq.com/web/bookReview/list?bookId=f57324607188b37df57c39e</p>

<p>《书名：Service Mesh微服务架构设计》</p>

<p>作者：刘俊海</p>

<p>微信读书： https://weread.qq.com/web/reader/42932ba07195510b429d842kc81322c012c81e728d9d180</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>缓存</title>
      <link href="http://localhost:4000/cache/"/>
      <pubDate>2020-08-21T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/cache</guid>
      <content:encoded><![CDATA[<h1 id="一概述">一、概述</h1>

<p>缓存可以提高页面的加载数据速度，减少服务器和数据库的负担。一般是先查询缓存中是否存在，不存在则向数据源请求，然后缓存在本地。</p>

<p>数据库均匀分布的读取当然是最好的，但是现实中存在热门数据，均匀分布读取就变成不可能的事，所以，缓存有效的缓解这一问题。</p>

<h1 id="二缓存分类">二、缓存分类</h1>

<p>1、<strong>客户端缓存</strong>  一般指的是请求的缓存在本地的方式，可以位于客户端（操作系统，浏览器），服务器（当作客户端看待）另一个角度上看可以是进程内。</p>

<p>nginx 缓存配置： <a href="https://www.cnblogs.com/itzgr/p/13321980.html">Nginx缓存配置 ：https://www.cnblogs.com/itzgr/p/13321980.html</a></p>

<p>2、<strong>CDN缓存</strong> 可以当做一种缓存，主要缓存静态文件。</p>

<p>3、<strong>Web服务器缓存</strong>  请求的数据被缓存在web服务器上，当发现这url命中缓存时，直接返回，不再向应用服务器请求数据。反向代理和缓存varnish。</p>

<p>4、<strong>数据库缓存</strong> 大部分数据库是可以配置内存缓存，如 ； mysql <a href="https://zhuanlan.zhihu.com/p/55947158">[玩转MySQL之四]MySQL缓存机制</a>。 针对一般用例进行了优化。调整配置，在不同情况下使用不同的模式可以进一步提高性能。</p>

<p>5、 <strong>应用缓存</strong> 基于内存的缓存比如 <code class="language-plaintext highlighter-rouge">Memcached</code> 和 <code class="language-plaintext highlighter-rouge">Redis</code> 是应用程序和数据存储之间的一种键值存储。由于数据保存在内存中，它比存储在磁盘上的典型数据库要快多了。内存比磁盘容量小得多，所以例如 least recently used (LRU) 的缓存无效算法可以将「热门数据」放在 RAM 中，而对一些比较「冷门」的数据不做处理。</p>

<p>Redis 有下附加功能：</p>

<ul>
  <li>持久性选项</li>
  <li>内置数据结构（有序集合和列表）</li>
</ul>

<h1 id="三缓存级别">三、缓存级别</h1>

<p>缓存时，数据大小范围要缓存到什么级别，这个要依据具体的业务。</p>

<p>1、<strong>对象级别</strong> 一般以对象为单位进行缓存。对象可以是具体业务中的对象，如：玩家的信息 <code class="language-plaintext highlighter-rouge">UserInfo</code>。也可以是数据库中一行数据。</p>

<p>2、<strong>聚合数据</strong> 把一个业务的数据聚合起来缓存。如：直播栏目页中，可能包含了不同业务的数据，把不同的业务数据聚合后缓存起来。</p>

<p>3、<strong>文件缓存</strong> 一般是要放在到CDN上，如前端一些静态页面， 一些兜底用的数据文件。</p>

<p>4、<strong>数据库行数据</strong> 即所数据库中一行的数据完整的缓存起来。</p>

<p>缓存到什么样的级别，要看具体的业务场景，标准是：<strong>提高性能，减少服务器的数据库的压力</strong>。</p>

<h1 id="四缓存更新">四、缓存更新</h1>

<p>缓存可能会导致数据一致问题，对更新缓存的方式要看运用业务的场景。</p>

<p>1、<strong>多读少写</strong></p>

<p>这是一种很普通的场景，要业务对数据延迟性有一定的包容。</p>

<p>写操作可以直接写入 db 中。读操作先读缓存，如果缓存没有，则回源读 db，然后写入缓存。</p>

<p>要注意的是，要根据业务设置缓存的有效时间。最好可配置，方便运营过程随时调整。</p>

<p>这种方式，缓存的数据存在延迟性。即 db 已更新，而缓存的数据还是旧的。要等待缓存的数据过期后，再回源才能是最新的数据。</p>

<p>解决这个问题的方法是，在缓存的数据中加入<strong>脏标</strong>。</p>

<p>写操作更新 db 时，同时如果存在缓存，则更新缓存的脏标。</p>

<p>读操作先读缓存时，如果存在脏标，则回源 db 的数据，写入缓存，去掉脏标。</p>

<p>这个可以解决缓存的延迟性的问题。</p>

<p>如下图：</p>

<p><img src="/assets/system-design/service-cache_2022-09-24_15-33-40.png" alt="" /></p>

<p>以上的方式，业务服务直接操作了 db ，这个方式我们叫 “直接回源”。当数据回源时可能会对服务的性能造成影响。</p>

<p>可以通过 “异步回源” 来解决这个问题。</p>

<p>1、当服务从缓存中读不到数据时，可以通过 MQ 发送消息通知 daemon 从 db 中，把数据加载到缓存中。</p>

<p>2、这样服务第二次读时就可以从缓存中就可以请求到数据了。</p>

<p>这种方式去掉了服务直接读 db 操作提高性能。但是也引入另一个问题，即第一次请求可能返回空。这要求业务对数据的延迟有一定的包容性。</p>

<p>如下图：</p>

<p><img src="/assets/system-design/service-cache-2022-09-24_16-43-23.png" alt="" /></p>

<p>我做过系统中，有把“异步回源” 和 “直接回源” 这两个都用到上的。这样对于数据要求高的，可以请求的参数来控制是否用“直接回源”。</p>

<p>2、 <strong>多读多写</strong></p>

<p>有的场景对于写和读的要求都比较高。此时读写都应该在缓存中。</p>

<p>写操作直接写入缓存中，然后把数据通过 MQ 写入 db。引入 MQ 主要是操作 db 很影响性能。可以把同步写换成异步写。</p>

<p>这种方式的缺点是：用 MQ 写时，可能会丢消息。即写入 db 失败，导致缓存有数据，db 没有数据。最终数据不一致的问题。</p>

<p>如下图：</p>

<p><img src="/assets/system-design/service-cache-2022-09-24_16-13-54.png" alt="" /></p>

<p>解决这个问题的方式是：</p>

<p>1、把数据写入缓存中，并设置标志。同时通过  MQ 通知 daemon 处理 缓存中的数据。</p>

<p>2、daemon 把 缓存中的数据拿出写入 db 中。然后设置缓存中的标示可读。</p>

<p>3、如果写入 db  失败，可能通过再次发送  MQ 再次写入 db。方式可以是：对缓存进行扫描查询有那些数据的标示长时间没有更新可读。</p>

<p>这个方案中，当数据被写到 db 中时，缓存中的数据才可以被读。保证了数据一致性。 同时对于数据丢失做了兜底处理。</p>

<p>如下图：</p>

<p><img src="/assets/system-design/service-cache-2022-09-24_16-28-28.png" alt="" /></p>

<p>多读多写的场景中，很多场景的数据是可以分<strong>冷数据</strong>和<strong>热数据</strong>的。即，一条业务数据到了终态则这个数据可能是冷数据，也就没有必要保存在缓存中了。而热数据则一直在缓存中。</p>

<p>1、数据写入缓存中，设置长期有效。</p>

<p>2、数据每一次更新到缓存中，都要通过 MQ 通知 daemon 处理数据。</p>

<p>3、daemon 接到通知后，如果发现缓存中的数据已经终态，则把数据写入 db 中。</p>

<p>4、当数据写入 db 中后，更新缓存中的数据的有效期。以节约缓存空间。</p>

<p>这个方案，要求缓存中的数据不能出现问题。所以对于数据要求高的业务，最好是要有双缓存，且在不同的机房。</p>

<p>另外，可以增加兜底的 daemon 定时扫描缓存。如果数据已经是终态而没有被处理，则兜底处理它。</p>

<p>如下图：</p>

<p><img src="/assets/system-design/service-cache-2022-09-24_16-59-55.png" alt="" /></p>

<p>缓存应该怎么用，还是要看具体的业务形态。分析出业务的特点，选择出合适的方案。是开发者的专业要求。</p>

<h1 id="五常遇到的问题">五、常遇到的问题</h1>

<p>1、<strong>缓存洞穿问题</strong></p>

<p>即请求缓存时没有数据，要去db 请求数据，db 也没有数据。不断请求就会把流量压到 db s上。造成性能问题。</p>

<p>解决方法是缓存中写入空标。当请求到空标时则直接返回。</p>

<p>对于空标的有效时间最好比数据有效时间短一些。在该业务时被更时，记得要重写入数据覆盖掉空标。</p>

<p>2、<strong>热点 KEY 问题</strong></p>

<p>缓存一个聚合数据。可能请求会出现热点现象。如：直播栏目页的数据。放到同一个 key 中。这时很多请求都落到同一个KEY中。这会造成 redis 实例的压力。</p>

<p>解决方法是可以把同一份数据用不同 KEY 写入到不同实例中。 如：<code class="language-plaintext highlighter-rouge">KEY_%d (d = [1,10])</code>  这样可以把数据分到10个实例中去。</p>

<p>3、<strong>大 KEY 问题</strong></p>

<p>缓存一个聚合数据。如果数据过大。可能会对网络的流量造成压力。对于聚合数据，要设置好约束条件，防止数据膨胀。</p>

<p>解决方案是对聚数据时行拆分，分成多个 key 缓存。</p>

<p>4、<strong>缓存雪崩的问题</strong></p>

<p>当把缓存中的大量数据设置的有效一样时，可能会同时失效，导致同时去回源，从而造成瞬间压力。 所以如果业务上有可能存在这个大量数据被设置同时失效时，则最好把有效时间用正太分布的方式散列开来。</p>

<hr />

<p>1、 <a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E7%BC%93%E5%AD%98">缓存：https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E7%BC%93%E5%AD%98</a></p>

<p>2、<a href="https://en.wikipedia.org/wiki/Cache_replacement_policies">缓存替换策略：https://en.wikipedia.org/wiki/Cache_replacement_policies</a></p>

<p>3、<a href="https://lethain.com/introduction-to-architecting-systems-for-scale/">可缩放系统构架介绍：https://lethain.com/introduction-to-architecting-systems-for-scale/</a></p>

<p>4、<a href="https://en.wikipedia.org/wiki/Cache_(computing)">维基百科：[维基百科](https://en.wikipedia.org/wiki/Cache_(computing)</a></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
