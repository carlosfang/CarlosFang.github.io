<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>xyecho</title>
    <link href="http://localhost:4000/feed/" rel="self" />
    <link href="http://localhost:4000" />
    <lastBuildDate>2022-10-09T22:11:48+08:00</lastBuildDate>
    <webMaster>1447675994@qq.com</webMaster>
    
    <item>
      <title>2022年读书书单</title>
      <link href="http://localhost:4000/2022%E5%B9%B4%E8%AF%BB%E4%B9%A6%E4%B9%A6%E5%8D%95/"/>
      <pubDate>2022-10-07T19:13:00+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/2022年读书书单</guid>
      <content:encoded><![CDATA[<h1 id="底层逻辑-by-吕白">底层逻辑 by 吕白</h1>

<p>书名：《底层逻辑》</p>

<p>作者：吕白</p>

<p>状态：已读完</p>

<p>来源：微信读书</p>

<p>说明：</p>

<p>本来是想读刘润《底层逻辑：看清这个世界的底牌》在微信读书中找到了书，也就随缘把它看完了。</p>

<p>这一本互联网相关的书。</p>

<h1 id="原则-by-瑞达利欧">原则 by 瑞·达利欧</h1>

<p>书名：《原则》 by 瑞·达利欧 已读完</p>

<p>作者：瑞·达利欧</p>

<p>状态：已读完</p>

<p>来源：微信读书、已买了纸质书</p>

<p>说明：</p>

<p>桥水基金创始人的书，2021年很热销的书，关于企业，关于职场。</p>

<p>但是，我看的不是很仔细。有一部是边写代码边听的。</p>

<h1 id="一步一步学spring-boot--by-黄文毅">一步一步学Spring Boot  by 黄文毅</h1>

<p>书名：《一步一步学Spring Boot：微服务项目实战 》</p>

<p>作者：黄文毅</p>

<p>状态：已读完</p>

<p>来源：微信读书</p>

<p>说明：</p>

<p>公司要求技术转行，都转 java 开发。要求学习 Spring Boot。</p>

<p>这书很浅，没有什么太大的价值。</p>

<h1 id="置身事内-by--兰小欢">置身事内 by  兰小欢</h1>

<p>书名：《置身事内》</p>

<p>作者：兰小欢</p>

<p>状态：已读完</p>

<p>来源：微信读书</p>

<p>说明：</p>

<p>这书很好，值的推荐。让我第一次了解了中国政府运作的一些情况，特别是政府对经济发展的思路；土地财政、地方政府和中央政府的博弈等。</p>

<h1 id="麦肯锡结构化战略思维--by-周国元">麦肯锡结构化战略思维  by 周国元</h1>

<p>书名：《麦肯锡结构化战略思维》</p>

<p>作者：周国元</p>

<p>状态：已读完</p>

<p>来源：纸质书</p>

<p>说明：</p>

<p>这本书是，在上家公司上班时，总监介绍的书，领导介绍还是要看一下的。最后发现这书还可以。值得推荐。对于在职场的一些技能表达和对新问题如何入手的一些方法论。</p>

<p>笔记： <a href="http://blog.xyecho.com/%E9%BA%A6%E8%82%AF%E9%94%A1%E7%BB%93%E6%9E%84%E5%8C%96%E6%88%98%E7%95%A5%E6%80%9D%E7%BB%B4/">《麦肯锡结构化战略思维》by 周国元</a></p>

<h1 id="蛤蟆先生去看心理医生-by-罗伯特-戴博德">蛤蟆先生去看心理医生 by 罗伯特 戴博德</h1>

<p>书名：《蛤蟆先生去看心理医生》</p>

<p>作者：罗伯特 戴博德</p>

<p>状态：已读完</p>

<p>来源：纸质书</p>

<p>说明：</p>

<p>这本书是妹妹介绍的。心理学方面的书，我一直对心理学有一定的兴趣。这两年比较推荐的一本书。最后几章把主要问题升级了，学习到了。</p>

<h1 id="麦肯锡工作法--by-大岛祥誉">麦肯锡工作法  by 大岛祥誉</h1>

<p>书名：《麦肯锡工作法》</p>

<p>作者：大岛祥誉</p>

<p>状态：未读完</p>

<p>来源：纸质书</p>

<p>说明：</p>

<p>妹妹送的书，主要讲职场上的一些方法和技能。日本人写的书，很多都比较难读。</p>

<h1 id="java技术核心-by-凯-s霍斯特曼">java技术核心 by 凯 S.霍斯特曼</h1>

<p>书名：《java技术核心》券1、券2</p>

<p>作者：凯 S.霍斯特曼</p>

<p>状态：未读完</p>

<p>来源：纸质书</p>

<p>说明：</p>

<p>java  经典书籍。因从上家离职，没有继续看 java 的。后面有机会可以继续看。</p>

<h1 id="python深度学习-2018中文版">Python深度学习 2018中文版</h1>

<p>书名：《_Python深度学习 2018中文版》</p>

<p>作者：</p>

<p>状态：未读</p>

<p>来源：电子书  pdf</p>

<p>说明：</p>

<p>人工智能、深度学习、python 方面的书，博士介绍的书，书也他发给我的。想先看数学基础后，再看了。</p>

<h1 id="垃圾回收的算法与实现-by-中村成洋">垃圾回收的算法与实现 by 中村成洋</h1>

<p>书名：《垃圾回收的算法与实现》</p>

<p>作者：中村成洋</p>

<p>状态：未读完</p>

<p>来源：电子书  pdf</p>

<p>说明：</p>

<p>垃圾回收算法，日本人写的书。同事介绍的，看了一半，书不错，应该要看完它。</p>

<h1 id="制内市场-by-郑永年">制内市场 by 郑永年</h1>

<p>书名：《制内市场》</p>

<p>作者：郑永年 、 黄彦杰 、 邱道隆</p>

<p>状态：未读完</p>

<p>来源：微信读书</p>

<p>说明：</p>

<p>一本关于中国政治经济的书，比较有中国特色。老蒋介绍的。</p>

<p>[[制内市场 中国国家主导型政治经济学   by 郑永年 黄彦杰]]</p>

<h1 id="红星照耀中国-by-埃德加斯诺埃">红星照耀中国 by 埃德加·斯诺埃</h1>

<p>书名：《红星照耀中国》</p>

<p>作者：埃德加·斯诺埃</p>

<p>状态：未读</p>

<p>来源：微信读书</p>

<p>说明：老蒋介绍的书，关于中国近代。</p>

<h1 id="孩子的品格--by-彭凯平">孩子的品格  by 彭凯平</h1>

<p>书名：《孩子的品格》</p>

<p>作者：彭凯平 、闫伟</p>

<p>状态：读完</p>

<p>来源：纸质书</p>

<p>说明：</p>

<p>俞敏洪介绍的书，积极心理学方面的书。很不错，之前看心理方面的书大部分都比较消极。</p>

<p>要重读一下并做笔记。</p>

<h1 id="后台开发核心技术与应用实践-by-徐晓鑫">后台开发：核心技术与应用实践 by 徐晓鑫</h1>

<p>书名：《后台开发：核心技术与应用实践》</p>

<p>作者：徐晓鑫</p>

<p>状态：读完</p>

<p>来源：纸质书</p>

<p>说明：</p>

<p>应该是第三遍看了，后台开发的基础。</p>

<h2 id="影响力-by-罗伯特西奥迪尼">影响力 by 罗伯特·西奥迪尼</h2>

<p>书名：《影响力》</p>

<p>作者：罗伯特·西奥迪尼</p>

<p>状态：读完</p>

<p>来源：纸质书</p>

<p>说明：</p>

<p>经典书籍，可以重复读。</p>

<h1 id="leetcode-c-面试突击--by-leetcode">leetcode C++ 面试突击  by leetcode</h1>

<p>书名：《leetcode C++ 面试突击》</p>

<p>作者：leetcode</p>

<p>状态：读完</p>

<p>来源：<a href="https://leetcode.cn/leetbook/read/cpp-interview-highlights/oxy0e5/">网站</a></p>

<p>说明：</p>

<p>面试八股文，回顾c++ 基础。</p>

<p>1、 <a href="http://blog.xyecho.com/c++-base/">c++ 基础知识</a></p>

<p>2、<a href="http://blog.xyecho.com/c++-cass/">c++  类和对象</a></p>

<p>3、<a href="http://blog.xyecho.com/c++-pointer/">c++ 基础 指针相关</a></p>

<p>4、<a href="http://blog.xyecho.com/c++-function/">c++ 关键字库函数知识点</a></p>

<h1 id="卡片笔记写作法-by-申克阿伦斯">卡片笔记写作法 by 申克·阿伦斯</h1>

<p>书名：《卡片笔记写作法》</p>

<p>作者：申克·阿伦斯</p>

<p>状态：未读完</p>

<p>来源：微信读书</p>

<p>说明：</p>

<p>工具提交方面的书，哥介绍的。方法很好，正在实践运用中。</p>

<h1 id="一则关于用户导向设计师的-寓言-by-戴维崔弗斯">一则关于用户导向设计师的 寓言 by 戴维·崔弗斯</h1>

<p>书名：《一则关于用户导向设计师的 寓言》</p>

<p>作者：戴维·崔弗斯</p>

<p>状态：读完</p>

<p>来源：电子书 pdf</p>

<p>说明：微博上网友介绍的，关于用户体验的书。</p>

<p>blog : <a href="http://blog.xyecho.com/%E4%B8%80%E5%88%99%E5%85%B3%E4%BA%8E%E7%94%A8%E6%88%B7%E5%AF%BC%E5%90%91%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%9A%84%E5%AF%93%E8%A8%80/">《一则关于用户导向设计师的寓言》 by David Travis</a></p>

<h1 id="大衰退-by-辜朝明">大衰退 by 辜朝明</h1>

<p>书名：《大衰退–如何在金融风暴中幸存和发展》</p>

<p>作者：辜朝明</p>

<p>状态：未读完</p>

<p>来源：电子书 pdf</p>

<p>说明：</p>

<p>师弟介绍的书，因为这两年经济开始衰退了，所以想看看日本等国家以前是怎么做的。</p>

<h1 id="改革历程-by--zzy">改革历程 by  zzy</h1>

<p>书名：《改革历程》</p>

<p>作者：zzy</p>

<p>状态：读完</p>

<p>来源：电子书 pdf</p>

<p>说明：</p>

<p>我国近代历史口述的，了解了当前的一些问题的历史原因。</p>

<h1 id="觉者之言-by-三界智尊者">觉者之言 by 三界智尊者</h1>

<p>书名：《觉者之言》</p>

<p>作者： 三界智尊者</p>

<p>状态：未读完</p>

<p>来源：纸质书</p>

<p>说明：</p>

<p>佛教入门指南。</p>

<h1 id="人性的弱点">人性的弱点</h1>

<p>书名：《人性的弱点》</p>

<p>作者：戴尔 卡耐基</p>

<p>状态：未读完</p>

<p>来源：纸质书</p>

<p>说明：</p>

<p>一本为人处世的书。How to win frientds and influence people.  不知道为什么翻译成人性的弱点。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>《一则关于用户导向设计师的寓言》 by David Travis</title>
      <link href="http://localhost:4000/%E4%B8%80%E5%88%99%E5%85%B3%E4%BA%8E%E7%94%A8%E6%88%B7%E5%AF%BC%E5%90%91%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%9A%84%E5%AF%93%E8%A8%80/"/>
      <pubDate>2022-09-27T19:13:00+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/一则关于用户导向设计师的寓言</guid>
      <content:encoded><![CDATA[<p>David Travis 戴维·崔弗斯 著作。</p>

<p>许晴晏 中文翻译。</p>

<p><a href="https://www.userfocus.co.uk/fable/?continueFlag=c1068e7e0e455bd9923ad0f16a65f620">下载：https://www.userfocus.co.uk/fable/?continueFlag=c1068e7e0e455bd9923ad0f16a65f620</a></p>

<p><a href="https://www.userfocus.co.uk/pdf/Fable_Simplified_CN.pdf">中文版：https://www.userfocus.co.uk/pdf/Fable_Simplified_CN.pdf</a></p>

<p><img src="/assets/reading/fable-simplified-cn_2022-09-27_12-27-37.png" alt="" /></p>

<p>大部分的设计师对美的追求：“我的设计在视觉上看起来很惊艳， 我设计的接口很吸引人的目光。”</p>

<p>寻找有效率的设计师，整体来说应该是可以利用科技去创造出对公司、客户或社会有益的产品。</p>

<p>而用户导向设计师则是重视的是在使用产品跟网站的这些人，而不是专注在视觉设计或是偏重新科技设计。</p>

<p><strong>第一个用户导向设计的秘密: 及早并持续的专注在用户以及他们的工作上</strong></p>

<p>大部分设计师其实不了解用户实际上如何使用他们的系统的。一些系统注定了它要面向一些特殊的用户，它的“一般用户”可能并不存在，是设计师自己想像出为的虚构用户。导致做出一些伪需求。</p>

<p>设计师要知道自己的软件是为谁设计的，使用者的群体是什么？他们用这个系统做什么？</p>

<p>所以要建立根据研究资料的典型人物 ， 而不是根据我们推测而出的客户。假设是好事， 但是实际发现更好。</p>

<p>建立一个实际拜访客户的计划：</p>

<p>1、了解客户的动机。创造典型人物，</p>

<p>2、使用产品的环境。例如公司文化。</p>

<p>3、发展红线区。红线区代表关键用户的旅程跟产品。即系统的最主要任务。</p>

<p>有些任务比任何任务都重要，这就是红线区。借着专注在红线区， 我们可以让比较不重要的功能不要占了界面的位置，使得界面看起来复杂凌乱。但这些功能还是存在， 只是当你要使用它时， 你可能要透过对话框或是在界面其他位置去取用它。</p>

<p>到用户实际访谈是要帮助你了解你设计的对象，用户如何使用这软件以及使用软件的环境。</p>

<p>可以使用 ’敏捷设计’ (Agile) 快速开发更新改善版本的软件，节省时间。</p>

<p><strong>第二个关于用户导向设计的秘密：经验性量测用户的行为</strong></p>

<p>如果你想要发现你产品上的问题，你就要找人来使用它。这样才可以发现产品中的<strong>无形的错误</strong>。</p>

<p>做使用性测试 (Usability Test)。他请我们的顾客使用这手机然后当他们使用时，我们观察他们。</p>

<p>量测了产品的使用性；</p>

<p>1、量测有效性：多少人可以正确的 完成红线区的任务。</p>

<p>2、量测效率性：客户完成这些任 务的时间。</p>

<p>3、量测了满意度：他们对这设计的感觉。</p>

<p><strong>第三个用户导向设计的秘密：重复性设计</strong></p>

<p>用户导向设计师介绍我们一种技巧，叫做纸上模型，它可以让我们很快的测试新的网站。或者电子模型测试。</p>

<p>这个测试的意义是：<strong>帮助我们确认我们拿到了正确的信息结构</strong>。</p>

<p>重复性设计。在开始写代码前一定要做设计，然后做重复性的推演，看看其中是否有什么遗漏。这也是我做研发的心得之一。</p>

<p>第一个关于用户导向设计的祕密有四个重点：</p>

<p>1、你必须专注在用户。</p>

<p>2、你必须了解用户的任务。</p>

<p>3、你必须及早开始。</p>

<p>4、你必须持续的做研究</p>

<blockquote>
  <p>即使他们开始做研究，通常不是那种更好的设计会需要的那种。研究通常在于人口统计学因素而不是真正去了解用户的目标跟动机。</p>
</blockquote>

<p>很多需要的依据都是数据统计，布数据统计可能并不能体现出人用户目标和动机，而现场访问却是可以真实感受的。</p>

<p>另外，对于用户的主需求的调研，一般都是在研发前期，这没有什么不对的。<strong>只是还不够，用户和需求的调研没有持续进行到整个周期</strong>。</p>

<p>访问用户时，只听听他们怎么说，分析他们的怎么说是不够，应该更进一点，<strong>观察他们是怎么用的，怎么操作的</strong>。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>《麦肯锡结构化战略思维》by 周国元</title>
      <link href="http://localhost:4000/%E9%BA%A6%E8%82%AF%E9%94%A1%E7%BB%93%E6%9E%84%E5%8C%96%E6%88%98%E7%95%A5%E6%80%9D%E7%BB%B4/"/>
      <pubDate>2022-05-28T19:13:00+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/麦肯锡结构化战略思维</guid>
      <content:encoded><![CDATA[<p>近些年，职场上发现，非技术的能力成了发展的短板。如良好的沟通，系统的思考。内心抗拒和陌生人接触。这个性格就是技术型的。</p>

<p>领导介绍了这本书《麦肯锡结构化战略思维》，感觉不错，在职场迷茫不知道怎么做个好人的可以看一下。</p>

<p>主要讲的是：对于一个新问题，新领域，用什么的原则和方法去切入，自上而下，有自己的洞见，用数据和逻辑讲故事，最后做出一个漂亮的交付。</p>

<p>事后也对思辨者做一些总结，形成习惯，方便以后可持续的输出。</p>

<p>它更像是一些职场的方法论。当然也可延生到生活，学习的等场景。</p>

<p><img src="/assets/reading/reading-book-jghsw20220528.jpeg" alt="" /></p>

<p>书主要从 <strong>原则、方法、习惯</strong> 三方面介绍。</p>

<h1 id="一原则">一、原则</h1>

<p>结构化思考的过程，我们要定一些原则，以免在这个过程中掉到坑里。</p>

<p>1、数字</p>

<p>当我们看到数据时，第一反应是质疑。是数据是否有问题？第二个反应是，这数据是否可以推出来这样的结论。</p>

<p>另外， 数据一定是和逻辑在一起的，有数据，没有逻辑是死数据，无用的。</p>

<p>如果数据都没有问题，数据中却出现特例，那可能就是问题所在了。 数据的<strong>异常点</strong>可能就是背后的支撑逻辑有问题。</p>

<p>数据只能说明过去的，而我们追求的时未来，价值在未来。</p>

<p>2、洞见</p>

<p>从数据加逻辑，我们可能得到信息，从信息中，我们提炼出洞见。 洞见就是我们要所要的结果。</p>

<p>洞见的来源：</p>

<p>数据的替身和数据趋势， 数据背后的实体是什么，将走向何处，提炼出来就是洞见。</p>

<p>数据的异常点，极端点，以及其他合理背后的逻辑，就是洞见。</p>

<p>数据对比的结果，差异就是洞见。</p>

<p>数据周边的相关信息，也可以是洞见。</p>

<p>以后，所有的推化和提炼都可以成洞见。</p>

<p>3、MECE 原则</p>

<p>MECE原则，就是一种切问题的方法。 或者说分拆问题的原则。</p>

<ul>
  <li>子分类相互独立无重叠</li>
  <li>子分类加起来穷尽全部可能</li>
</ul>

<p>这个两个原则，我的理解是子问题要解藕，方便独立解决。</p>

<p>4、 假设</p>

<p>个人觉得假设很重要。假设是探讨问题的一个开始。<strong>假设，论证，再假设，再论证。</strong> 几个轮回之后，很多背后的逻辑也浮出了水面。</p>

<p>过程不介绍探讨假设。很多人不喜欢假设。一开口就是说“你别给我假设”，“这只是你的假设”。可能太急燥了，就想一开始就能切中问题所在吧。</p>

<h1 id="二方法">二、方法</h1>

<p>把一个问题搞懂的方法论，就是如下图这个步骤了。</p>

<p><img src="/assets/reading/reading-book-jghsw2022-05-28_14-16-01.png" alt="" /></p>

<h2 id="定义问题">定义问题</h2>

<p>1、之所以要重新定义问题，因为我们拿到手的问题，可能是个假问题。所以第一步要确认问题的正确性。</p>

<p>2、 所以用一些手段，即定义问题的工具：</p>

<ul>
  <li>问题的背景，从全局的角度看待这个问题。</li>
  <li>问题的边界，解决问题约束。即，问题的不能无限扩大，解决的资源不是无限的。</li>
  <li>解决问题的标准是什么，即达到什么程度，这个问题才算解决。</li>
  <li>问题的相关人，责任人。</li>
</ul>

<p>书上写的工具不只四个，但我觉得有一些可以合并。这几项，大概就可以把问题圈定在一定的范围内。我们目标也明确了。后面的假设不会超过这个范围遨游太虚去了。</p>

<p>3、MECE 原则</p>

<p>如上面已讲，这个原则就是切问题的，把问题拆分成子问题。</p>

<p>4、多维图谱</p>

<p>可以用思维导图呈现你的思考过程，当有你很多假设、验证过程时会更加清晰的呈现出思考对错。</p>

<h2 id="结构化分析">结构化分析</h2>

<p>结构化分析和切问题估计应该就是本书的核心章节了，如下图，就是结构化思维最基本的主流程了。其实前面的所有步骤做之后，就已经进入分析状态了。</p>

<p><img src="/assets/reading/reading-book-jghsw2022-05-28_14-52-53.png" alt="" /></p>

<h3 id="1切问题">1、切问题</h3>

<p>个人觉得切问题，怎么样切，要看个人的能力，对所在领域的业务能力。如果你什么都不了解，不清楚。想切也无从下手。所以，结构化分化要有领域专业基础能力做支撑。</p>

<p>书中讲的只一些通用方法，具体问题还要具体分析。</p>

<ul>
  <li>公式法</li>
  <li>子目录列举法</li>
  <li>流程法</li>
  <li>逻辑框架法</li>
</ul>

<h3 id="2逻辑思维">2、逻辑思维</h3>

<p>这个已经上升到逻辑学层面了，可能算是基本法则了。但因果性和相关性可能是很多容易犯的错而不自知。</p>

<ul>
  <li>归纳法（自下而上）</li>
  <li>演绎法（自上而下）</li>
  <li>因果性和相关性</li>
</ul>

<h3 id="3提出假设">3、提出假设</h3>

<p>切出子问题之后，对子问题的解决，就是多次假设，多次验证。 假设也不是天马行空的，上面在问题的准备时已经就做限制。 提出假设的方法主要有：</p>

<ul>
  <li>假设清单。 所有的过程都不应该外露，这个假设清单也是，很多会被证伪。</li>
  <li>头脑风暴。 提出有差异、平等、发散的各种意见。</li>
  <li>杜绝专家过早参与。专家过早参与，有可能被画地为牢。专家应该在验证过程会更好。</li>
</ul>

<h3 id="4验证假设">4、验证假设</h3>

<p>验证假设应该是整个过程最花精力的地方了。主要通过调研和访谈两方面。</p>

<p>调研的分类有：</p>

<ul>
  <li>案头调研。收集相关的资料，当然是越多越好。但这只是第一步，很多人只做到这一步。</li>
  <li>实地调研。 案头调研之后，再深入的就是实地调研。如投资，不单要看财报，要市场做调研。</li>
</ul>

<p>人个觉得调研的技巧，可以专门找书籍来学习。 调研技巧：</p>

<ul>
  <li>商业敏感度</li>
  <li>表达沟通能力</li>
  <li>自驱力</li>
  <li>情商、同理心</li>
  <li>数据字分析技能</li>
</ul>

<p>访谈就是沟通，如何很好的沟通，是一门很能难的学问，也是不被看重的能力。 也因当专门学习。</p>

<p>访谈技巧：</p>

<ul>
  <li>对被访者的尊重，注意情绪的波动</li>
  <li>聆听后的提炼，重述</li>
  <li>对话要输入新的增值信息</li>
  <li>以结果为导向的访谈态度</li>
  <li>培养建立长期信任关系</li>
  <li>保护好被访问者</li>
</ul>

<h3 id="5交付">5、交付</h3>

<p>切问题是这个过程中最核心的技术，验证是最花精力的过程，那么交付就是最重要的结果了。</p>

<p>前面的所有努力都在这里呈现，如果呈现不出了，估计别人觉得你什么都没做了。</p>

<p>交付分为三个阶段： 交付前，交付时，交付后。</p>

<p>交付后， 是我个人加进去了。 因为真的交付后，还有很多事情可以做的，如总结，复盘，优化以后的流程，分享等。</p>

<p>交付前：</p>

<ul>
  <li>只有充分的准备，没有过度的准备。</li>
  <li>对自己的心理建设。</li>
</ul>

<p>交付时：</p>

<ul>
  <li>商务沟通：讲故事</li>
  <li>沟通是双向，多向的</li>
  <li>沟通是多层面的， 信息，洞见，个性化，情绪，情感</li>
  <li>沟通多形式</li>
  <li>沟通的外部影响</li>
  <li>沟通的3S 原则</li>
  <li>沟通的金字塔原则</li>
</ul>

<p>自己总结一点，平时，可以用电机叙述的方式用5W2H分析法把事情讲清楚。</p>

<h1 id="三习惯">三、习惯</h1>

<p>最后，对于一个结构化思辨者，我们应该养成什么样的习惯呢？</p>

<ul>
  <li>反对的责任</li>
  <li>解决正确的问题</li>
  <li>下一层面的细节</li>
  <li>总结提炼， 电梯陈述，讲清5W2H</li>
  <li>第一天的答案， 可以快速理清框架，出思路，可以过掉细节</li>
  <li>问正确的问题</li>
  <li>认为还是知道</li>
  <li>移动时间轴</li>
  <li>数据和逻辑</li>
  <li>知道边界</li>
</ul>

<p>如果， 只能记住三点，那么我会选择：</p>

<p>1、质疑数据，数据一定要有逻辑。</p>

<p>2、正确的问题</p>

<p>3、总结提炼， 电梯陈述，讲清5W2H</p>

<h1 id="四总结">四、总结</h1>

<p>像《查理穷宝典》中芒格说的，我们要一些思维模型，用这一些工具来对世界上的事物进行思考。 学习的过程就是不断的建议自己的思维模型。</p>

<p>结构化思维对于职场来说是一个很好的思维模型，可以以这个为基础，不断打磨自己的方法论。形成自己的思维工具。</p>

<p>人不固执己见，终身学习才是王者，这个和年纪没有什么关系。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>如何处理一个系统设计</title>
      <link href="http://localhost:4000/server-how-to-design-systerm/"/>
      <pubDate>2022-03-21T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/server-how-to-design-systerm</guid>
      <content:encoded><![CDATA[<p>这是一个开放性问题， 这文章中提供了一个大概的思考步骤。<a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98">如何处理一个系统设计的面试题</a>
后续学习工作中，可以不断的完善这一些思考。</p>

<h2 id="第一步描述使用场景约束和假设">第一步：描述使用场景，约束和假设</h2>

<p>把所有需要的东西聚集在一起，审视问题。不停的提问，以至于我们可以明确使用场景和约束。讨论假设。</p>

<ul>
  <li>谁会使用它？</li>
  <li>他们会怎样使用它？</li>
  <li>有多少用户？</li>
  <li>系统的作用是什么？</li>
  <li>系统的输入输出分别是什么？</li>
  <li>我们希望处理多少数据？</li>
  <li>我们希望每秒钟处理多少请求？</li>
  <li>我们希望的读写比率？分别什么场景？</li>
</ul>

<h2 id="第二步创造一个高层级的设计">第二步：创造一个高层级的设计</h2>

<p>使用所有重要的组件来描绘出一个高层级的设计。</p>

<ul>
  <li>画出主要的组件和连接。 画出框架图，不宜太细仔。主要体现出组件的关系和数据流。</li>
  <li>证明你的想法。 根据框架图，推演一下，能不能解决问题。</li>
</ul>

<h2 id="第三步设计核心组件">第三步：设计核心组件</h2>

<p>对每一个核心组件进行详细深入的分析。举例来说，如果你被问到设计一个 url 缩写服务，开始讨论：</p>

<ul>
  <li>生成并储存一个完整 url 的 hash
    <ul>
      <li>MD5 和 Base62</li>
      <li>Hash 碰撞</li>
      <li>SQL 还是 NoSQL</li>
      <li>数据库模型</li>
    </ul>
  </li>
  <li>将一个 hashed url 翻译成完整的 url
    <ul>
      <li>数据库查找</li>
    </ul>
  </li>
  <li>API 和面向对象设计</li>
</ul>

<h2 id="第四步扩展设计">第四步：扩展设计</h2>

<p>确认和处理瓶颈以及一些限制。举例来说就是你需要下面的这些来完成扩展性的议题吗？</p>

<ul>
  <li>负载均衡</li>
  <li>水平扩展</li>
  <li>缓存</li>
  <li>数据库分片</li>
</ul>

<p>论述可能的解决办法和代价。每件事情需要取舍。可以使用可扩展系统的设计原则来处理瓶颈。</p>

<h2 id="预估计算量">预估计算量</h2>

<p>你或许会被要求通过手算进行一些估算。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>《底层逻辑》by 吕白</title>
      <link href="http://localhost:4000/%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"/>
      <pubDate>2022-02-23T19:13:00+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/底层逻辑</guid>
      <content:encoded><![CDATA[<p>不要担心自己赚不到钱，也不要因为赚到了钱而高兴得太早，提升认知是你最需要做的事。当你提升了认知水平之后，哪怕你现在还没赚到钱，也不必太着急，你的财富一定会很快跟上你的认知提升的速度。</p>

<p>投资理财时，也请牢记“成功=赛道×效率”的公式。如果要投资，就找到未来最厉害的赛道，投第一名或投整个赛道。未来什么赛道最厉害？看钱在哪里，当年“4万亿”经济刺激计划的钱投到了房地产领域，现在钱又在哪里呢？</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>服务发现原理</title>
      <link href="http://localhost:4000/server-service-discovery/"/>
      <pubDate>2022-01-26T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/server-service-discovery</guid>
      <content:encoded><![CDATA[<h1 id="一概述">一、概述</h1>

<p>在微服务分布式框架中，服务被拆分成很微小服务，各自独立。由多个台机器组成，各服务之间相互调用，有管理各种服务的需求。 服务发现机制可以降低服务管理的成本。</p>

<p>在服务发现之前，服务之间的调用，可能要在各服务代码中写死IP 或者 通过配置文件读出服务之间的IP。</p>

<p>服务发现机制则一分两步:</p>

<p>1、服务注册。 在服务启动时，把自己的<strong>IP和端口</strong> 通过服务注册定入到服务管理平台中，以便提供给其他主调用。</p>

<p>2、服务发现。其他方调用时则要先通过服务平台拿到这个服务其中的一个<strong>IP和端口</strong>，然后再调用。</p>

<p>如图：</p>

<p><img src="/assets/system-design/service-discovery-2022-09-23_11-53-40.png" alt="" /></p>

<p>说明：</p>

<p>1、 server b 把自己注册到  service registry  叫做 <strong>服务注册</strong>。</p>

<p>2、 server  a  从 service registry 发现 server b 的节点信息叫做 <strong>服务发现</strong>。</p>

<p>3、最后 server a 调用 server b。</p>

<h1 id="二服务注册">二、服务注册</h1>

<p>服务注册，简单的说是，就是把自己的IP和端口写到服务管理平台上形成一组服务，告诉所有其他的服务，想调用我，可以通过服务管理平台上的服务名找到我的IP和端口。</p>

<p>服务注册的大概框架图：</p>

<p><img src="/assets/system-design/service-discovery-2022-09-23_00-58-18.png" alt="" /></p>

<p>一般一个服务会有多个 IP 和端口。 如：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="err">user</span><span class="w"> </span><span class="err">server</span><span class="w"> 
</span><span class="p">[</span><span class="w">
	</span><span class="p">{</span><span class="w"> 
		</span><span class="nl">"ip"</span><span class="p">:</span><span class="mf">127.0</span><span class="err">.</span><span class="mf">0.1</span><span class="p">,</span><span class="w">
		</span><span class="nl">"port"</span><span class="p">:</span><span class="mi">8800</span><span class="w">
	</span><span class="p">},</span><span class="w">
	</span><span class="p">{</span><span class="w"> 
		</span><span class="nl">"ip"</span><span class="p">:</span><span class="mf">127.0</span><span class="err">.</span><span class="mf">0.2</span><span class="p">,</span><span class="w">
		</span><span class="nl">"port"</span><span class="p">:</span><span class="mi">8800</span><span class="w">
	</span><span class="p">},</span><span class="w">
	</span><span class="p">{</span><span class="w"> 
		</span><span class="nl">"ip"</span><span class="p">:</span><span class="mf">127.0</span><span class="err">.</span><span class="mf">0.3</span><span class="p">,</span><span class="w">
		</span><span class="nl">"port"</span><span class="p">:</span><span class="mi">8800</span><span class="w">
	</span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="w">

</span><span class="err">#</span><span class="w"> </span><span class="err">live</span><span class="w"> </span><span class="err">server</span><span class="w"> 
</span><span class="p">[</span><span class="w">
	</span><span class="p">{</span><span class="w"> 
		</span><span class="nl">"ip"</span><span class="p">:</span><span class="mf">127.0</span><span class="err">.</span><span class="mf">1.1</span><span class="p">,</span><span class="w">
		</span><span class="nl">"port"</span><span class="p">:</span><span class="mi">8801</span><span class="w">
	</span><span class="p">},</span><span class="w">
	</span><span class="p">{</span><span class="w"> 
		</span><span class="nl">"ip"</span><span class="p">:</span><span class="mf">127.0</span><span class="err">.</span><span class="mf">1.2</span><span class="p">,</span><span class="w">
		</span><span class="nl">"port"</span><span class="p">:</span><span class="mi">8801</span><span class="w">
	</span><span class="p">},</span><span class="w">
	</span><span class="p">{</span><span class="w"> 
		</span><span class="nl">"ip"</span><span class="p">:</span><span class="mf">127.0</span><span class="err">.</span><span class="mf">1.3</span><span class="p">,</span><span class="w">
		</span><span class="nl">"port"</span><span class="p">:</span><span class="mi">8801</span><span class="w">
	</span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="w">

</span></code></pre></div></div>

<p>说明：</p>

<p>1、业务服务会向服务平台注册一个服务名，把自己的 IP和端口号写入。</p>

<p>2、一般情况下，同一个服务，所有端口最好一样，方便管理。</p>

<p>3、以现在docker 的技术，一般是一个实例只能跑一个业务服务。但也有企业了节约成本，也会在同一个docker 跑多个服务。</p>

<p>4、有的解决方案是在服务管理平台手动的写入服务名和对应的IP列表。 服务名要全局惟一。</p>

<h1 id="三服务发现">三、服务发现</h1>

<p>服务发现，即当server a 想请求 serve b 时，应该如何找到合适的IP和端口呢？如：</p>

<p>user sever 这个服务 有三台机器，  live server  也有三台机器。 live sever1  想请求 user server  的业务接口。它就应该先请求服务管理平台。</p>

<p>服务管理平台返回了 user server 中的一个IP和端口。 （负载均衡后的结果）</p>

<p><img src="/assets/system-design/service-discovery-2022-09-23_11-09-13.png" alt="" /></p>

<p>上图说明：</p>

<p>1、 live server1 想请求 user server 中的接口。</p>

<p>2、live server1 要请求服务管理平台，服务管理平台返回了 user server 其中的一个IP 和 端口。 （user server2）</p>

<p>3、live server1 再请求 user server2</p>

<p>这样就完成一个服务的调用。</p>

<h1 id="四活跃检测">四、活跃检测</h1>

<p>服务发现机制，除了在微服务分布式系统中方便服务之间的调用后，还是功能就两个是活跃检测和负载均衡。</p>

<p>即服务管理平台会向注册的服务发送请求，确认服务是否可用，如果服务不可用或机器已挂机。即标记该 IP 不可用，或者直接摘机。</p>

<p>另一种方式是注册的服务定时的向服务管理平台发送确认的状态。告诉服务管理平台，自己还是活跃的。</p>

<p>当时发现服务不通时，可以进行摘机。即把IP从列表中移除掉。</p>

<p>所以，服务提供方一般都要求两个机器以上，这样可以起到容灾的作用。 要求高一点，可以要求机器在不同机房。当一个机房出问题时，另一个机器的服务可以支持着服务。</p>

<p><img src="/assets/system-design/service-discovery-2022-09-23_01-04-49.png" alt="" /></p>

<h1 id="五负载均衡">五、负载均衡</h1>

<p>服务请求时，提供方的服务是无状态的，会存在多个IP，我们只需求访问其中一个IP即可。 所以，服务管理平台同时也起了负载均衡的作用，只返回一个合适的IP。</p>

<p>当然，也有的策略是返回多个 IP， 让调用方自己去选择那个IP访问。</p>

<p>这里也导致一个问题，即所有请求都会预先请求服务管理平台。流量大的时侯会有瓶颈。解决的方案的是，请求到一个IP后，可以在本地缓存几秒钟，减少因流量峰值而带来服务管理平台的压力。</p>

<p><a href="http://blog.xyecho.com/load-balancing-and-reverse-proxy/">负载均衡策略：http://blog.xyecho.com/load-balancing-and-reverse-proxy/</a></p>

<h1 id="五服务发现技术点">五、服务发现技术点</h1>

<p>一套完整的服务发现平台，所需要的技术点：</p>

<p>1、 集群、分布式。 要应对大流量的服务，就一定要用到分布式集群。同时也起到容灾的作用。</p>

<p>2、强一致性、数据同步。由于分布式， 所以数据的一定要同步到每一台机器上，同时也要保证每一台机器的上的数据是一致的。</p>

<p>3、高并发、高可用。服务请求都要预先请求一次服务管理平台，所以流量会比较大。不能因为服务发现的加入而导致整体的性能下降太多。</p>

<p>4、部署管理简单。 简单的管理和好的体验，会让更多开发者去运用它。</p>

<h1 id="六开源的解决方案">六、开源的解决方案</h1>

<p>有资源的企业会基于源开放的解决方案上做一些二次开发，以适用于本企业的研发文化。 github 上也有一些比较靠谱的解决方案。如：
<code class="language-plaintext highlighter-rouge">etcd</code> 、<code class="language-plaintext highlighter-rouge">zookeeper</code> 、<code class="language-plaintext highlighter-rouge">consul</code> 等。都具有安全稳定，高可用，高并发。强一致性的特点。</p>

<p>1、<code class="language-plaintext highlighter-rouge">etcd</code>  : <a href="https://github.com/etcd-io/etcd">https://github.com/etcd-io/etcd</a></p>

<p>2、<code class="language-plaintext highlighter-rouge">zookeeper</code> : <a href="https://github.com/apache/zookeeper">https://github.com/apache/zookeeper</a></p>

<p>3、<code class="language-plaintext highlighter-rouge">consul</code> :<a href="https://github.com/hashicorp/consul">https://github.com/hashicorp/consul</a></p>

<hr />
<p>1、<a href="https://zhuanlan.zhihu.com/p/161277955">深入了解服务注册与发现 : https://zhuanlan.zhihu.com/p/161277955</a></p>

<p>2、<a href="https://zhuanlan.zhihu.com/p/409154290">服务注册与发现的原理和实现 : https://zhuanlan.zhihu.com/p/409154290</a></p>

]]></content:encoded>
    </item>
    
    <item>
      <title>系统设计方案注意事项</title>
      <link href="http://localhost:4000/server-system-design-idea/"/>
      <pubDate>2022-01-25T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/server-system-design-idea</guid>
      <content:encoded><![CDATA[<h1 id="一需求背景">一、需求背景</h1>

<p>1、 清晰掌握需求的各个场景，以业务为导向，检验技术和系统能否很好支持需求的各个场景。</p>

<p>2、了解需求背景，有助于从技术角度上看，需求是否存在漏洞</p>

<h1 id="二系统架构">二、系统架构</h1>

<p>1、画出清晰的高层框架图，主要体现出用什么组件，之间是怎么连接的，数据流向。</p>

<p>2、证明你的思路，用框架图进行推演，是否可以解决需求问题。</p>

<p>3、各个组件节点，是否存在关键点，是否有备用方案，即容错容灾。</p>

<p>4、 估算业务数据，并发，数据总量，系统是否可以满足。</p>

<h1 id="三关键业务流程图">三、关键业务流程图</h1>

<p>1、深入描述清楚关键组件节点的核心业务逻辑。</p>

<p>2、本地缓存防止热点出现。 本地缓存考虑空标情况。</p>

<p>3、处理外部接口异常情况。</p>

<p>4、防止流程出现阻塞情况。</p>

<p>5、关键接口，或读写缓存/db是否有重试机制。</p>

<p>6、业务或第三方接口是否考虑可重入。</p>

<p>7、关键数据一致性考虑。</p>

<p>8、关键流程是否存在并发，是否需要加锁。极端情况也不能忽略，觉得量少不可能会有并发情况，但极端情况果可以由其他bug导致的。</p>

<p>9、对外接口做频限保护。</p>

<p>10、核心业务流程记录流水。</p>

<h1 id="四业务">四、业务</h1>

<p>1、活动和时间相关的，注意零点和跨年的边界问题。</p>

<h1 id="五数据结构-mysql表设计redis缓存数据">五、数据结构  （mysql 表设计，redis 缓存数据）</h1>

<p>1、<code class="language-plaintext highlighter-rouge">mysql</code> 表设计是否合理，相关字段的索引；字段类型定义；是否有扩展字段；业务的数据总量是否考虑分表，用什么维度分表。</p>

<p>2、<code class="language-plaintext highlighter-rouge">mysql</code> <code class="language-plaintext highlighter-rouge">dao</code> 考虑连接数多少。防止对数据库压力过大，是否要加一层redis缓存。</p>

<p>3、<code class="language-plaintext highlighter-rouge">mysql</code> 优先考虑写主，读从。但也要防止主从同步的时间差可能导致业务逻辑的问题。</p>

<p>4、<code class="language-plaintext highlighter-rouge">mysql</code> sql 效率问题，如:  是否让索引失效，是否有必要连表，连表的是否表设计有问题。</p>

<p>5、<code class="language-plaintext highlighter-rouge">redis</code> 缓存是否存在热点， 是否存在大key， 是否考虑缓存空标，空标有效时间和正常的有效时间要区别出来。有效时间是否考虑打散，防止数据同时失效出现雪崩。</p>

<p>6、<code class="language-plaintext highlighter-rouge">redis</code> 数据结构设计注意版本号或扩展字段。反过来，在迭代新增扩展字段时，要考虑数据序列化问题，即版本号等问题。</p>

<h1 id="六协议">六、协议</h1>

<p>1、协议要简洁易懂，字段命名不要出现歧义，注释清楚。一定要有初始化，且初始化的值要合理。</p>

<p>2、协议要有对应的文档。文档说明清晰。文档要用 <code class="language-plaintext highlighter-rouge">source</code> 记录调用业务来源，预估请量，相关负责人。</p>

<p>3、请求协议要有source字段定义业务来源。</p>

<p>4、服务的协议要注意可扩展，新增字段要在mapExt中添加。</p>

<p>5、服务的协议初始化，序列化要对应正确。</p>

<p>6、响应协议要有错误码和错误信息。在文档要对错误码做出释义。</p>

<h1 id="七配置监控">七、配置监控</h1>

<p>1、对所有第三方接口要单独监控。</p>

<p>2、<code class="language-plaintext highlighter-rouge">dao</code> 操作要做单独监控。</p>

<p>3、<code class="language-plaintext highlighter-rouge">redis</code> 缓存/进程内缓存要监控命中率。</p>

<p>4、对外接口做全局监控。</p>

<p>5、<code class="language-plaintext highlighter-rouge">daemon</code> 也要做全局监控。</p>

<p>6、对外部参数的校验可以不做告警。</p>

<p>7、集中建立个性化视图，写清楚紧急联系人，方便快速找到对应的负责人。</p>

<p>8、接口调用来源做统计监控。</p>

<p>9、关键业务做出错告警。</p>

<p>10、 监控让服务有可观察性。</p>

<h1 id="八异常处理">八、异常处理</h1>

<p>1、考虑兜底方案，降级方案，补偿机制。</p>

<p>2、重试，告警。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>引流活动九宫格抽奖系统设计</title>
      <link href="http://localhost:4000/server-acitivity-ninebox/"/>
      <pubDate>2022-01-24T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/server-acitivity-ninebox</guid>
      <content:encoded><![CDATA[<h1 id="一-背景">一 背景</h1>

<p>在用户购买商品后，完成支付，可以一个抽奖活动。很多线上线下的都会搞类似这样的活动。这个位置是一个很好引流活动。可以把流量引向不同的业务。</p>

<p>如华为运动中的活动：</p>

<p><img src="/assets/system-design/server-activity-ninebox-2022-09-21_17-19-20.png" alt="" /></p>

<p>产品的业务逻辑：</p>

<p>1、九宫格中展示7个坑位的奖品，中间一个是抽奖按钮。第8个坑位是“谢谢参与”。</p>

<p>2、这是一个引流推广活动，所以业务逻辑上要求是奖品必中。之所以留一个坑位“谢谢参与”，是为兜底系统错误（如：网络问题）以避免客诉。</p>

<p>3、活动会接入不同业务线，以达到把流量导入到不同业务线的目的。</p>

<p>4、用户进入页面后，会根据不同的策略展示不同业务的奖品，最多7个奖品。</p>

<p>5、当用户点击“立即抽奖”后，根据不同奖品的不同权重，随机出抽中的奖品，发送领取落地页链接，用户在落地页点击领取。</p>

<p>6、奖品都是来不同的业务线。不存储本地。所以业务方一般要提供两个接口。 查询是可以发奖然后显示，中奖时通知业务方发奖。</p>

<p>如何把不同的业务的接入进来才是这个需求的难点。 不同的业务有不同类型的状态，如红包，试用券， 会员积分，  体验卡，  品牌会员等。</p>

<p>每个业务方都要提供一个查询奖励的接口和一个领奖品的接口。 奖励的数量和库存由对业务方自己决定。</p>

<p><strong>这种方式有好有坏：</strong></p>

<p>1）好处是：奖品的类型和库存可以由各个业务自己配置控制。 活动只是做一个中间路由，只是控制展示策略和命中权重，外加一个兜底奖品。</p>

<p>2）坏处是：过于发散，沟通成本太大，后期活动接入的业务越来越多，性能依赖各个业务的接口的性能。如遇大的调整，每个业务都回归测试一下。</p>

<p>其实，大部分奖品都是可以通知奖池来配置完成。 但这样子业务方无法自己把控奖品。同时也增加了我们运营， 九宫格活动不是京喜的业务，是京东的业务，所以人力成本也是一个原因。</p>

<h1 id="二服务框架">二、服务框架</h1>

<p>所用技术  <code class="language-plaintext highlighter-rouge">c++</code> ,<code class="language-plaintext highlighter-rouge">redis</code>, <code class="language-plaintext highlighter-rouge">http</code> 。</p>

<p>服务整体框架：</p>

<p><img src="/assets/system-design/server-activity-ninebox-2022-09-21_16-55-36.png" alt="" /></p>

<p>说明：</p>

<p>1、 活动通过 <code class="language-plaintext highlighter-rouge">http</code>  的方式提供服务。 两个接口： 一个是查询奖品（query），一个抽奖(draw)。</p>

<p>2、App client 是 京东App。收银台支付页完成后展示出来的是一个h5的页面。 App server是，京东App的服务端，跨团队，客户端没有直接接到我们这边的接口。</p>

<p>3、用户抽奖的相关数据用 <code class="language-plaintext highlighter-rouge">Redis</code> 存储。 中奖信息只保留7天。活动本身并不涉及奖品存储，都是通知业务方发放奖品的。奖品的历史查询是业务方自己的业务逻辑了。</p>

<p>4、业务上要求这个活动是必中活动。所以加入自己的奖池做为兜底。当有业务的奖品库存已经耗尽时，可以用到自己的奖品顶上去。</p>

<p>5、对于请求业务方的奖品，要先按策略选出7个业务的奖品，再通过并发调用接口，提高调用性能。这样，一次并发调用7个接口。</p>

<h2 id="21-展示奖品query">2.1  展示奖品（Query）</h2>

<p>主要逻辑流程图：</p>

<p><img src="/assets/system-design/server-activity-ninebox_2022-09-21_16-20-18.png" alt="" /></p>

<p>说明：</p>

<p>1、 关于奖品的展示策略通过配置中心定义，方便对于策略随时更新。所以服务一开始就要加载配置信息。</p>

<p>2、风险控制方面：１）要求登录，２）查询风控系统　３）判断是否重请求，防止被刷，同一个单多次刷新接口展示一点的奖品。</p>

<p>3、兜底逻辑，在筛选各个业务后如果出现不足七个奖品时，要用查询奖口列表做兜底，满足七个坑位。</p>

<p>4、比较极端的情况下，如果不足7个坑位的奖品，则要求前不展示活动。</p>

<h2 id="22-抽奖接口draw">2.2 抽奖接口（draw） </h2>

<p>主要逻辑流程图：</p>

<p><img src="/assets/system-design/server-activity-ninebox_2022-09-21_16-29-08.png" alt="" /></p>

<p>说明：</p>

<p>1、 抽奖时，要做登录检验，数据从redis中读出，保证数据的一致性。数据缓存redis有7天的时效，这个没有必要重新查询风控。因为写入reids的数据是在查询奖品时就写入的，查询奖品时就已经查询过风控了。</p>

<p> 2、 如果出现异常，返回“谢谢参与“，避免客诉。</p>

<p>3、抽奖后会记录在用户的历史记录中。防止用户重复刷新抽奖。</p>

<p>4、 加redis的乐观锁，防止快速刷时，被不同进程处理。</p>

<h1 id="三总结">三、总结</h1>

<p>这个活动需求最有挑战的，不是开发技术问题，而是沟通问题。随着活动的展开，业务的发展，要求接入的业务越来越多。一个业务的背后是一个不同的团队。沟通起来比较耗时，效率也比较低。 团队也是分散易地办公，很难要规范统一起来，沟通过程出现各种推诿。</p>

<p>当然活动可以做起更加通用一些。 查询接口和通知发奖接口按统一标准接入。可以有一个后台管理系统配置接入业务。配置完成生效后，就可以用。不用每一次新填业务都要去做开发。但做成通知性的难度不低，而且要各个业务方按九宫格的标准备开发接口。我们这边是省事了。他们很难受了。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>java 基本重点知识</title>
      <link href="http://localhost:4000/java-base-learn1/"/>
      <pubDate>2021-07-16T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/java-base-learn1</guid>
      <content:encoded><![CDATA[<p>解释虚拟机指令肯定会比全速运行机器指令慢很多。然而，虚拟机有一个选项，可以将执行最频繁的字节码序列翻译成机器码，这一过程被称为即时编译。</p>

<p>Java虚拟机还有一些其他的优点。它可以检测指令序列的行为，从而增强其安全性。</p>

<h2 id="java的特点">Java的特点</h2>

<ul>
  <li>可移植性</li>
  <li>解释型</li>
  <li>高性能</li>
  <li>多线程</li>
  <li>动态性</li>
</ul>

<h2 id="java-官方的一些源码和文档">Java 官方的一些源码和文档</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">javasrc</code> 在JDK的路径上，有一个src.zip，解开后，含了所有公共类库的源代码。</li>
  <li><code class="language-plaintext highlighter-rouge">javadoc</code>  可以从官网下载文档 https://www.oracle.com/java/technologies/javase-downloads。解压后，可以访问目录上的<code class="language-plaintext highlighter-rouge">jdk-16.0.2_doc-all\docs\index.html</code> 可以在浏览器打开，保存标签，这里可找到所有公共类库的说明。</li>
</ul>

<p><img src="../../assets/java/2021-07-26-java-learn-202449.png" alt="" /></p>

<ul>
  <li>编译器、虚拟机、本地方法以及私有辅助类 http://jdk.java.net/8/ 暂时不看吧。</li>
  <li>书籍代码学习 https://horstmann.com/corejava/ 可以下载。</li>
</ul>

<h2 id="java应用程序">Java应用程序</h2>

<p><strong>注释</strong></p>

<p>有三种注释方式， <code class="language-plaintext highlighter-rouge">//</code>     <code class="language-plaintext highlighter-rouge">/*  */</code>  第三种注释可以生成文档  <code class="language-plaintext highlighter-rouge">/** */</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1、todo </span>

<span class="cm">/* 2、comment */</span>

<span class="cm">/**
* 3、This is a doc comment
*/</span>
</code></pre></div></div>

<h2 id="数据类型">数据类型</h2>

<p>Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型， 8种基本类型。</p>

<p><code class="language-plaintext highlighter-rouge">big number </code> 大数，是一种对象，不是类型。</p>

<p>8种基本类型</p>

<p>整型 <code class="language-plaintext highlighter-rouge">int</code>  4个字节</p>

<p>整型 <code class="language-plaintext highlighter-rouge">short</code> 2个字节</p>

<p>整型 <code class="language-plaintext highlighter-rouge">long</code> 8个字节</p>

<p>整型 <code class="language-plaintext highlighter-rouge">byte</code> 1字节</p>

<p>长整型数值有一个后缀L或l（如4000000000L）。 从Java 7开始，加上前缀0b或0B就可以写二进制数。</p>

<p>浮点型 <code class="language-plaintext highlighter-rouge">float</code> 4个字节</p>

<p>浮点型 <code class="language-plaintext highlighter-rouge">double</code> 8个字节</p>

<p>float类型的数值有一个后缀F或f（例如，3.14F）。没有后缀F的浮点数值（如3.14）默认为double类型。当然，也可以在浮点数值后面添加后缀D或d（例如，3.14D）。</p>

<p>三个特殊的值。</p>

<p>正无穷大  <code class="language-plaintext highlighter-rouge">Double.POSITIVE_INFINITY</code></p>

<p>负无穷大 <code class="language-plaintext highlighter-rouge">Double.NEGATIVE_INFINITY</code></p>

<p>NaN （不是一个数字） <code class="language-plaintext highlighter-rouge">Double.NaN</code></p>

<p>不能这样检测一个特定值是否等于Double.NaN：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">==</span> <span class="nc">Double</span><span class="o">.</span><span class="na">NaN</span><span class="o">)</span> <span class="c1">// is ture </span>
   
<span class="k">if</span> <span class="o">(</span><span class="nc">Double</span><span class="o">.</span><span class="na">isNaN</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="c1">// check x is "not a number"</span>
</code></pre></div></div>

<p>char类型 单个字符， 字面量值要用单引号括起来。<code class="language-plaintext highlighter-rouge">'A'</code>  , <code class="language-plaintext highlighter-rouge">"A"</code> 是一个字符串。可以表示为十六进制值。其范围从<code class="language-plaintext highlighter-rouge">\u0000</code>到<code class="language-plaintext highlighter-rouge">\Uffff</code>。除了转义序列<code class="language-plaintext highlighter-rouge">\u</code>之外，还有一些用于表示特殊字符的转义序列</p>

<p>Unicode类型 另讲。</p>

<p>boolean类型。有两个值：false和true，用来判定逻辑条件。<strong>整型值和布尔值之间不能进行相互转换，这一点要注意和C++不一样</strong>。</p>

<p><strong>枚举类型</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="nc">Size</span><span class="o">{</span><span class="no">SMALL</span><span class="o">,</span> <span class="no">MEDIUM</span><span class="o">,</span> <span class="no">LARGE</span><span class="o">,</span> <span class="no">EXTRA_LARGE</span><span class="o">}</span> <span class="o">;</span> 
</code></pre></div></div>

<h2 id="变量">变量</h2>

<p>在Java中，每个变量都有一个类型（type）。在声明变量时，变量的类型位于变量名之前。 每个声明以分号结束。</p>

<p>变量名必须是一个以字母开头并由字母或数字构成的序列。</p>

<p>不能使用Java保留字作为变量名。</p>

<p>变量名对大小写敏感。</p>

<p>声明一个变量之后，必须用赋值语句对变量进行<strong>显式初始化</strong>。</p>

<p>利用关键字final指示常量。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kt">double</span> <span class="no">CM_PER_INCH</span> <span class="o">=</span> <span class="mf">2.54</span><span class="o">;</span> 
</code></pre></div></div>

<p>类常量的定义位于main方法的外部。</p>

<p><code class="language-plaintext highlighter-rouge">const</code>是 Java 保留的关键字，但目前并没有使用。在Java中，必须使用final定义常量。</p>

<h2 id="运算符">运算符</h2>

<p>在Java中，使用算术运算符<code class="language-plaintext highlighter-rouge">+、-、*、/</code>表示加、减、乘、除运算。</p>

<p>整数的求余操作（有时称为取模）用<code class="language-plaintext highlighter-rouge">%</code>s表示.</p>

<p><strong>数值类型之间的转换</strong></p>

<p>数值类型之间的合法转换.。 6个实心箭头，表示无信息丢失的转换；有3个虚箭头，表示可能有精度损失的转换。</p>

<p><img src="../../assets/java/2021-07-26-java-learn-2024459.png" alt="" /></p>

<p><strong>强制类型转换</strong></p>

<p>可能会丢失一些信息。如</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">9.997</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">x</span><span class="o">;</span> 
</code></pre></div></div>

<p>变量 <code class="language-plaintext highlighter-rouge">nx = 9</code> 小数被截断掉，如果四舍五入用</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">9.997</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="nc">Math</span><span class="o">.</span><span class="na">round</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
</code></pre></div></div>

<p>round方法返回的结果为long类型。所以最后要<code class="language-plaintext highlighter-rouge">（int）</code>转换一下。</p>

<p><strong>结合赋值和运算符</strong></p>

<p>和c++ 一样， <code class="language-plaintext highlighter-rouge">+=</code> 等操作。如：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">+=</span> <span class="mi">4</span><span class="o">;</span> 
</code></pre></div></div>

<p><strong>自增与自减运算符</strong></p>

<p>和c++一样。 如 <code class="language-plaintext highlighter-rouge">x++</code> 、<code class="language-plaintext highlighter-rouge">x--</code> 、<code class="language-plaintext highlighter-rouge">++n</code>、 <code class="language-plaintext highlighter-rouge">--n</code> 。 <code class="language-plaintext highlighter-rouge">++</code>在前在后有区别， 用在表达式中时，前缀形式会先完成加1；而后缀形式会使用变量原来的值。</p>

<p><strong>关系和boolean运算符</strong></p>

<p>基本都沿用了C++的做法。</p>

<p><code class="language-plaintext highlighter-rouge">&amp;&amp;</code>和<code class="language-plaintext highlighter-rouge">||</code>运算符是按照“短路”方式来求值的：如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。</p>

<p>同样支持三元操作符<code class="language-plaintext highlighter-rouge">？:</code></p>

<p>boolean 类型不要做转换。</p>

<h2 id="位运算符">位运算符</h2>

<table>
  <tbody>
    <tr>
      <td>应用在布尔值上时，&amp;和</td>
      <td>运算符也会得到一个布尔值。这些运算符与&amp;&amp;和</td>
      <td> </td>
      <td>运算符很类似，不过&amp;和</td>
      <td>运算符不采用“短路”方式来求值，也就是说，得到计算结果之前两个操作数都需要计算。</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">&gt;&gt;</code>和<code class="language-plaintext highlighter-rouge">&lt;&lt;</code>运算符将位模式左移或右移</p>

<p>有一个新知识：** <code class="language-plaintext highlighter-rouge">&gt;&gt;&gt;</code>运算符会用0填充高位，这与»不同，它会用符号位填充高位。不存在«&lt;运算符。**</p>

<p><strong>括号与运算符级别</strong></p>

<p>与C或C++不同，Java不使用逗号运算符。不过，可以在for语句的第1和第3部分中使用逗号分隔表达式列表。</p>

<h2 id="字符串">字符串</h2>

<p>标准Java类库中提供了一个预定义类，很自然地叫做String。每个用双引号括起来的字符串都是String类的一个实例。</p>

<p>String类的substring方法可以从一个较大的字符串提取出一个子串。</p>

<p>substring的工作方式有一个优点：容易计算子串的长度。字符串s.substring(a, b)的长度为b-a。例如，子串“Hel”的长度为3-0=3。</p>

<p>使用+号连接（拼接）两个字符串。 后面可以是int型。</p>

<p>把多个字符串放在一起，用一个定界符分隔，可以使用静态join方法。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">all</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">" /"</span><span class="o">,</span> <span class="s">"S"</span><span class="o">,</span> <span class="s">"M"</span><span class="o">,</span> <span class="s">"L"</span><span class="o">,</span> <span class="s">"XL"</span><span class="o">);</span> 
<span class="c1">// all is the string  "S / M / L / XL"</span>
</code></pre></div></div>

<p>String类没有提供用于修改字符串的方法。要从原字符串中获取后，重新组成，然后再覆盖回原来的字符串。</p>

<p>不可变字符串却有一个优点：编译器可以让字符串共享</p>

<p>字符串存放在公共的存储池中。字符串变量指向存储池中相应的位置。如果复制一个字符串变量，原始字符串与复制的字符串共享相同的字符。</p>

<p>使用equals方法检测两个字符串是否相等。如果字符串s与字符串t相等，则返回true；否则，返回false。需要注意，s与t可以是字符串变量，也可以是字符串字面。</p>

<p>要想检测两个字符串是否相等，而不区分大小写，可以使用<code class="language-plaintext highlighter-rouge">equalsIgnoreCase</code>方法。</p>

<p>一定不要使用==运算符检测两个字符串是否相等！这个运算符只能够确定两个字符串是否放置在同一个位置上。</p>

<p><strong>空串与Null串</strong></p>

<p>空串”“是长度为0的字符串。可以调用以下代码检查一个字符串是否为空。 空串是一个Java对象，有自己的串长度（0）和内容（空）。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">str</span><span class="o">,</span><span class="n">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
    <span class="c1">// empty string</span>
<span class="o">}</span>

<span class="k">if</span> <span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">""</span><span class="o">)){</span>
    <span class="c1">// empty string</span>
<span class="o">}</span>
</code></pre></div></div>

<p>String变量还可以存放一个特殊的值，名为null，这表示目前没有任何对象与该变量关联。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">str</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
	<span class="c1">// string is null </span>
<span class="o">}</span>
</code></pre></div></div>

<p>检查一个字符串既不是null也不为空串，这种情况下就需要使用以下条件：<strong>首先要检查str不为null</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">str</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
    <span class="c1">// string is not null or empty</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>码点与代码单元</strong></p>

<p>Java字符串由char值序列组成。char数据类型是一个采用UTF-16编码表示Unicode码点的代码单元。大多数的常用Unicode字符使用一个代码单元就可以表示，而辅助字符需要一对代码单元表示。</p>

<p><strong>构建字符串</strong></p>

<p>有些时候，需要由较短的字符串构建字符串，例如，按键或来自文件中的单词。采用字符串连接的方式达到此目的效率比较低。每次连接字符串，都会构建一个新的String对象，既耗时，又浪费空间。使用<strong>StringBuilder</strong>类就可以避免这个问题的发生。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">StringBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span> 

<span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span> <span class="c1">// appends a single character </span>
<span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">str</span><span class="o">)</span> <span class="c1">// appends a string </span>
    
<span class="nc">String</span> <span class="n">completeString</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span> 
</code></pre></div></div>

<h2 id="格式化输出">格式化输出</h2>

<p>使用<code class="language-plaintext highlighter-rouge">System.out.print(x)</code>将数值x输出到控制台上。和C语言中的方法一样的。 <code class="language-plaintext highlighter-rouge">printf</code>和C语言一样。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%8.2f"</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>  <span class="c1">//  same to c printf </span>
</code></pre></div></div>

<p>可以使用静态的String.format方法创建一个格式化的字符串，而不打印输出：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"Hello, %s. Next year, you'll be %d"</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">);</span> 
</code></pre></div></div>

<p><strong>文件输入与输出</strong></p>

<p>对文件进行读取，就需要一个用File对象构造一个Scanner对象。如下所示：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Scanner</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"myfile.txt"</span><span class="o">),</span> <span class="s">"UTF-8"</span><span class="o">);</span> 
</code></pre></div></div>

<p>要想写入文件，就需要构造一个PrintWriter对象。在构造器中，只需要提供文件名：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">PrintWriter</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintWriter</span><span class="o">(</span><span class="s">"myfile.txt"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span> 
</code></pre></div></div>

<h2 id="控制流程">控制流程</h2>

<p>Java的控制流程结构与C和C++的控制流程结构一样，只有很少的例外情况。没有goto语句，但break语句可以带标签。 foreach循环。</p>

<h3 id="块作用域">块作用域</h3>

<p>块（即复合语句）是指由一对大括号括起来的若干条简单的Java语句。块确定了变量的作用域。</p>

<p>不能在嵌套的两个块中声明同名的变量。例如</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
<span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">;</span> 
    <span class="c1">// ...</span>
    <span class="o">{</span>
        <span class="kt">int</span> <span class="n">k</span><span class="o">;</span> 
        <span class="kt">int</span> <span class="n">n</span><span class="o">;</span> <span class="c1">// Error  can't redefine n in inner block</span>
        <span class="c1">// ... </span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="条件语句">条件语句</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">condition</span><span class="o">){</span>
    <span class="n">statement</span> 
<span class="o">}</span><span class="k">else</span> <span class="o">{</span>
    <span class="n">statement</span> 
<span class="o">}</span>
</code></pre></div></div>

<h3 id="循环">循环</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="o">(</span><span class="n">condition</span><span class="o">){</span>
    <span class="n">statement</span> 
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="o">{</span>
    <span class="n">statement</span> 
<span class="o">}</span><span class="k">while</span><span class="o">(</span><span class="n">condition</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span> 
<span class="o">}</span>
</code></pre></div></div>
<h2 id="foreach循环">foreach循环</h2>

<p>Java有一种功能很强的循环结构，可以用来依次处理数组中的每个元素（其他类型的元素集合亦可）而不必为指定下标值而分心.。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="n">variable</span> <span class="o">:</span> <span class="n">collection</span><span class="o">){</span>
    <span class="n">statement</span> 
<span class="o">}</span>
</code></pre></div></div>

<h2 id="多重选择switch语句">多重选择：switch语句</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">choice</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span> 
<span class="k">switch</span><span class="o">(</span><span class="n">choice</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> 
        <span class="c1">// ...</span>
        <span class="k">break</span><span class="o">;</span> 
    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> 
        <span class="c1">// ...</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="k">default</span><span class="o">:</span> 
        <span class="c1">// bad input </span>
        <span class="k">break</span><span class="o">;</span> 
<span class="o">}</span>
</code></pre></div></div>

<h2 id="中断控制流程语句">中断控制流程语句</h2>

<p>break , goto ，continue 等。</p>

<p>与C++不同，Java还提供了一种带标签的break语句，用于跳出多重嵌套的循环语句。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">test</span><span class="o">()</span>
<span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">;</span> 
    <span class="nl">read_data:</span>
    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
        <span class="c1">// ...</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"enter anumber &gt;=0:"</span><span class="o">);</span> 
            <span class="n">n</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span> 
            <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">){</span> <span class="c1">// should never  happend-can't go to </span>
                <span class="k">break</span> <span class="n">read_data</span><span class="o">;</span> <span class="c1">// break out fo read_data loop </span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="大数值">大数值</h2>

<p>如果基本的整数和浮点数精度不能够满足需求，那么可以使用<code class="language-plaintext highlighter-rouge">java.math</code>包中的两个很有用的类：<code class="language-plaintext highlighter-rouge">BigInteger</code>  和 <code class="language-plaintext highlighter-rouge">BigDecimal</code>。</p>

<p>这两个类可以处理包含任意长度数字序列的数值。<code class="language-plaintext highlighter-rouge">BigInteger</code>类实现了任意精度的整数运算，<code class="language-plaintext highlighter-rouge">BigDecimal</code>实现了任意精度的浮点数运算。</p>

<p>使用静态的valueOf方法可以将普通的数值转换为大数值：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BigInteger</span> <span class="n">a</span> <span class="o">=</span> <span class="nc">BigInteger</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span> 
<span class="nc">BigInteger</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">b</span><span class="o">);</span> <span class="c1">// c = a+b</span>
<span class="nc">BigInteger</span> <span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">multiply</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">BigInteger</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">2</span><span class="o">)))</span><span class="c1">// d = c * (b+2)</span>
</code></pre></div></div>

<h3 id="数组">数组</h3>

<p>数组是一种数据结构，用来存储同一类型值的集合。通过一个整型下标可以访问数组中的每一个值。</p>

<p>声明了整型数组a：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">;</span>  <span class="c1">// 声明变更a  或 int a[]</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">100</span><span class="o">]</span> <span class="o">;</span> 
</code></pre></div></div>

<p>有个更加简单的方式打印数组中的所有值，即利用Arrays类的toString方法。调用Arrays.toString(a)，返回一个包含数组元素的字符串，这些元素被放置在括号内，并用逗号分隔，例如，“[2,3,5,7,11,13]”。要想打印数组，可以调用:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">,</span><span class="n">toString</span><span class="o">(</span><span class="n">a</span><span class="o">));</span> 
</code></pre></div></div>

<p><strong>数组初始化以及匿名数组</strong></p>

<p>提供了一种创建数组对象并同时赋予初始值的简化书写形式</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">smallPrimes</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">13</span><span class="o">};</span> 
</code></pre></div></div>

<p>不需要调用 new。</p>

<p>初始化一个匿名的数组：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">13</span><span class="o">};</span> 

<span class="n">smallPrimes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">13</span><span class="o">};</span> 
</code></pre></div></div>

<p><strong>数组拷贝</strong></p>

<p>在Java中，允许将一个数组变量拷贝给另一个数组变量。这时，两个变量将引用同一个数组.。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">[]</span> <span class="n">luckyNumbers</span> <span class="o">=</span> <span class="n">smallPrimes</span><span class="o">;</span> 
<span class="n">luckyNumbers</span><span class="o">[</span><span class="mi">5</span><span class="o">]</span> <span class="o">=</span> <span class="mi">12</span><span class="o">;</span> <span class="c1">// noew smallPrimes[5] is also 12 </span>
</code></pre></div></div>

<p>如果希望将一个数组的所有值拷贝到一个新的数组中去，就要使用Arrays类的<code class="language-plaintext highlighter-rouge">copyOf</code>方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">copiedLickyNumbers</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">luckyNumbers</span><span class="o">,</span> <span class="n">lickyNumbers</span><span class="o">.</span><span class="na">length</span><span class="o">);</span> 
</code></pre></div></div>

<p>第2个参数是新数组的长度。这个方法通常用来增加数组的大小：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">copiedLickyNumbers</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">luckyNumbers</span><span class="o">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">lickyNumbers</span><span class="o">.</span><span class="na">length</span><span class="o">);</span> 
</code></pre></div></div>

<p>Java数组与C++数组在堆栈上有很大不同，但基本上与<strong>分配在堆（heap）</strong>上的数组指针一样。</p>

<h2 id="命令行参数">命令行参数</h2>

<p>每一个Java应用程序都有一个带Stringarg[]参数的main方法。这个参数表明main方法将接收一个字符串数组，也就是命令行参数。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> 
<span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> 
    <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">arg</span> <span class="o">:</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="s">"-version"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"v10000.0"</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

]]></content:encoded>
    </item>
    
    <item>
      <title>java 技术栈学习脉络</title>
      <link href="http://localhost:4000/java-learn-map/"/>
      <pubDate>2021-07-16T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/java-learn-map</guid>
      <content:encoded><![CDATA[<p>继续整理更新中~</p>

<h3 id="一-java基础">一、 java基础</h3>

<ol>
  <li>Linux常用命令</li>
  <li>Shell 脚本编程</li>
  <li>数据结构</li>
  <li>算法</li>
  <li>集合</li>
  <li>IO/NIO</li>
  <li>并发编程
    <ul>
      <li>并发基石线程基础</li>
      <li>synchronized</li>
      <li>JUC</li>
    </ul>
  </li>
  <li>JVM</li>
  <li>JDBC 连接池</li>
  <li>编码规范</li>
</ol>

<h3 id="二jave-web-略过">二、jave web 略过</h3>

<p>JSP、Servlet 、Html、CSS、JavaScript、JQuery、Tomcat</p>

<h3 id="三-重构设计">三 重构设计</h3>

<p>设计原则</p>

<ol>
  <li>开闭原则总则</li>
  <li>依赖倒置原则</li>
  <li>接口隔离原则</li>
  <li>单一职责原则</li>
  <li>里氏替换原则</li>
  <li>最少知道原则</li>
  <li>合成复用原则</li>
</ol>

<p>常用设计模式</p>

<ul>
  <li>创建型模式
    <ul>
      <li>单例模式</li>
      <li>工厂模式</li>
    </ul>
  </li>
  <li>结构型模式
    <ul>
      <li>代理模式</li>
      <li>装饰模式</li>
      <li>适配器模式</li>
    </ul>
  </li>
  <li>行为型模式
    <ul>
      <li>策略模式</li>
      <li>命令模式</li>
      <li>责任链模式</li>
      <li>观察者模式</li>
      <li>模板方法模式</li>
    </ul>
  </li>
</ul>

<p>重构-改善既有代码的设计</p>

<h3 id="三开源框架-重点">三、开源框架 （重点）</h3>

<ol>
  <li>NET 框架 
​    - Netty 
​    - HttpClient 
​    - Mina</li>
  <li>MVC框架
    <ul>
      <li>Sping</li>
      <li>Structs</li>
    </ul>
  </li>
  <li>ORM 框架
    <ul>
      <li>MyBatis</li>
      <li>Hibernate</li>
    </ul>
  </li>
  <li>RPC 框架
    <ul>
      <li>Dubbo</li>
      <li>springCloud</li>
      <li>Thrift</li>
    </ul>
  </li>
  <li>模板引擎
    <ul>
      <li>Velocity</li>
      <li>Freemarker</li>
    </ul>
  </li>
</ol>

<h3 id="四数据存储">四、数据存储</h3>

<ol>
  <li>SQL数据库
    <ul>
      <li>MySQL</li>
      <li>Oracle</li>
      <li>DB2</li>
      <li>分库分表 
ShardingSphere 
MyCat 
TDDL</li>
    </ul>
  </li>
  <li>NoSQL
    <ul>
      <li>Redis</li>
      <li>Hbase</li>
      <li>MongoDB</li>
    </ul>
  </li>
</ol>

<h3 id="五测试技能">五、测试技能</h3>

<ol>
  <li>单元测试MockSpringTest</li>
  <li>压力测试 JMeter</li>
</ol>

<h3 id="六中间件">六、中间件</h3>

<ol>
  <li>Redis</li>
  <li>RocketMQ</li>
  <li>Zookerper</li>
  <li>elasticStack</li>
  <li>etcd</li>
  <li>kafka</li>
  <li>memcashed</li>
</ol>

<h3 id="七性能优化">七、性能优化</h3>

<ol>
  <li>web 前端性能优化 （略过）</li>
  <li>应用服务性能优化
    <ul>
      <li>集群</li>
      <li>缓存</li>
      <li>异步</li>
      <li>代码
        <ul>
          <li>并发</li>
          <li>编程</li>
          <li>资源得胜</li>
          <li>数据结构</li>
        </ul>
      </li>
      <li>JVM</li>
    </ul>
  </li>
  <li>数据存取性能优化
    <ul>
      <li>SQL优化</li>
      <li>索引优化</li>
      <li>数据库架构 + 分库分表</li>
    </ul>
  </li>
</ol>

<h3 id="八架构技能">八、架构技能</h3>

<ol>
  <li>分布式架构
    <ul>
      <li>keepalive + nginx/lvs</li>
      <li>Zooperper</li>
      <li>RPC
        <ul>
          <li>Dubbo</li>
          <li>SpringCloud</li>
        </ul>
      </li>
      <li>服务治理
        <ul>
          <li>服务熔断</li>
          <li>服务降级</li>
          <li>服务限流</li>
          <li>服务隔离</li>
        </ul>
      </li>
      <li>MQ
        <ul>
          <li>RockerMQ</li>
          <li>kafka</li>
        </ul>
      </li>
      <li>缓存
        <ul>
          <li>redis</li>
          <li>memchached</li>
        </ul>
      </li>
      <li>分布数据一致性</li>
      <li>微服务架构</li>
      <li>Docker</li>
      <li>数据库架构
        <ul>
          <li>主备架构</li>
          <li>主从架构</li>
          <li>双主架构 （什么场景会有这个？）</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h3 id="九大数据">九、大数据</h3>

<ol>
  <li>数据收集
    <ul>
      <li>网络爬虫</li>
      <li>Flume/Logstash</li>
    </ul>
  </li>
  <li>数据存储
    <ul>
      <li>HDFSHive (这个算是存储吗？)</li>
      <li>Hbase</li>
      <li>MongoDB</li>
    </ul>
  </li>
  <li>数据检索
    <ul>
      <li>Elasticsearch</li>
    </ul>
  </li>
  <li>数据处理
    <ul>
      <li>Hive</li>
      <li>Storm</li>
      <li>ParkFlink</li>
    </ul>
  </li>
  <li>数据挖掘
    <ul>
      <li>机器学习</li>
    </ul>
  </li>
</ol>

<h3 id="十解决方案">十、解决方案</h3>

<ol>
  <li>技术实践方案</li>
  <li>业务实现方案</li>
</ol>

<h3 id="十一其他技能">十一、其他技能</h3>

<ol>
  <li>开发工具
    <ul>
      <li>Intellij</li>
      <li>IDEA</li>
      <li>Eclipse</li>
    </ul>
  </li>
  <li>项目构建
    <ul>
      <li>MavenGradle</li>
    </ul>
  </li>
  <li>版本控制
    <ul>
      <li>Git</li>
      <li>SVN</li>
    </ul>
  </li>
</ol>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
