<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>xyecho</title>
    <link href="http://localhost:4000/feed/" rel="self" />
    <link href="http://localhost:4000" />
    <lastBuildDate>2022-09-21T20:50:58+08:00</lastBuildDate>
    <webMaster>1447675994@qq.com</webMaster>
    
    <item>
      <title>《麦肯锡结构化战略思维》by 周国元</title>
      <link href="http://localhost:4000/%E9%BA%A6%E8%82%AF%E9%94%A1%E7%BB%93%E6%9E%84%E5%8C%96%E6%88%98%E7%95%A5%E6%80%9D%E7%BB%B4/"/>
      <pubDate>2022-05-28T19:13:00+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/麦肯锡结构化战略思维</guid>
      <content:encoded><![CDATA[<p>近些年，职场上发现，非技术的能力成了发展的短板。如良好的沟通，系统的思考。内心抗拒和陌生人接触。这个性格就是技术型的。</p>

<p>领导介绍了这本书《麦肯锡结构化战略思维》，感觉不错，在职场迷茫不知道怎么做个好人的可以看一下。</p>

<p>主要讲的是：对于一个新问题，新领域，用什么的原则和方法去切入，自上而下，有自己的洞见，用数据和逻辑讲故事，最后做出一个漂亮的交付。</p>

<p>事后也对思辨者做一些总结，形成习惯，方便以后可持续的输出。</p>

<p>它更像是一些职场的方法论。当然也可延生到生活，学习的等场景。</p>

<p><img src="/assets/reading/reading-book-jghsw20220528.jpeg" alt="" /></p>

<p>书主要从 <strong>原则、方法、习惯</strong> 三方面介绍。</p>

<h2 id="原则">原则</h2>
<hr />

<p>结构化思考的过程，我们要定一些原则，以免在这个过程中掉到坑里。</p>

<p>1、数字</p>

<p>当我们看到数据时，第一反应是质疑。是数据是否有问题。第二个反应是，这数据是否可以推出来这样的结论。</p>

<p>另外， 数据一定是和逻辑在一起的，有数据，没有逻辑是死数据，无用的。</p>

<p>如果数据都没有问题，数据中却出现特例，那可能就是问题所在了。 数据的异常点可能就是背后的支撑逻辑有问题。</p>

<p>数据只能说明过去的，而我们追求的时未来，价值在未来。</p>

<p>2、洞见</p>

<p>从数据加逻辑，我们可能得到信息，从信息中，我提炼出洞见。 洞见就是我们要所要的结果。</p>

<p>洞见的来源：</p>

<p>数据的替身和数据趋势， 数据背后的实体是什么，将走向何处，提炼出来就是洞见。</p>

<p>数据的异常点，极端点，以及其他合理背后的逻辑，就是洞见。</p>

<p>数据对比的结果，差异就是洞见。</p>

<p>数据周边的相关信息，也可以是洞见。</p>

<p>以后，所有的推化和提炼都可以成洞见。</p>

<p>3、MECE 原则</p>

<p>MECE原则，就是一种切问题的方法。 或者说分拆问题的原则。</p>

<ul>
  <li>子分类相互独立无重叠</li>
  <li>子分类加起来穷尽全部可能</li>
</ul>

<p>这个两个原则，我的理解是子问题要解藕，方便独立解决。</p>

<p>4、 假设</p>

<p>个人觉得假设很重要。假设是探讨问题的一个开始。<strong>假设，论证，再假设，再论证。</strong> 几个轮回之后，很多背后的逻辑也浮出了水面。</p>

<p>过程不介绍探讨假设。很多人不喜欢假设。一开口就是说“你别给我假设”，“这只是你的假设”。可能太急燥了，就想一开始就能切中问题所在吧。</p>

<h2 id="方法">方法</h2>
<hr />

<p>把一个问题搞懂的方法论，就是如下图这个步骤了。</p>

<p><img src="/assets/reading/reading-book-jghsw2022-05-28_14-16-01.png" alt="" /></p>

<h3 id="定义问题">定义问题</h3>

<p>1、之所以要重新定义问题，因为我们拿到手的问题，可能是个假问题。所以第一步要确认问题的正确性。</p>

<p>2、 所以用一些手段，即定义问题的工具：</p>

<ul>
  <li>问题的背景，从全局的角度看待这个问题。</li>
  <li>问题的边界，解决问题约束。即，问题的不能无限扩大，解决的资源不是无限的。</li>
  <li>解决问题的标准是什么，即达到什么程度，这个问题才算解决。</li>
  <li>问题的相关人，责任人。</li>
</ul>

<p>书上写的工具不只四个，但我觉得有一些可以合并。这几项，大概就可以把问题圈定在一定的范围内。我们目标也明确了。后面的假设不会超过这个范围遨游太虚去了。</p>

<p>3、MECE 原则</p>

<p>如上面已讲，这个原则就是切问题的，把问题拆分成子问题。</p>

<p>4、多维图谱</p>

<p>可以用思维导图呈现你的思考过程，当有你很多假设、验证过程时会更加清晰的呈现出思考对错。</p>

<h3 id="结构化分析">结构化分析</h3>

<p>结构化分析和切问题估计应该就是本书的核心章节了，如下图，就是结构化思维最基本的主流程了。其实前面的所有步骤做之后，就已经进入分析状态了。</p>

<p><img src="/assets/reading/reading-book-jghsw2022-05-28_14-52-53.png" alt="" /></p>

<h4 id="1切问题">1、切问题</h4>

<p>个人觉得切问题，怎么样切，要看个人的能力，对所在领域的业务能力。如果你什么都不了解，不清楚。想切也无从下手。所以，结构化分化要有领域专业基础能力做支撑。</p>

<p>书中讲的只一些通用方法，具体问题还要具体分析。</p>

<ul>
  <li>公式法</li>
  <li>子目录列举法</li>
  <li>流程法</li>
  <li>逻辑框架法</li>
</ul>

<h4 id="2逻辑思维">2、逻辑思维</h4>

<p>这个已经上升到逻辑学层面了，可能算是基本法则了。但因果性和相关性可能是很多容易犯的错而不自知。</p>

<ul>
  <li>归纳法（自下而上）</li>
  <li>演绎法（自上而下）</li>
  <li>因果性和相关性</li>
</ul>

<h4 id="3提出假设">3、提出假设</h4>

<p>切出子问题之后，对子问题的解决，就是多次假设，多次验证。 假设也不是天马行空的，上面在问题的准备时已经就做限制。 提出假设的方法主要有：</p>

<ul>
  <li>假设清单。 所有的过程都不应该外露，这个假设清单也是，很多会被证伪。</li>
  <li>头脑风暴。 提出有差异、平等、发散的各种意见。</li>
  <li>杜绝专家过早参与。专家过早参与，有可能被画地为牢。专家应该在验证过程会更好。</li>
</ul>

<h4 id="4验证假设">4、验证假设</h4>

<p>验证假设应该是整个过程最花精力的地方了。主要通过调研和访谈两方面。</p>

<p>调研的分类有：</p>

<ul>
  <li>案头调研。收集相关的资料，当然是越多越好。但这只是第一步，很多人只做到这一步。</li>
  <li>实地调研。 案头调研之后，再深入的就是实地调研。如投资，不单要看财报，要市场做调研。</li>
</ul>

<p>人个觉得调研的技巧，可以专门找书籍来学习。 调研技巧：</p>

<ul>
  <li>商业敏感度</li>
  <li>表达沟通能力</li>
  <li>自驱力</li>
  <li>情商、同理心</li>
  <li>数据字分析技能</li>
</ul>

<p>访谈就是沟通，如何很好的沟通，是一门很能难的学问，也是不被看重的能力。 也因当专门学习。</p>

<p>访谈技巧：</p>

<ul>
  <li>对被访者的尊重，注意情绪的波动</li>
  <li>聆听后的提炼，重述</li>
  <li>对话要输入新的增值信息</li>
  <li>以结果为导向的访谈态度</li>
  <li>培养建立长期信任关系</li>
  <li>保护好被访问者</li>
</ul>

<h4 id="5交付">5、交付</h4>

<p>切问题是这个过程中最核心的技术，验证是最花精力的过程，那么交付就是最重要的结果了。</p>

<p>前面的所有努力都在这里呈现，如果呈现不出了，估计别人觉得你什么都没做了。</p>

<p>交付分为三个阶段： 交付前，交付时，交付后。</p>

<p>交付后， 是我个人加进去了。 因为真的交付后，还有很多事情可以做的，如总结，复盘，优化以后的流程，分享等。</p>

<p>交付前：</p>

<ul>
  <li>只有充分的准备，没有过度的准备。</li>
  <li>对自己的心理建设。</li>
</ul>

<p>交付时：</p>

<ul>
  <li>商务沟通：讲故事</li>
  <li>沟通是双向，多向的</li>
  <li>沟通是多层面的， 信息，洞见，个性化，情绪，情感</li>
  <li>沟通多形式</li>
  <li>沟通的外部影响</li>
  <li>沟通的3S 原则</li>
  <li>沟通的金字塔原则</li>
</ul>

<p>自己总结一点，平时，可以用电机叙述的方式用5W2H分析法把事情讲清楚。</p>

<h2 id="习惯">习惯</h2>
<hr />

<p>最后，对于一个结构化思辨者，我们应该养成什么样的习惯呢？</p>

<ul>
  <li>反对的责任</li>
  <li>解决正确的问题</li>
  <li>下一层面的细节</li>
  <li>总结提炼， 电梯陈述，讲清5W2H</li>
  <li>第一天的答案， 可以快速理清框架，出思路，可以过掉细节</li>
  <li>问正确的问题</li>
  <li>认为还是知道</li>
  <li>移动时间轴</li>
  <li>数据和逻辑</li>
  <li>知道边界</li>
</ul>

<p>如果， 只能记住三点，那么我会选择：</p>

<p>1、质疑数据，数据一定要有逻辑。</p>

<p>2、正确的问题</p>

<p>3、总结提炼， 电梯陈述，讲清5W2H</p>

<h2 id="总结">总结</h2>
<hr />

<p>像《查理穷宝典》中芒格说的，我们要一些思维模型，用这一些工具来对世界上的事物进行思考。 学习的过程就是不断的建议自己的思维模型。</p>

<p>结构化思维对于职场来说是一个很好的思维模型，可以以这个为基础，不断打磨自己的方法论。形成自己的思维工具。</p>

<p>人不固执己见，终身学习才是王者，这个和年纪没有什么关系。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>系统设计方案注意事项</title>
      <link href="http://localhost:4000/system-design-idea/"/>
      <pubDate>2022-01-25T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/system design-idea</guid>
      <content:encoded><![CDATA[<h1 id="一需求背景">一、需求背景</h1>

<p>1、 清晰掌握需求的各个场景，以业务为导向，检验技术和系统能否很好支持需求的各个场景。</p>

<p>2、了解需求背景，有助于从技术角度上看，需求是否存在漏洞</p>

<h1 id="二系统架构">二、系统架构</h1>

<p>1、画出清晰的高层框架图，主要体现出用什么组件，之间是怎么连接的，数据流向。</p>

<p>2、证明你的思路，用框架图进行推演，是否可以解决需求问题。</p>

<p>3、各个组件节点，是否存在关键点，是否有备用方案，即容错容灾。</p>

<p>4、 估算业务数据，并发，数据总量，系统是否可以满足。</p>

<h1 id="三关键业务流程图">三、关键业务流程图</h1>

<p>1、深入描述清楚关键组件节点的核心业务逻辑。</p>

<p>2、本地缓存防止热点出现。 本地缓存考虑空标情况。</p>

<p>3、处理外部接口异常情况。</p>

<p>4、防止流程出现阻塞情况。</p>

<p>5、关键接口，或读写缓存/db是否有重试机制。</p>

<p>6、业务或第三方接口是否考虑可重入。</p>

<p>7、关键数据一致性考虑。</p>

<p>8、关键流程是否存在并发，是否需要加锁。极端情况也不能忽略，觉得量少不可能会有并发情况，但极端情况果可以由其他bug导致的。</p>

<p>9、对外接口做频限保护。</p>

<p>10、核心业务流程记录流水。</p>

<h1 id="四业务">四、业务</h1>

<p>1、活动和时间相关的，注意零点和跨年的边界问题。</p>

<h1 id="五数据结构-mysql表设计redis缓存数据">五、数据结构  （mysql 表设计，redis 缓存数据）</h1>

<p>1、<code class="language-plaintext highlighter-rouge">mysql</code> 表设计是否合理，相关字段的索引；字段类型定义；是否有扩展字段；业务的数据总量是否考虑分表，用什么维度分表。</p>

<p>2、<code class="language-plaintext highlighter-rouge">mysql</code> <code class="language-plaintext highlighter-rouge">dao</code> 考虑连接数多少。防止对数据库压力过大，是否要加一层redis缓存。</p>

<p>3、<code class="language-plaintext highlighter-rouge">mysql</code> 优先考虑写主，读从。但也要防止主从同步的时间差可能导致业务逻辑的问题。</p>

<p>4、<code class="language-plaintext highlighter-rouge">mysql</code> sql 效率问题，如:  是否让索引失效，是否有必要连表，连表的是否表设计有问题。</p>

<p>5、<code class="language-plaintext highlighter-rouge">redis</code> 缓存是否存在热点， 是否存在大key， 是否考虑缓存空标，空标有效时间和正常的有效时间要区别出来。有效时间是否考虑打散，防止数据同时失效出现雪崩。</p>

<p>6、<code class="language-plaintext highlighter-rouge">redis</code> 数据结构设计注意版本号或扩展字段。反过来，在迭代新增扩展字段时，要考虑数据序列化问题，即版本号等问题。</p>

<h1 id="六协议">六、协议</h1>

<p>1、协议要简洁易懂，字段命名不要出现歧义，注释清楚。一定要有初始化，且初始化的值要合理。</p>

<p>2、协议要有对应的文档。文档说明清晰。文档要用 <code class="language-plaintext highlighter-rouge">source</code> 记录调用业务来源，预估请量，相关负责人。</p>

<p>3、请求协议要有source字段定义业务来源。</p>

<p>4、服务的协议要注意可扩展，新增字段要在mapExt中添加。</p>

<p>5、服务的协议初始化，序列化要对应正确。</p>

<p>6、响应协议要有错误码和错误信息。在文档要对错误码做出释义。</p>

<h1 id="七配置监控">七、配置监控</h1>

<p>1、对所有第三方接口要单独监控。</p>

<p>2、<code class="language-plaintext highlighter-rouge">dao</code> 操作要做单独监控。</p>

<p>3、<code class="language-plaintext highlighter-rouge">redis</code> 缓存/进程内缓存要监控命中率。</p>

<p>4、对外接口做全局监控。</p>

<p>5、<code class="language-plaintext highlighter-rouge">daemon</code> 也要做全局监控。</p>

<p>6、对外部参数的校验可以不做告警。</p>

<p>7、集中建立个性化视图，写清楚紧急联系人，方便快速找到对应的负责人。</p>

<p>8、接口调用来源做统计监控。</p>

<p>9、关键业务做出错告警。</p>

<p>10、 监控让服务有可观察性。</p>

<h1 id="八异常处理">八、异常处理</h1>

<p>1、考虑兜底方案，降级方案，补偿机制。</p>

<p>2、重试，告警。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>引流活动九宫格抽奖系统设计</title>
      <link href="http://localhost:4000/server-acitivity-ninebox/"/>
      <pubDate>2022-01-24T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/server-acitivity-ninebox</guid>
      <content:encoded><![CDATA[<h1 id="一-背景">一 背景</h1>

<p>在用户购买商品后，完成支付，可以一个抽奖活动。很多线上线下的都会搞类似这样的活动。这个位置是一个很好引流活动。可以把流量引向不同的业务。</p>

<p>如华为运动中的活动：</p>

<p><img src="/assets/system-design/server-activity-ninebox-2022-09-21_17-19-20.png" alt="" /></p>

<p>产品的业务逻辑：</p>

<p>1、九宫格中展示7个坑位的奖品，中间一个是抽奖按钮。第8个坑位是“谢谢参与”。</p>

<p>2、这是一个引流推广活动，所以业务逻辑上要求是奖品必中。之所以留一个坑位“谢谢参与”，是为兜底系统错误（如：网络问题）以避免客诉。</p>

<p>3、活动会接入不同业务线，以达到把流量导入到不同业务线的目的。</p>

<p>4、用户进入页面后，会根据不同的策略展示不同业务的奖品，最多7个奖品。</p>

<p>5、当用户点击“立即抽奖”后，根据不同奖品的不同权重，随机出抽中的奖品，发送领取落地页链接，用户在落地页点击领取。</p>

<p>6、奖品都是来不同的业务线。不存储本地。所以业务方一般要提供两个接口。 查询是可以发奖然后显示，中奖时通知业务方发奖。</p>

<p>如何把不同的业务的接入进来才是这个需求的难点。 不同的业务有不同类型的状态，如红包，试用券， 会员积分，  体验卡，  品牌会员等。</p>

<p>每个业务方都要提供一个查询奖励的接口和一个领奖品的接口。 奖励的数量和库存由对业务方自己决定。</p>

<p><strong>这种方式有好有坏：</strong></p>

<p>1）好处是：奖品的类型和库存可以由各个业务自己配置控制。 活动只是做一个中间路由，只是控制展示策略和命中权重，外加一个兜底奖品。</p>

<p>2）坏处是：过于发散，沟通成本太大，后期活动接入的业务越来越多，性能依赖各个业务的接口的性能。如遇大的调整，每个业务都回归测试一下。</p>

<p>其实，大部分奖品都是可以通知奖池来配置完成。 但这样子业务方无法自己把控奖品。同时也增加了我们运营， 九宫格活动不是京喜的业务，是京东的业务，所以人力成本也是一个原因。</p>

<h1 id="二服务框架">二、服务框架</h1>

<p>所用技术  <code class="language-plaintext highlighter-rouge">c++</code> ,<code class="language-plaintext highlighter-rouge">redis</code>, <code class="language-plaintext highlighter-rouge">http</code> 。</p>

<p>服务整体框架：</p>

<p><img src="/assets/system-design/server-activity-ninebox-2022-09-21_16-55-36.png" alt="" /></p>

<p>说明：</p>

<p>1、 活动通过 <code class="language-plaintext highlighter-rouge">http</code>  的方式提供服务。 两个接口： 一个是查询奖品（query），一个抽奖(draw)。</p>

<p>2、App client 是 京东App。收银台支付页完成后展示出来的是一个h5的页面。 App server是，京东App的服务端，跨团队，客户端没有直接接到我们这边的接口。</p>

<p>3、用户抽奖的相关数据用 <code class="language-plaintext highlighter-rouge">Redis</code> 存储。 中奖信息只保留7天。活动本身并不涉及奖品存储，都是通知业务方发放奖品的。奖品的历史查询是业务方自己的业务逻辑了。</p>

<p>4、业务上要求这个活动是必中活动。所以加入自己的奖池做为兜底。当有业务的奖品库存已经耗尽时，可以用到自己的奖品顶上去。</p>

<p>5、对于请求业务方的奖品，要先按策略选出7个业务的奖品，再通过并发调用接口，提高调用性能。这样，一次并发调用7个接口。</p>

<h2 id="21-展示奖品query">2.1  展示奖品（Query）</h2>

<p>主要逻辑流程图：</p>

<p><img src="/assets/system-design/server-activity-ninebox_2022-09-21_16-20-18.png" alt="" /></p>

<p>说明：</p>

<p>1、 关于奖品的展示策略通过配置中心定义，方便对于策略随时更新。所以服务一开始就要加载配置信息。</p>

<p>2、风险控制方面：１）要求登录，２）查询风控系统　３）判断是否重请求，防止被刷，同一个单多次刷新接口展示一点的奖品。</p>

<p>3、兜底逻辑，在筛选各个业务后如果出现不足七个奖品时，要用查询奖口列表做兜底，满足七个坑位。</p>

<p>4、比较极端的情况下，如果不足7个坑位的奖品，则要求前不展示活动。</p>

<h2 id="22-抽奖接口draw">2.2 抽奖接口（draw） </h2>

<p>主要逻辑流程图：</p>

<p><img src="/assets/system-design/server-activity-ninebox_2022-09-21_16-29-08.png" alt="" /></p>

<p>说明：</p>

<p>1、 抽奖时，要做登录检验，数据从redis中读出，保证数据的一致性。数据缓存redis有7天的时效，这个没有必要重新查询风控。因为写入reids的数据是在查询奖品时就写入的，查询奖品时就已经查询过风控了。</p>

<p> 2、 如果出现异常，返回“谢谢参与“，避免客诉。</p>

<p>3、抽奖后会记录在用户的历史记录中。防止用户重复刷新抽奖。</p>

<p>4、 加redis的乐观锁，防止快速刷时，被不同进程处理。</p>

<h1 id="三总结">三、总结</h1>

<p>这个活动需求最有挑战的，不是开发技术问题，而是沟通问题。随着活动的展开，业务的发展，要求接入的业务越来越多。一个业务的背后是一个不同的团队。沟通起来比较耗时，效率也比较低。 团队也是分散易地办公，很难要规范统一起来，沟通过程出现各种推诿。</p>

<p>当然活动可以做起更加通用一些。 查询接口和通知发奖接口按统一标准接入。可以有一个后台管理系统配置接入业务。配置完成生效后，就可以用。不用每一次新填业务都要去做开发。但做成通知性的难度不低，而且要各个业务方按九宫格的标准备开发接口。我们这边是省事了。他们很难受了。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>java 基本重点知识</title>
      <link href="http://localhost:4000/java-base-learn1/"/>
      <pubDate>2021-07-16T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/java-base-learn1</guid>
      <content:encoded><![CDATA[<p>解释虚拟机指令肯定会比全速运行机器指令慢很多。然而，虚拟机有一个选项，可以将执行最频繁的字节码序列翻译成机器码，这一过程被称为即时编译。</p>

<p>Java虚拟机还有一些其他的优点。它可以检测指令序列的行为，从而增强其安全性。</p>

<h2 id="java的特点">Java的特点</h2>

<ul>
  <li>可移植性</li>
  <li>解释型</li>
  <li>高性能</li>
  <li>多线程</li>
  <li>动态性</li>
</ul>

<h2 id="java-官方的一些源码和文档">Java 官方的一些源码和文档</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">javasrc</code> 在JDK的路径上，有一个src.zip，解开后，含了所有公共类库的源代码。</li>
  <li><code class="language-plaintext highlighter-rouge">javadoc</code>  可以从官网下载文档 https://www.oracle.com/java/technologies/javase-downloads。解压后，可以访问目录上的<code class="language-plaintext highlighter-rouge">jdk-16.0.2_doc-all\docs\index.html</code> 可以在浏览器打开，保存标签，这里可找到所有公共类库的说明。</li>
</ul>

<p><img src="../../assets/java/2021-07-26-java-learn-202449.png" alt="" /></p>

<ul>
  <li>编译器、虚拟机、本地方法以及私有辅助类 http://jdk.java.net/8/ 暂时不看吧。</li>
  <li>书籍代码学习 https://horstmann.com/corejava/ 可以下载。</li>
</ul>

<h2 id="java应用程序">Java应用程序</h2>

<p><strong>注释</strong></p>

<p>有三种注释方式， <code class="language-plaintext highlighter-rouge">//</code>     <code class="language-plaintext highlighter-rouge">/*  */</code>  第三种注释可以生成文档  <code class="language-plaintext highlighter-rouge">/** */</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1、todo </span>

<span class="cm">/* 2、comment */</span>

<span class="cm">/**
* 3、This is a doc comment
*/</span>
</code></pre></div></div>

<h2 id="数据类型">数据类型</h2>

<p>Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型， 8种基本类型。</p>

<p><code class="language-plaintext highlighter-rouge">big number </code> 大数，是一种对象，不是类型。</p>

<p>8种基本类型</p>

<p>整型 <code class="language-plaintext highlighter-rouge">int</code>  4个字节</p>

<p>整型 <code class="language-plaintext highlighter-rouge">short</code> 2个字节</p>

<p>整型 <code class="language-plaintext highlighter-rouge">long</code> 8个字节</p>

<p>整型 <code class="language-plaintext highlighter-rouge">byte</code> 1字节</p>

<p>长整型数值有一个后缀L或l（如4000000000L）。 从Java 7开始，加上前缀0b或0B就可以写二进制数。</p>

<p>浮点型 <code class="language-plaintext highlighter-rouge">float</code> 4个字节</p>

<p>浮点型 <code class="language-plaintext highlighter-rouge">double</code> 8个字节</p>

<p>float类型的数值有一个后缀F或f（例如，3.14F）。没有后缀F的浮点数值（如3.14）默认为double类型。当然，也可以在浮点数值后面添加后缀D或d（例如，3.14D）。</p>

<p>三个特殊的值。</p>

<p>正无穷大  <code class="language-plaintext highlighter-rouge">Double.POSITIVE_INFINITY</code></p>

<p>负无穷大 <code class="language-plaintext highlighter-rouge">Double.NEGATIVE_INFINITY</code></p>

<p>NaN （不是一个数字） <code class="language-plaintext highlighter-rouge">Double.NaN</code></p>

<p>不能这样检测一个特定值是否等于Double.NaN：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">==</span> <span class="nc">Double</span><span class="o">.</span><span class="na">NaN</span><span class="o">)</span> <span class="c1">// is ture </span>
   
<span class="k">if</span> <span class="o">(</span><span class="nc">Double</span><span class="o">.</span><span class="na">isNaN</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="c1">// check x is "not a number"</span>
</code></pre></div></div>

<p>char类型 单个字符， 字面量值要用单引号括起来。<code class="language-plaintext highlighter-rouge">'A'</code>  , <code class="language-plaintext highlighter-rouge">"A"</code> 是一个字符串。可以表示为十六进制值。其范围从<code class="language-plaintext highlighter-rouge">\u0000</code>到<code class="language-plaintext highlighter-rouge">\Uffff</code>。除了转义序列<code class="language-plaintext highlighter-rouge">\u</code>之外，还有一些用于表示特殊字符的转义序列</p>

<p>Unicode类型 另讲。</p>

<p>boolean类型。有两个值：false和true，用来判定逻辑条件。<strong>整型值和布尔值之间不能进行相互转换，这一点要注意和C++不一样</strong>。</p>

<p><strong>枚举类型</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="nc">Size</span><span class="o">{</span><span class="no">SMALL</span><span class="o">,</span> <span class="no">MEDIUM</span><span class="o">,</span> <span class="no">LARGE</span><span class="o">,</span> <span class="no">EXTRA_LARGE</span><span class="o">}</span> <span class="o">;</span> 
</code></pre></div></div>

<h2 id="变量">变量</h2>

<p>在Java中，每个变量都有一个类型（type）。在声明变量时，变量的类型位于变量名之前。 每个声明以分号结束。</p>

<p>变量名必须是一个以字母开头并由字母或数字构成的序列。</p>

<p>不能使用Java保留字作为变量名。</p>

<p>变量名对大小写敏感。</p>

<p>声明一个变量之后，必须用赋值语句对变量进行<strong>显式初始化</strong>。</p>

<p>利用关键字final指示常量。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kt">double</span> <span class="no">CM_PER_INCH</span> <span class="o">=</span> <span class="mf">2.54</span><span class="o">;</span> 
</code></pre></div></div>

<p>类常量的定义位于main方法的外部。</p>

<p><code class="language-plaintext highlighter-rouge">const</code>是 Java 保留的关键字，但目前并没有使用。在Java中，必须使用final定义常量。</p>

<h2 id="运算符">运算符</h2>

<p>在Java中，使用算术运算符<code class="language-plaintext highlighter-rouge">+、-、*、/</code>表示加、减、乘、除运算。</p>

<p>整数的求余操作（有时称为取模）用<code class="language-plaintext highlighter-rouge">%</code>s表示.</p>

<p><strong>数值类型之间的转换</strong></p>

<p>数值类型之间的合法转换.。 6个实心箭头，表示无信息丢失的转换；有3个虚箭头，表示可能有精度损失的转换。</p>

<p><img src="../../assets/java/2021-07-26-java-learn-2024459.png" alt="" /></p>

<p><strong>强制类型转换</strong></p>

<p>可能会丢失一些信息。如</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">9.997</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">x</span><span class="o">;</span> 
</code></pre></div></div>

<p>变量 <code class="language-plaintext highlighter-rouge">nx = 9</code> 小数被截断掉，如果四舍五入用</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">9.997</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="nc">Math</span><span class="o">.</span><span class="na">round</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
</code></pre></div></div>

<p>round方法返回的结果为long类型。所以最后要<code class="language-plaintext highlighter-rouge">（int）</code>转换一下。</p>

<p><strong>结合赋值和运算符</strong></p>

<p>和c++ 一样， <code class="language-plaintext highlighter-rouge">+=</code> 等操作。如：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">+=</span> <span class="mi">4</span><span class="o">;</span> 
</code></pre></div></div>

<p><strong>自增与自减运算符</strong></p>

<p>和c++一样。 如 <code class="language-plaintext highlighter-rouge">x++</code> 、<code class="language-plaintext highlighter-rouge">x--</code> 、<code class="language-plaintext highlighter-rouge">++n</code>、 <code class="language-plaintext highlighter-rouge">--n</code> 。 <code class="language-plaintext highlighter-rouge">++</code>在前在后有区别， 用在表达式中时，前缀形式会先完成加1；而后缀形式会使用变量原来的值。</p>

<p><strong>关系和boolean运算符</strong></p>

<p>基本都沿用了C++的做法。</p>

<p><code class="language-plaintext highlighter-rouge">&amp;&amp;</code>和<code class="language-plaintext highlighter-rouge">||</code>运算符是按照“短路”方式来求值的：如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。</p>

<p>同样支持三元操作符<code class="language-plaintext highlighter-rouge">？:</code></p>

<p>boolean 类型不要做转换。</p>

<h2 id="位运算符">位运算符</h2>

<table>
  <tbody>
    <tr>
      <td>应用在布尔值上时，&amp;和</td>
      <td>运算符也会得到一个布尔值。这些运算符与&amp;&amp;和</td>
      <td> </td>
      <td>运算符很类似，不过&amp;和</td>
      <td>运算符不采用“短路”方式来求值，也就是说，得到计算结果之前两个操作数都需要计算。</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">&gt;&gt;</code>和<code class="language-plaintext highlighter-rouge">&lt;&lt;</code>运算符将位模式左移或右移</p>

<p>有一个新知识：** <code class="language-plaintext highlighter-rouge">&gt;&gt;&gt;</code>运算符会用0填充高位，这与»不同，它会用符号位填充高位。不存在«&lt;运算符。**</p>

<p><strong>括号与运算符级别</strong></p>

<p>与C或C++不同，Java不使用逗号运算符。不过，可以在for语句的第1和第3部分中使用逗号分隔表达式列表。</p>

<h2 id="字符串">字符串</h2>

<p>标准Java类库中提供了一个预定义类，很自然地叫做String。每个用双引号括起来的字符串都是String类的一个实例。</p>

<p>String类的substring方法可以从一个较大的字符串提取出一个子串。</p>

<p>substring的工作方式有一个优点：容易计算子串的长度。字符串s.substring(a, b)的长度为b-a。例如，子串“Hel”的长度为3-0=3。</p>

<p>使用+号连接（拼接）两个字符串。 后面可以是int型。</p>

<p>把多个字符串放在一起，用一个定界符分隔，可以使用静态join方法。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">all</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">" /"</span><span class="o">,</span> <span class="s">"S"</span><span class="o">,</span> <span class="s">"M"</span><span class="o">,</span> <span class="s">"L"</span><span class="o">,</span> <span class="s">"XL"</span><span class="o">);</span> 
<span class="c1">// all is the string  "S / M / L / XL"</span>
</code></pre></div></div>

<p>String类没有提供用于修改字符串的方法。要从原字符串中获取后，重新组成，然后再覆盖回原来的字符串。</p>

<p>不可变字符串却有一个优点：编译器可以让字符串共享</p>

<p>字符串存放在公共的存储池中。字符串变量指向存储池中相应的位置。如果复制一个字符串变量，原始字符串与复制的字符串共享相同的字符。</p>

<p>使用equals方法检测两个字符串是否相等。如果字符串s与字符串t相等，则返回true；否则，返回false。需要注意，s与t可以是字符串变量，也可以是字符串字面。</p>

<p>要想检测两个字符串是否相等，而不区分大小写，可以使用<code class="language-plaintext highlighter-rouge">equalsIgnoreCase</code>方法。</p>

<p>一定不要使用==运算符检测两个字符串是否相等！这个运算符只能够确定两个字符串是否放置在同一个位置上。</p>

<p><strong>空串与Null串</strong></p>

<p>空串”“是长度为0的字符串。可以调用以下代码检查一个字符串是否为空。 空串是一个Java对象，有自己的串长度（0）和内容（空）。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">str</span><span class="o">,</span><span class="n">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
    <span class="c1">// empty string</span>
<span class="o">}</span>

<span class="k">if</span> <span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">""</span><span class="o">)){</span>
    <span class="c1">// empty string</span>
<span class="o">}</span>
</code></pre></div></div>

<p>String变量还可以存放一个特殊的值，名为null，这表示目前没有任何对象与该变量关联。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">str</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
	<span class="c1">// string is null </span>
<span class="o">}</span>
</code></pre></div></div>

<p>检查一个字符串既不是null也不为空串，这种情况下就需要使用以下条件：<strong>首先要检查str不为null</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">str</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">){</span>
    <span class="c1">// string is not null or empty</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>码点与代码单元</strong></p>

<p>Java字符串由char值序列组成。char数据类型是一个采用UTF-16编码表示Unicode码点的代码单元。大多数的常用Unicode字符使用一个代码单元就可以表示，而辅助字符需要一对代码单元表示。</p>

<p><strong>构建字符串</strong></p>

<p>有些时候，需要由较短的字符串构建字符串，例如，按键或来自文件中的单词。采用字符串连接的方式达到此目的效率比较低。每次连接字符串，都会构建一个新的String对象，既耗时，又浪费空间。使用<strong>StringBuilder</strong>类就可以避免这个问题的发生。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">StringBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span> 

<span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span> <span class="c1">// appends a single character </span>
<span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">str</span><span class="o">)</span> <span class="c1">// appends a string </span>
    
<span class="nc">String</span> <span class="n">completeString</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span> 
</code></pre></div></div>

<h2 id="格式化输出">格式化输出</h2>

<p>使用<code class="language-plaintext highlighter-rouge">System.out.print(x)</code>将数值x输出到控制台上。和C语言中的方法一样的。 <code class="language-plaintext highlighter-rouge">printf</code>和C语言一样。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%8.2f"</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>  <span class="c1">//  same to c printf </span>
</code></pre></div></div>

<p>可以使用静态的String.format方法创建一个格式化的字符串，而不打印输出：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"Hello, %s. Next year, you'll be %d"</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">);</span> 
</code></pre></div></div>

<p><strong>文件输入与输出</strong></p>

<p>对文件进行读取，就需要一个用File对象构造一个Scanner对象。如下所示：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Scanner</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"myfile.txt"</span><span class="o">),</span> <span class="s">"UTF-8"</span><span class="o">);</span> 
</code></pre></div></div>

<p>要想写入文件，就需要构造一个PrintWriter对象。在构造器中，只需要提供文件名：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">PrintWriter</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintWriter</span><span class="o">(</span><span class="s">"myfile.txt"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span> 
</code></pre></div></div>

<h2 id="控制流程">控制流程</h2>

<p>Java的控制流程结构与C和C++的控制流程结构一样，只有很少的例外情况。没有goto语句，但break语句可以带标签。 foreach循环。</p>

<h3 id="块作用域">块作用域</h3>

<p>块（即复合语句）是指由一对大括号括起来的若干条简单的Java语句。块确定了变量的作用域。</p>

<p>不能在嵌套的两个块中声明同名的变量。例如</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
<span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">;</span> 
    <span class="c1">// ...</span>
    <span class="o">{</span>
        <span class="kt">int</span> <span class="n">k</span><span class="o">;</span> 
        <span class="kt">int</span> <span class="n">n</span><span class="o">;</span> <span class="c1">// Error  can't redefine n in inner block</span>
        <span class="c1">// ... </span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="条件语句">条件语句</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">condition</span><span class="o">){</span>
    <span class="n">statement</span> 
<span class="o">}</span><span class="k">else</span> <span class="o">{</span>
    <span class="n">statement</span> 
<span class="o">}</span>
</code></pre></div></div>

<h3 id="循环">循环</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="o">(</span><span class="n">condition</span><span class="o">){</span>
    <span class="n">statement</span> 
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="o">{</span>
    <span class="n">statement</span> 
<span class="o">}</span><span class="k">while</span><span class="o">(</span><span class="n">condition</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span> 
<span class="o">}</span>
</code></pre></div></div>
<h2 id="foreach循环">foreach循环</h2>

<p>Java有一种功能很强的循环结构，可以用来依次处理数组中的每个元素（其他类型的元素集合亦可）而不必为指定下标值而分心.。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="n">variable</span> <span class="o">:</span> <span class="n">collection</span><span class="o">){</span>
    <span class="n">statement</span> 
<span class="o">}</span>
</code></pre></div></div>

<h2 id="多重选择switch语句">多重选择：switch语句</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">choice</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span> 
<span class="k">switch</span><span class="o">(</span><span class="n">choice</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> 
        <span class="c1">// ...</span>
        <span class="k">break</span><span class="o">;</span> 
    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> 
        <span class="c1">// ...</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="k">default</span><span class="o">:</span> 
        <span class="c1">// bad input </span>
        <span class="k">break</span><span class="o">;</span> 
<span class="o">}</span>
</code></pre></div></div>

<h2 id="中断控制流程语句">中断控制流程语句</h2>

<p>break , goto ，continue 等。</p>

<p>与C++不同，Java还提供了一种带标签的break语句，用于跳出多重嵌套的循环语句。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">test</span><span class="o">()</span>
<span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">;</span> 
    <span class="nl">read_data:</span>
    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
        <span class="c1">// ...</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"enter anumber &gt;=0:"</span><span class="o">);</span> 
            <span class="n">n</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span> 
            <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">){</span> <span class="c1">// should never  happend-can't go to </span>
                <span class="k">break</span> <span class="n">read_data</span><span class="o">;</span> <span class="c1">// break out fo read_data loop </span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="大数值">大数值</h2>

<p>如果基本的整数和浮点数精度不能够满足需求，那么可以使用<code class="language-plaintext highlighter-rouge">java.math</code>包中的两个很有用的类：<code class="language-plaintext highlighter-rouge">BigInteger</code>  和 <code class="language-plaintext highlighter-rouge">BigDecimal</code>。</p>

<p>这两个类可以处理包含任意长度数字序列的数值。<code class="language-plaintext highlighter-rouge">BigInteger</code>类实现了任意精度的整数运算，<code class="language-plaintext highlighter-rouge">BigDecimal</code>实现了任意精度的浮点数运算。</p>

<p>使用静态的valueOf方法可以将普通的数值转换为大数值：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BigInteger</span> <span class="n">a</span> <span class="o">=</span> <span class="nc">BigInteger</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span> 
<span class="nc">BigInteger</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">b</span><span class="o">);</span> <span class="c1">// c = a+b</span>
<span class="nc">BigInteger</span> <span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">multiply</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">BigInteger</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">2</span><span class="o">)))</span><span class="c1">// d = c * (b+2)</span>
</code></pre></div></div>

<h3 id="数组">数组</h3>

<p>数组是一种数据结构，用来存储同一类型值的集合。通过一个整型下标可以访问数组中的每一个值。</p>

<p>声明了整型数组a：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">;</span>  <span class="c1">// 声明变更a  或 int a[]</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">100</span><span class="o">]</span> <span class="o">;</span> 
</code></pre></div></div>

<p>有个更加简单的方式打印数组中的所有值，即利用Arrays类的toString方法。调用Arrays.toString(a)，返回一个包含数组元素的字符串，这些元素被放置在括号内，并用逗号分隔，例如，“[2,3,5,7,11,13]”。要想打印数组，可以调用:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">,</span><span class="n">toString</span><span class="o">(</span><span class="n">a</span><span class="o">));</span> 
</code></pre></div></div>

<p><strong>数组初始化以及匿名数组</strong></p>

<p>提供了一种创建数组对象并同时赋予初始值的简化书写形式</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">smallPrimes</span> <span class="o">=</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">13</span><span class="o">};</span> 
</code></pre></div></div>

<p>不需要调用 new。</p>

<p>初始化一个匿名的数组：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">13</span><span class="o">};</span> 

<span class="n">smallPrimes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">13</span><span class="o">};</span> 
</code></pre></div></div>

<p><strong>数组拷贝</strong></p>

<p>在Java中，允许将一个数组变量拷贝给另一个数组变量。这时，两个变量将引用同一个数组.。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">[]</span> <span class="n">luckyNumbers</span> <span class="o">=</span> <span class="n">smallPrimes</span><span class="o">;</span> 
<span class="n">luckyNumbers</span><span class="o">[</span><span class="mi">5</span><span class="o">]</span> <span class="o">=</span> <span class="mi">12</span><span class="o">;</span> <span class="c1">// noew smallPrimes[5] is also 12 </span>
</code></pre></div></div>

<p>如果希望将一个数组的所有值拷贝到一个新的数组中去，就要使用Arrays类的<code class="language-plaintext highlighter-rouge">copyOf</code>方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">copiedLickyNumbers</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">luckyNumbers</span><span class="o">,</span> <span class="n">lickyNumbers</span><span class="o">.</span><span class="na">length</span><span class="o">);</span> 
</code></pre></div></div>

<p>第2个参数是新数组的长度。这个方法通常用来增加数组的大小：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">copiedLickyNumbers</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">luckyNumbers</span><span class="o">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">lickyNumbers</span><span class="o">.</span><span class="na">length</span><span class="o">);</span> 
</code></pre></div></div>

<p>Java数组与C++数组在堆栈上有很大不同，但基本上与<strong>分配在堆（heap）</strong>上的数组指针一样。</p>

<h2 id="命令行参数">命令行参数</h2>

<p>每一个Java应用程序都有一个带Stringarg[]参数的main方法。这个参数表明main方法将接收一个字符串数组，也就是命令行参数。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> 
<span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> 
    <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">arg</span> <span class="o">:</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="s">"-version"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"v10000.0"</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

]]></content:encoded>
    </item>
    
    <item>
      <title>java 技术栈学习脉络</title>
      <link href="http://localhost:4000/java-learn-map/"/>
      <pubDate>2021-07-16T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/java-learn-map</guid>
      <content:encoded><![CDATA[<p>继续整理更新中~</p>

<h3 id="一-java基础">一、 java基础</h3>

<ol>
  <li>Linux常用命令</li>
  <li>Shell 脚本编程</li>
  <li>数据结构</li>
  <li>算法</li>
  <li>集合</li>
  <li>IO/NIO</li>
  <li>并发编程
    <ul>
      <li>并发基石线程基础</li>
      <li>synchronized</li>
      <li>JUC</li>
    </ul>
  </li>
  <li>JVM</li>
  <li>JDBC 连接池</li>
  <li>编码规范</li>
</ol>

<h3 id="二jave-web-略过">二、jave web 略过</h3>

<p>JSP、Servlet 、Html、CSS、JavaScript、JQuery、Tomcat</p>

<h3 id="三-重构设计">三 重构设计</h3>

<p>设计原则</p>

<ol>
  <li>开闭原则总则</li>
  <li>依赖倒置原则</li>
  <li>接口隔离原则</li>
  <li>单一职责原则</li>
  <li>里氏替换原则</li>
  <li>最少知道原则</li>
  <li>合成复用原则</li>
</ol>

<p>常用设计模式</p>

<ul>
  <li>创建型模式
    <ul>
      <li>单例模式</li>
      <li>工厂模式</li>
    </ul>
  </li>
  <li>结构型模式
    <ul>
      <li>代理模式</li>
      <li>装饰模式</li>
      <li>适配器模式</li>
    </ul>
  </li>
  <li>行为型模式
    <ul>
      <li>策略模式</li>
      <li>命令模式</li>
      <li>责任链模式</li>
      <li>观察者模式</li>
      <li>模板方法模式</li>
    </ul>
  </li>
</ul>

<p>重构-改善既有代码的设计</p>

<h3 id="三开源框架-重点">三、开源框架 （重点）</h3>

<ol>
  <li>NET 框架 
​    - Netty 
​    - HttpClient 
​    - Mina</li>
  <li>MVC框架
    <ul>
      <li>Sping</li>
      <li>Structs</li>
    </ul>
  </li>
  <li>ORM 框架
    <ul>
      <li>MyBatis</li>
      <li>Hibernate</li>
    </ul>
  </li>
  <li>RPC 框架
    <ul>
      <li>Dubbo</li>
      <li>springCloud</li>
      <li>Thrift</li>
    </ul>
  </li>
  <li>模板引擎
    <ul>
      <li>Velocity</li>
      <li>Freemarker</li>
    </ul>
  </li>
</ol>

<h3 id="四数据存储">四、数据存储</h3>

<ol>
  <li>SQL数据库
    <ul>
      <li>MySQL</li>
      <li>Oracle</li>
      <li>DB2</li>
      <li>分库分表 
ShardingSphere 
MyCat 
TDDL</li>
    </ul>
  </li>
  <li>NoSQL
    <ul>
      <li>Redis</li>
      <li>Hbase</li>
      <li>MongoDB</li>
    </ul>
  </li>
</ol>

<h3 id="五测试技能">五、测试技能</h3>

<ol>
  <li>单元测试MockSpringTest</li>
  <li>压力测试 JMeter</li>
</ol>

<h3 id="六中间件">六、中间件</h3>

<ol>
  <li>Redis</li>
  <li>RocketMQ</li>
  <li>Zookerper</li>
  <li>elasticStack</li>
  <li>etcd</li>
  <li>kafka</li>
  <li>memcashed</li>
</ol>

<h3 id="七性能优化">七、性能优化</h3>

<ol>
  <li>web 前端性能优化 （略过）</li>
  <li>应用服务性能优化
    <ul>
      <li>集群</li>
      <li>缓存</li>
      <li>异步</li>
      <li>代码
        <ul>
          <li>并发</li>
          <li>编程</li>
          <li>资源得胜</li>
          <li>数据结构</li>
        </ul>
      </li>
      <li>JVM</li>
    </ul>
  </li>
  <li>数据存取性能优化
    <ul>
      <li>SQL优化</li>
      <li>索引优化</li>
      <li>数据库架构 + 分库分表</li>
    </ul>
  </li>
</ol>

<h3 id="八架构技能">八、架构技能</h3>

<ol>
  <li>分布式架构
    <ul>
      <li>keepalive + nginx/lvs</li>
      <li>Zooperper</li>
      <li>RPC
        <ul>
          <li>Dubbo</li>
          <li>SpringCloud</li>
        </ul>
      </li>
      <li>服务治理
        <ul>
          <li>服务熔断</li>
          <li>服务降级</li>
          <li>服务限流</li>
          <li>服务隔离</li>
        </ul>
      </li>
      <li>MQ
        <ul>
          <li>RockerMQ</li>
          <li>kafka</li>
        </ul>
      </li>
      <li>缓存
        <ul>
          <li>redis</li>
          <li>memchached</li>
        </ul>
      </li>
      <li>分布数据一致性</li>
      <li>微服务架构</li>
      <li>Docker</li>
      <li>数据库架构
        <ul>
          <li>主备架构</li>
          <li>主从架构</li>
          <li>双主架构 （什么场景会有这个？）</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h3 id="九大数据">九、大数据</h3>

<ol>
  <li>数据收集
    <ul>
      <li>网络爬虫</li>
      <li>Flume/Logstash</li>
    </ul>
  </li>
  <li>数据存储
    <ul>
      <li>HDFSHive (这个算是存储吗？)</li>
      <li>Hbase</li>
      <li>MongoDB</li>
    </ul>
  </li>
  <li>数据检索
    <ul>
      <li>Elasticsearch</li>
    </ul>
  </li>
  <li>数据处理
    <ul>
      <li>Hive</li>
      <li>Storm</li>
      <li>ParkFlink</li>
    </ul>
  </li>
  <li>数据挖掘
    <ul>
      <li>机器学习</li>
    </ul>
  </li>
</ol>

<h3 id="十解决方案">十、解决方案</h3>

<ol>
  <li>技术实践方案</li>
  <li>业务实现方案</li>
</ol>

<h3 id="十一其他技能">十一、其他技能</h3>

<ol>
  <li>开发工具
    <ul>
      <li>Intellij</li>
      <li>IDEA</li>
      <li>Eclipse</li>
    </ul>
  </li>
  <li>项目构建
    <ul>
      <li>MavenGradle</li>
    </ul>
  </li>
  <li>版本控制
    <ul>
      <li>Git</li>
      <li>SVN</li>
    </ul>
  </li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>腾讯云容器团队内部Istio 笔记</title>
      <link href="http://localhost:4000/tencent-cloud-container-team-istio/"/>
      <pubDate>2020-10-17T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/tencent-cloud -container-team-istio</guid>
      <content:encoded><![CDATA[<p>文章来源： <a href="https://www.servicemesher.com/blog/istio-the-king-of-service-mesh/">腾讯云容器团队内部Istio专题分享</a>
作者：钟华</p>

<p>微服务架构是更为复杂的分布式系统，它给运维带来了更多挑战, 这些挑战主要包括资源的有效管理和服务之间的治理, 如:</p>

<p>新的分布式系统:微服务架构 带来了新挑战， 资源的有效管理和服务之间的治理。 其实分布式系统本质上都有这样的挑战，但微服务架构快速发展，让这一些问更加突出了。</p>

<ul>
  <li>服务注册, 服务发现</li>
  <li>服务伸缩</li>
  <li>健康检查</li>
  <li>快速部署</li>
  <li>服务容错: 断路器, 限流, 隔离舱, 熔断保护, 服务降级等等</li>
  <li>认证和授权</li>
  <li>灰度发布方案</li>
  <li>服务调用可观测性, 指标收集</li>
  <li>配置管理</li>
</ul>

<p>在很多微服务架构中，都是通过架构api、sdk。做入侵式的开发，在架构中屏蔽了底层网络的复杂性，提供服务注册发现、服务RPC通信、服务配置管理、服务负载均衡、路由限流、容错、服务监控及治理、服务发布及升级等通用能力。</p>

<p>比较典型的产品有:</p>
<ul>
  <li>分布式RPC通信框架: COBRA, WebServices, Thrift, GRPC 等</li>
  <li>服务治理特定领域的类库和解决方案: Hystrix, Zookeeper, Zipkin, Sentinel 等</li>
  <li>对多种方案进行整合的微服务框架: SpringCloud、Finagle、Dubbox 等</li>
</ul>

<p>service mesh 提供了一种 <strong>Sidecar 模式</strong></p>

<p>这其实不是什么新东西，以前叫做agent, 在两个节点之前加一个代理。 微服务的大部分需要解决的问题，在这sidecar 实现。提供服务注册发现、服务RPC通信、服务配置管理、服务负载均衡、路由限流、容错、服务监控及治理、服务发布及升级等通用能力</p>

<p>Linkerd的CEO Willian Morgan给出的Service Mesh的定义:</p>

<blockquote>
  <p>A Service Mesh is a dedicated infrastructure layer for handling service-to-service communication. It’s responsible for the reliable &gt; delivery of requests through the complex topology of services that comprise a modern, cloud native application. In practice, the
Service Mesh is typically implemented as an array of lightweight network proxies that are deployed alongside application code,
without the application needing to be aware.</p>
</blockquote>

<p>关键字：基础设施层　轻量级网络代理　对应用程序透明</p>

<p>第二代 Service Mesh　在数据平面的基础上添加了控制平面。</p>

<p>国内Service Mesh 发展情况：</p>

<ul>
  <li>蚂蚁金服开源SOFAMesh：
    <ul>
      <li>https://github.com/alipay/sofa-mesh</li>
      <li>从istio fork</li>
      <li>使用Golang语言开发全新的Sidecar，替代Envoy</li>
      <li>为了避免Mixer带来的性能瓶颈，合并Mixer部分功能进入Sidecar</li>
      <li>Pilot和Citadel模块进行了大幅的扩展和增强</li>
      <li>扩展RPC协议: SOFARPC/HSF/Dubbo</li>
    </ul>
  </li>
  <li>华为:
    <ul>
      <li>go-chassis: https://github.com/go-chassis/go-chassis golang 微服务框架, 支持istio平台</li>
      <li>mesher: https://github.com/go-mesh/mesher mesh 数据面解决方案</li>
      <li>国内首家提供Service Mesh公共服务的云厂商
目前(2019年1月)公有云Istio 产品线上已经支持申请公测, 产品形态比较完善
腾讯云 TSF:
基于 Istio、envoy 进行改造
支持 Kubernetes、虚拟机以及裸金属的服务
对 Istio 的能力进行了扩展和增强, 对 Consul 的完整适配
对于其他二进制协议进行扩展支持
唯品会
OSP (Open Service Platform)
新浪:
Motan: 是一套基于java开发的RPC框架, Weibo Mesh 是基于Motan</li>
    </ul>
  </li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>service mesh 学习资料收集</title>
      <link href="http://localhost:4000/service-mesh-refer/"/>
      <pubDate>2020-10-17T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/service-mesh-refer</guid>
      <content:encoded><![CDATA[<h3 id="资料收集">资料收集</h3>

<ul>
  <li><a href="https://zhuanlan.zhihu.com/p/61901608">什么是Service Mesh</a></li>
  <li><a href="https://philcalcado.com/2017/08/03/pattern_service_mesh.html">Pattern: Service Mesh</a></li>
  <li><a href="https://philcalcado.com/">Phil Calçado: https://philcalcado.com/</a></li>
  <li><a href="https://www.servicemesher.com/istio-handbook/">Istio Handbook——Istio 服务网格进阶实战</a></li>
  <li><a href="https://istio.io/">istio官网 https://istio.io/</a></li>
  <li><a href="https://www.servicemesher.com/envoy/">Envoy 官方文档中文版</a></li>
  <li><a href="https://istio.io/latest/zh/docs/ops/deployment/architecture/">Istio</a></li>
  <li><a href="https://github.com/sofastack/sofa-mesh">蚁金服开源SOFAMesh</a></li>
  <li><a href="https://www.servicemesher.com/blog/istio-the-king-of-service-mesh/">腾讯云容器团队内部Istio专题分享</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/38994623">企业级应用弹性伸缩的最佳方式：Service Mesh</a></li>
  <li><a href="https://zjj2wry.github.io/network/iptables/">理解 kube-proxy 中 iptables 规则</a></li>
  <li><a href="https://www.qikqiak.com/post/how-to-use-ipvs-in-kubernetes/">ipvs vs. iptables</a></li>
  <li><a href="https://jimmysong.io/kubernetes-handbook/">Kubernetes Handbook——Kubernetes 中文指南/云原生应用架构实践手册</a></li>
  <li> <a href="https://skyao.io/">敖小剑的博客</a></li>
  <li> <a href="https://www.infoq.cn/article/azCFGyTDGakZqaLEEDMN">蚂蚁金服 API Gateway Mesh 思考与实践</a></li>
  <li> <a href="https://www.servicemesher.com/blog/do-i-need-an-api-gateway-if-i-have-a-service-mesh/">使用了 Service Mesh 后我还需要 API 网关吗</a></li>
  <li><a href="http://blog.itpub.net/69904796/viewspace-2648816/">蚂蚁金服 Service Mesh 落地实践与挑战，附全套PPT下载</a></li>
  <li><a href="http://xiaorui.cc/archives/6051">技术分享之service mesh (k8s&amp;istio)的那些事儿</a></li>
</ul>

<p>书箱：</p>

<p>《Service Mesh实战：用Istio软负载实现服务网格 》</p>

<p>作者：周遥 http://seflerzhou.net</p>

<p>微信读书：https://weread.qq.com/web/bookReview/list?bookId=f57324607188b37df57c39e</p>

<p>《书名：Service Mesh微服务架构设计》</p>

<p>作者：刘俊海</p>

<p>微信读书： https://weread.qq.com/web/reader/42932ba07195510b429d842kc81322c012c81e728d9d180</p>

]]></content:encoded>
    </item>
    
    <item>
      <title>缓存</title>
      <link href="http://localhost:4000/cache/"/>
      <pubDate>2020-08-21T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/cache</guid>
      <content:encoded><![CDATA[<p>学习资料：
<a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E7%BC%93%E5%AD%98">缓存</a></p>

<p>缓存可以提高页面的加载数据速度，减少服务器和数据库的负担。一般是先查询缓存中是否存在，不存在则向数据源请求，然后缓存在本地。</p>

<p>数据库分征均匀分布的读取是最好的，但存在热门数据，均匀分布读取就变成不可能的事，所以，缓存有效的缓解这一问题。</p>

<p>缓存分类：</p>

<ol>
  <li>客户端缓存</li>
  <li>CDN缓存</li>
  <li>Web服务器缓存</li>
</ol>

<h3 id="客户端缓存">客户端缓存</h3>

<p>一般指的是请求的缓存在本地的方式，可以位于客户端（操作系统，浏览器），服务器（当作客户端看待）另一个角度上看可以是进程内。</p>

<h3 id="cdn缓存">CDN缓存</h3>

<p>可以当做一种缓存，主要缓存静态文件。</p>

<h3 id="web服务器缓存">Web服务器缓存</h3>

<p>请求的数据被缓存在web服务器上，当发现这url命中缓存时，直接返回，不再向应用服务器请求数据。反向代理和缓存varnish。（查一下）</p>

<h3 id="数据库缓存">数据库缓存</h3>

<p>大部分数据库是可以配置内存缓存，如mysql <a href="https://zhuanlan.zhihu.com/p/55947158">[玩转MySQL之四]MySQL缓存机制</a>。
针对一般用例进行了优化。调整配置，在不同情况下使用不同的模式可以进一步提高性能。</p>

<h3 id="应用缓存">应用缓存</h3>

<p>基于内存的缓存比如 Memcached 和 Redis 是应用程序和数据存储之间的一种键值存储。由于数据保存在 RAM 中，它比存储在磁盘上的典型数据库要快多了。RAM 比磁盘限制更多，所以例如 least recently used (LRU) 的缓存无效算法可以将「热门数据」放在 RAM 中，而对一些比较「冷门」的数据不做处理。</p>

<p>Redis 有下附加功能：</p>

<ul>
  <li>持久性选项</li>
  <li>内置数据结构（有序集合和列表）</li>
</ul>

<p>有多个缓存级别，分为两大类： <strong>数据库查询</strong>和<strong>对象</strong></p>

<ul>
  <li>行级别</li>
  <li>查询级别</li>
  <li>完整的可序列化对象</li>
  <li>完全渲染的HTML</li>
</ul>

<p>一般来说，你应该尽量避免基于文件的缓存，因为这使得复制和自动缩放很困难。</p>

<p>对象级别的缓存</p>

<p>将数据视为对象，就像对待你的应用代码一样，让应用程序数据从数据库中的组合到类实例或数据结构中：</p>

<ul>
  <li>如果查对象的基础数据已经更改了。那么从缓存中删掉这个对象。（一般很难知道基础数据是否已经更新了）</li>
  <li>异步处理： workers 通过使用最新的缓存对象来组装对象。（监控基础数据是否有更新，有则更新缓存，注意必要时加锁）</li>
</ul>

<p>建议缓存的内容： 什么数据应该缓存，还是要看具体的场景，是否提高访问速度，减少服务器或数据库压力。换个说法，建议什么内容不要用缓存，事务性要求比较高，涉及交易数据等（后续想到添加….）</p>

<h3 id="何时更新缓存">何时更新缓存</h3>

<h4 id="缓存模式">缓存模式</h4>

<p>应用从存储器读写。缓存不和存储器直接交互，执行如下：</p>

<ul>
  <li>在缓存中查询记录，没命中</li>
  <li>从存储器中加载所需内容</li>
  <li>将查找到的结果存储到缓存中</li>
  <li>返回所需内容</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">get_user</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">):</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">cache</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"user.{0}"</span><span class="p">,</span> <span class="n">user_id</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">user</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">user</span> <span class="o">=</span> <span class="n">db</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="s">"SELECT * FROM users WHERE user_id = {0}"</span><span class="p">,</span> <span class="n">user_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">user</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="s">"user.{0}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">user_id</span><span class="p">)</span>
            <span class="n">cache</span><span class="p">.</span><span class="nb">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">json</span><span class="p">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">user</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">user</span>
</code></pre></div></div>
<p>这种方式一般都有设置缓存有效期。当过了有效期则重新从存储器上读取。
缺点：</p>

<ul>
  <li>请求数据不在缓存中，就需要经过三个步骤来获取数据，会有明显的延迟。</li>
  <li>存储器上的数据被更新了，会导致缓存中的数据成为旧数据。请求没能及时拿到最新的数据，可能通过设计有效时间，或直写的模式来缓解这种情况。</li>
</ul>

<h4 id="直写模式">直写模式</h4>

<p>应用使用缓存作为说要的数据存储，将数据读写到缓存中，而缓存负责从数据库中读写数据。</p>

<ul>
  <li>应用向缓存中添加/更新数据</li>
  <li>缓存同步地写入数据存储</li>
  <li>返回所需内容</li>
</ul>

<p>即，应用层只关心写缓存就可以了，同步数据库由缓存机制自己完成。</p>

<p>应用代码：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">set_user</span><span class="p">(</span><span class="mi">12345</span><span class="p">,</span> <span class="p">{</span><span class="s">"foo"</span><span class="p">:</span><span class="s">"bar"</span><span class="p">})</span>
</code></pre></div></div>
<p>缓存代码：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">set_user</span><span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">db</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="s">"UPDATE Users WHERE id = {0}"</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
    <span class="n">cache</span><span class="p">.</span><span class="nb">set</span><span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">user</span><span class="p">)</span>
</code></pre></div></div>

<p>直写模式的缺点：</p>

<ul>
  <li>写入的大多数数据可能永远不会被读取，用TTL（生存时间值）可以最小化这种情况。</li>
  <li>存写操作比较慢，但读取刚写的数据很快。</li>
</ul>

<h4 id="回写模式">回写模式</h4>

<p>先写入缓存中，然后通过MQ，把数据发给另一个模块，由它写入数据库。</p>

<ul>
  <li>在缓存中增加或更新条目。</li>
  <li>异步写入数据，提高写入性能。</li>
</ul>

<p>缺点：</p>

<ul>
  <li>可能存在缓存写入成功，写入数据库失败，导致数据不一致。</li>
  <li>方式比直写模式或缓存更复杂一些。</li>
</ul>

<h3 id="相关资源和延伸阅读">相关资源和延伸阅读</h3>

<p><a href="https://en.wikipedia.org/wiki/Cache_replacement_policies">缓存替换策略</a>
<a href="https://lethain.com/introduction-to-architecting-systems-for-scale/">可缩放系统构架介绍</a>
<a href="https://en.wikipedia.org/wiki/Cache_(computing)">维基百科</a></p>

]]></content:encoded>
    </item>
    
    <item>
      <title>负载均衡和反向代理</title>
      <link href="http://localhost:4000/load-balancing-and-reverse-proxy/"/>
      <pubDate>2020-08-19T00:12:15+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/load-balancing-and-reverse-proxy</guid>
      <content:encoded><![CDATA[<h2 id="负载均衡">负载均衡</h2>

<p>负载均衡是高可用网络基础架构的关键组件，通常用于将工作负载分布到多个服务器来提高网站、应用、数据库或其他服务的性能和可靠性。</p>

<h4 id="一个没有负载均衡的web架构">一个没有负载均衡的web架构</h4>

<p><img src="https://pic3.zhimg.com/80/v2-6a7f624cd5e776a6b0b05a051e65666e_720w.jpg" alt="" /></p>

<h4 id="存在问题">存在问题</h4>

<ol>
  <li>如果服务器宕机了，用户就无法访问到数据了。</li>
  <li>单位时间内请求人的比较，可能会超过它的处理极限，也可能请求不到数据。</li>
</ol>

<p>后端引入负载均衡器，可以缓解这个问题。通常要求所有后端服务器保证提供相同的内容，无论用户访问时昨到那了个服务响应。都能收到相同的内容。</p>

<h4 id="负载均衡器的效用在于">负载均衡器的效用在于</h4>

<ul>
  <li>防止请求进入不好的服务器</li>
  <li>防止资源过载帮助</li>
  <li>消除单一的故障点</li>
  <li>水平扩展，提高性能和可用性，性价比高。</li>
</ul>

<p><img src="https://picb.zhimg.com/80/v2-6aa2607e04cc9d2f0d448f9fa80b2ae2_720w.jpg" alt="" /></p>

<h4 id="负载均衡可以处理协议请求">负载均衡可以处理协议请求：</h4>

<ul>
  <li>http</li>
  <li>https</li>
  <li>tcp</li>
  <li>udp</li>
</ul>

<p>其实负载均衡是一种解法的问题思路，和具体的协议没什么关系。特定协议可以自己写负载均衡器达到目的。</p>

<p>负载均衡器如何选择要转发的后端服务器？</p>

<p>首先，要确保所和选择的服务器是健康的，一般会有一个健康服务器池（healthy pool）中进行选择。</p>

<p>如何知道后端的服务是否健康，我猜负载均衡器会定时的检测后端的服务的状态，是否可用。　</p>

<h4 id="选择规则算法">选择规则算法：</h4>

<ol>
  <li>轮询算法</li>
  <li>加权轮询算法</li>
  <li>随机算法</li>
  <li>加权随机算法</li>
  <li>哈希法</li>
  <li>一致性哈希</li>
  <li>最少连接算法</li>
</ol>

<p>负载均衡器还能帮助水平扩展，提高性能和可用性。使用商业硬件的性价比更高，并且比在单台硬件上垂直扩展更贵的硬件具有更高的可用性。</p>

<p><strong>水平扩展的缺陷：</strong></p>

<ul>
  <li>
    <p>水平扩展引入了复杂度并涉及服务器复制</p>

    <ul>
      <li>服务器应该是无状态的:它们也不该包含像 session 或资料图片等与用户关联的数据。</li>
      <li>session 可以集中存储在数据库或持久化缓存（Redis、Memcached）的数据存储区中。</li>
    </ul>
  </li>
  <li>
    <p>缓存和数据库等下游服务器需要随着上游服务器进行扩展，以处理更多的并发连接。</p>
  </li>
</ul>

<h4 id="nginx-负载均衡的策略">nginx 负载均衡的策略：</h4>

<ol>
  <li>轮询（默认）： 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端不通，则自动剔除。</li>
  <li>weight  ： 指定轮询几率，weight和访问比率成正比， 用于后端服务器能不情况。</li>
  <li>ip_hash :  通过hash 用户访问IP，把用户指向同一个服务器上，这种方式会把用户固定在某一个服务器上，除非用户IP变了。</li>
  <li>fair （第三方）： 按后端服务嘎嘎的响应时间来分配请求，响应时间短的优先分配。</li>
  <li>url_hash (第三方) ：按访问url的hash结果来分配请求，使用每个url定向到一个（对应的）后端服务。</li>
</ol>

<h4 id="扩展阅读">扩展阅读</h4>

<ul>
  <li><a href="https://blog.csdn.net/readiay/article/details/53538085">浮动IP（FLOAT IP）</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/32841479">什么是负载均衡？https://zhuanlan.zhihu.com/p/32841479</a></li>
  <li><a href="https://cloud.tencent.com/developer/article/1480179">大神口中的服务器负载均衡到底是什么意思？https://cloud.tencent.com/developer/article/1480179</a></li>
  <li><a href="https://www.cnblogs.com/xybaby/p/7867735.html">关于负载均衡的一切：总结与思考:https://www.cnblogs.com/xybaby/p/7867735.html</a></li>
</ul>

<h2 id="反向代理">反向代理</h2>

<p>反向代理是一种可以集中地调用内部服务，并提供统一接口给公共客户的 web 服务器。来自客户端的请求先被反向代理服务器转发到可响应请求的服务器，然后代理再把服务器的响应结果返回给客户端。</p>

<p><strong>带来的好处包括：</strong></p>

<ul>
  <li>增加安全性 - 隐藏后端服务器的信息，屏蔽黑名单中的 IP，限制每个客户端的连接数。</li>
  <li>提高可扩展性和灵活性 - 客户端只能看到反向代理服务器的 IP，这使你可以增减服务器或者修改它们的配置。</li>
  <li>本地终结 SSL 会话 - 解密传入请求，加密服务器响应，这样后端服务器就不必完成这些潜在的高成本的操作。 免除了在每个服务器上安装 X.509 证书的需要</li>
  <li>压缩 - 压缩服务器响应.</li>
  <li>缓存 - 直接返回命中的缓存结果.</li>
  <li>静态内容 - 直接提供静态内容, HTML/CSS/JS图片视频等等</li>
</ul>

<h4 id="扩展阅读-1">扩展阅读</h4>

<ul>
  <li><a href="https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/">What is a Reverse Proxy vs. Load Balancer? https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/</a></li>
  <li><a href="https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/">NGINX 架构 https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>《极客时间》 微服务架构核心20讲</title>
      <link href="http://localhost:4000/time-geekbang-microservice-core20/"/>
      <pubDate>2020-02-09T03:22:12+08:00</pubDate>
      <author>xyecho</author>
      <guid>http://localhost:4000/time-geekbang-microservice-core20</guid>
      <content:encoded><![CDATA[<p>极客时间学习笔记， 微服务架构核心20讲</p>

<p>作者：杨波　（拍拍贷框架研发部总监，资深架构师，微服务技术专家）</p>

<p><a href="https://time.geekbang.org/course/intro/66">微服务架构核心20讲 https://time.geekbang.org/course/intro/66</a></p>

<h2 id="1-什么是微服务架构">1 什么是微服务架构</h2>
<hr />
<p>微服务是一种架构风格（如MVC）　</p>

<p>微服务的六个特点：　</p>
<ul>
  <li>一组小的服务</li>
  <li>独立的进程</li>
  <li>轻量级通信</li>
  <li>基于业务能务</li>
  <li>独立部署</li>
  <li>无集中式管理 （这里指的是可以用不同的技术栈，不同的存储）</li>
</ul>

<p>微服框架的定义者马丁福勒：他的一篇博客：</p>

<p><a href="https://www.martinfowler.com/articles/microservices.html">马丁福勒的文章 https://www.martinfowler.com/articles/microservices.htm</a></p>

<p><strong>微服务定义</strong></p>

<p>基于有界上下文的　松散耦合面向服务的架构。</p>

<h2 id="２架构师如何权衡微服务的利弊">２　架构师如何权衡微服务的利弊</h2>
<hr />
<p>开发者的一个重要职责就是权衡</p>

<p>利:</p>

<ul>
  <li>强模块化边界</li>
  <li>可独立部署</li>
  <li>技术多样性</li>
</ul>

<p>弊:</p>
<ul>
  <li>分布式系统复杂性</li>
  <li>最终一致性</li>
  <li>运维复杂性</li>
  <li>测试复杂性</li>
</ul>

<p>分布式系统带来的一个挑战就是取终一致性。</p>

<h2 id="３康威法则和微服务给架构师怎样的启示">３　康威法则和微服务给架构师怎样的启示</h2>
<hr />

<p>设计系统的组织，其产生的架构设计等价于组织间的沟通结构。</p>

<p>其实就是要规避，多个团队去支持一个服务模块。应该拆解成一个团队支持一个小服务，多个小服务组织成一个大服务（或系统）。</p>

<h2 id="４企业应该在什么时候开始考虑引入微服务">４　企业应该在什么时候开始考虑引入微服务</h2>
<hr />

<p>微服务的适用性:</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_4.png" alt="" /></p>

<p>Monolth 单块服务</p>

<p>Microservice 微服务</p>

<p>微服务 有基础模块和平台的要求，所以企业刚开始时微服务并不能有高的生产力。</p>

<p>所以一般以单块服务开始。适用于小企业，微服务更加适合于中大型企业。</p>

<p>中间的交点，就是企业要考虑从单块服务切换成微服务的时候了。</p>

<p>业务模块的复杂性已经达到某个点了。 点的把控要架构师应该思考的问题、一般100人的团队可以考虑了这个问题了。</p>

<p>一般业务开始以单块服务优先。如果研发效率开始下降了。再做优化，向微服方向转变。</p>

<p>如果一开始就以微服开始，可能在设计上会更复杂。</p>

<p>架构是演化出来的。</p>

<p>不可能一步到位， 所以一般是单块优先原则，然后不断迭代，不断的微服化。</p>

<h2 id="5-什么样组织架构更适合微服务">5 什么样组织架构更适合微服务</h2>
<hr />

<p>组织架构：</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_5_1.png" alt="" /></p>

<p>左边是比较传统的组织架构。产品从左到右流程走，可能出现的问题，反馈比较慢，对业务支持比较慢。沟通成本比较大。</p>

<p>右边是比较合适微服务的组织架构， 每一个团队（基于微服务的跨职能的团队），有开发，有产品，有测试，团队都支持自己的微服务。交付的产口是平台，对外提供API
接口支持多样的业务。</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_5_2.png" alt="" /></p>

<p>在团队内做内部循环。端对端的开发。</p>

<p>谁开发的，谁构建，谁支持。</p>

<h2 id="6-如何理解阿里巴巴提出的微服务">6 如何理解阿里巴巴提出的微服务</h2>
<hr />

<p>中台战略和微服务的关系
下图：一线互联网主流的组织架构。 微服的标准的参考架构。</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_6.png" alt="" /></p>

<p>业务中台和技术中台 统称为大中台。支撑业务前台。中台越强大，前台越发展越快。</p>

<p>PaaS 和 核心业务层是和微服务相关的。这一些基本都可以用微服务来实现。</p>

<p>IaaS：Infrastructure-as-a-Service（基础设施即服务）</p>

<p>PaaS：Platform-as-a-Service（平台即服务）</p>

<h2 id="7-如何给出一个清晰简洁的服务分层方式">7 如何给出一个清晰简洁的服务分层方式</h2>
<hr />

<p>大致的服务分层图：</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_7.png" alt="" /></p>

<p>SOA  Service-Oriented Architecture  （面向服务的架构）</p>

<p>基础服务：　也有其他的说法。如：核心领域服务、中间层服务、公共服务。</p>

<p>聚合服务：　对基础服务的聚全和裁剪，以达到满足业务的需求，提供给外部调用。　</p>

<h2 id="８微服务总体技术架构体系是怎么设计的">８　微服务总体技术架构体系是怎么设计的</h2>
<hr />

<p>微服务总体架构体系图：</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_8.png" alt="" /></p>

<ul>
  <li>接入层：　外部和内部接入，主要把流量接入进来，做负载均衡。</li>
  <li>网关层：　反向路由，限流，安全，跨横切面的功能。　　</li>
  <li>业务服务层：　可分为：聚合服务，基础服务。</li>
  <li>支撑服务： 后台服务。</li>
  <li>平台服务： 可以是一些管理系统。</li>
  <li>基础设施　由运维团队运维。　</li>
</ul>

<p>网关层、业务服务层、支撑服务、平台服务。 这四层可以和微服务相关的，</p>

<h2 id="9-微服务最经典的三种服务发现机制">9 微服务最经典的三种服务发现机制</h2>
<hr />

<p>消息者应该怎么去发现生产者。三者主流的模式：</p>

<p>1 通过DNS 访问LB，LB（负载均衡）。</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_9_1.png" alt="" /></p>

<p>2 　LB功能放到Consumer内， service 注册到 Service Registry上。有定时心跳发到注册中收，Consumer  定期的同步 Service Registry的信息。</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_9_2.png" alt="" /></p>

<p>3 结全前面两种方式， 在Consumer的主机上也布置一个LB。 LB会定期同步Service Registry的信息。 运维成本比较高一点。</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_9_3.png" alt="" /></p>

<h2 id="10-微服务-api-服务网关一原理">10 微服务 API 服务网关（一）原理</h2>
<hr />

<p>API　Gateway</p>

<p>屏蔽掉服务内部的逻辑，希望外部访问看到是统一的接口。</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_10_1.png" alt="" /></p>

<p>下面这个图 接入网关的前面有一层LB（负载均衡）如果是网关可以是无状态的，这样方便扩展，单点挂掉时，可以摘除。对系统的稳定性很重要。</p>

<h5 id="网关主要的功能">网关主要的功能</h5>
<ul>
  <li>反向路由  将外部的请求换成内部调用。</li>
  <li>认证安全 防刷 防爬虫。</li>
  <li>限流熔断 处理可能会突发流量。</li>
  <li>日志监控  进行访问访问审计，监控流量。</li>
</ul>

<p>一般不要把过多的业务逻辑写在网关当中。</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_10_2.png" alt="" /></p>

<h2 id="11-服务-api-服务网关二开源网关-zuul">11 服务 API 服务网关（二）开源网关 Zuul</h2>
<hr />

<p>核心:  Servlet 和 Fitter Runner 
过滤器：  前置过滤器，  路由过滤器，后置过滤器</p>

<p>过滤器开发，可以通过脚本开发。开发完后上传到过滤器目录中， 被扫描后加到Filtter Runner中。</p>

<p>各个Fitte 共享数据通过 Request Context 来实现。</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_11_1.png" alt="" /></p>

<p>过滤链的流程：</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_11_2.png" alt="" /></p>

<p>前置路由过滤器</p>

<p>路由过滤器</p>

<p>后置路由过滤器</p>

<h2 id="12-跟-netflix-学习微服务路由发现体系">12 跟 Netflix 学习微服务路由发现体系</h2>
<hr />

<p>netflix 有两个比较重要的支撑服务</p>

<ul>
  <li>服务注册中心  Eureka</li>
  <li>网关 zuul</li>
</ul>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_12.png" alt="" /></p>

<h2 id="13-集中式配置中心的作用和原理是什么">13 集中式配置中心的作用和原理是什么</h2>
<hr />

<p>为什么要引入配置中心呢？
　
小企业一般是写在配置文件中的，不方便管理。响应比较慢。无法审计。配置中心可能解决这些问题。</p>

<p>什么可做配置呢？</p>

<ul>
  <li>业务开关</li>
  <li>调用/响应超时</li>
  <li>限流</li>
  <li>连接字符串</li>
  <li>动态参数</li>
</ul>

<p>Svr 更新配置有两种方式 拉和推。</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_13_1.png" alt="" /></p>

<p>携程的Apollo配置中心:</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_13_2.png" alt="" /></p>

<p>github : https://github.com/ctripcorp/apollo</p>

<h2 id="14-微服务通讯方式-rpc-vs-rest">14 微服务通讯方式 RPC vs REST</h2>
<hr />
<p>RPC：Remote Procedure Call 远程过程调用</p>

<p>REST ：Restful</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_14.png" alt="" /></p>

<h2 id="15-微服务框架需要考虑哪些治理环节">15 微服务框架需要考虑哪些治理环节</h2>
<hr />

<p>一个公司的微服务多了，就要需要考虑治理。</p>

<p>软负载： 蓝绿发布， 灰度发布</p>

<p>Metrics: 服务的调用量， 耗时监控。</p>

<p>调用链埋点： 方便快速定位问题，</p>

<p>契约生成代码： 定义结构体可自动生成json格式， vscode 有插件。</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_15.png" alt="" /></p>

<p>阿里巴巴微服务治理生态：Dubbo 	http://dubbo.apache.org/en-us/</p>

<h2 id="16-微服务监控系统分层和监控架构">16 微服务监控系统分层和监控架构</h2>
<hr />

<p>五个层次的监控</p>

<ul>
  <li>基础设施监控</li>
  <li>系统层监控</li>
  <li>应用层监控 url sevice mysql cache 可用率，性能， qps</li>
  <li>业务层监控 核心指标监控 登录注册</li>
  <li>端用户体验监控</li>
</ul>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_16_1.png" alt="" /></p>

<p>日志 监控  对应Elasticsearch<br />
metrics 监控
健康检查
调用链监控
告警系统</p>

<p>比较典型的监控架构，大部分公司的流程</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_16_2.png" alt="" /></p>

<p>比较大的队列用kafka 。</p>

<p>Nagios 健康检测工具。</p>

<p>ELK　ELK是Elasticsearch、Logstash、Kibana三大开源框架首字母大写简称。</p>

<h2 id="17-微服务的调用链监控该如何选型">17 微服务的调用链监控该如何选型</h2>
<hr />

<p>调用链的监控　谷歌2010年提出来的。　</p>

<p>通过 Span来跟踪， RootSpan  ChildSpan  跨进程时  会有Trace di + parant span id</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_17_1.png" alt="" /></p>

<p>三个主流调用链监控系统的比较：</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_17_2.png" alt="" /></p>

<h2 id="18-微服务的容错限流是如何工作的">18 微服务的容错限流是如何工作的</h2>
<hr />

<p>Netfiix  Hystrix 具有熔断 隔离 限流 降级的功能 。</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_18.png" alt="" /></p>

<p>说明：</p>

<ul>
  <li>3 Cirult OPen 判断是否可以熔断， 是则执行 getFAllBack() 降级处理函数</li>
  <li>5 run() 超时 也执行降级处理函数。</li>
  <li>6 不成功也 执行处理函数 。</li>
  <li>Calculate Cirult Health 就是在正常执行成功后计算是否需要熔断。</li>
</ul>

<h2 id="19-docker-容器部署技术--持续交付流水线">19 Docker 容器部署技术 &amp; 持续交付流水线</h2>
<hr />

<p>docker 容器治理就是解决：环境不一致的问题。把依赖的所有包都打在镜像中。</p>

<p>统一、标准化的交付流水线。</p>

<p>UAT 环境： User Acceptance Test （用户验收测试）</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_19_1.png" alt="" /></p>

<p>发布模式： 蓝绿布置，灰度发布（金丝雀发布）。</p>

<p>金丝雀发布 滚动发布：</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_19_2.png" alt="" /></p>

<h2 id="20-容器集群调度和基于容器的发布体系">20 容器集群调度和基于容器的发布体系</h2>
<hr />

<p>资源调度框架 Mesos 架构</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_20_1.png" alt="" /></p>

<p>基于容器的云发布体系</p>

<p><img src="../../assets/time-geekbang-microservice-core20/micro_server_20_2.png" alt="" /></p>

]]></content:encoded>
    </item>
    
  </channel>
</rss>
