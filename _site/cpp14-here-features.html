<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>c++ 14 新特性</title>

    <meta name="viewport" content="width=device-width">
    <meta name="description" content="">

    
    

    <link rel="canonical" href="http://localhost:4000/cpp14-here-features">
    <link rel="icon" type="image/png" href="/images/logo.png">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/monster.css">

    

</head>


    <body>
    
    <div class="wrapper">

      <header class="header">

  <div class="site-title">
    
    <h4 class="entry-title"><a href="/cpp14-here-features">c++ 14 新特性</a></h4>
    
  </div>

<div class="links">
    
    <a href="/" class="page-link">Blog</a>
    
    
    
    
      <a class="page-link"
        href="/about/">About</a>
    
    
    
      <a class="page-link"
        href="/categories">Categories</a>
    
    
    
    
    
    
    
      <a class="page-link"
        href="/links/">Links</a>
    
    
    
    
    
      <a class="page-link"
        href="/tags">Tags</a>
    
    
    <a href="/feed.xml" target="_blank" class="page-link">RSS</a>
</div>
</header>

      
      <div class="navi">
    
    <a href="/" class="page-link">Blog</a>
    
    
    
    
      <a class="page-link"
        href="/about/">About</a>
    
    
    
      <a class="page-link"
        href="/categories">Categories</a>
    
    
    
    
    
    
    
      <a class="page-link"
        href="/links/">Links</a>
    
    
    
    
    
      <a class="page-link"
        href="/tags">Tags</a>
    
    
    <a href="/feed.xml" target="_blank" class="page-link">RSS</a>
</div>


      <div class="content">
        <div class="articles">
            <div class="article-meta">
    2021-01-04
     • Category: 
        
        <a href="/categories//#编程语言-ref" >编程语言</a>
        
    
     • Tag: 
        
            <a href="/tags//#c++-ref" >C++</a>
        
            <a href="/tags//#c-ref" >C</a>
        
            <a href="/tags//#技术笔记-ref" >技术笔记</a>
        
    
</div>

<div class="entry post">

	<div class="entry-content">
	  <article class="entry-body">
	  	
	  		<p>C++14 这一继 C++11 之后的新的 C++ 标准。是一个小版本。</p>

<p>C++14 新特性主要体现在三个领域：Lambda 函数、constexpr 和类型推导。</p>

<p><img src="/assets/programming-language/c-plus-plus-14-2022-11-21_11-34-12.png" alt="" /></p>

<h1 id="lambda-函数">Lambda 函数</h1>

<p>C++14 的 Lambda 函数可以使用推导类型声明。如：</p>

<p>```c++ 14</p>

<p>auto lambda = <a href="auto a, auto b"></a> {return a + b;};</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
而 C++ 11 的 Lambda 函数使用的是具体的类型声明，如

```c++

auto lambda = [](int a, int b) {return a + b;};

</code></pre></div></div>

<h1 id="constexpr">constexpr</h1>

<p>c++11 关于constexpr 的特性可以看： <a href="http://blog.xyecho.com/c++11-constexpr/">c++11  constexpr</a></p>

<p>在 C++11 中，使用 constexpr 声明的函数可以在编译时执行，生成一个值，用在需要常量表达式的地方，比如作为初始化模板的整形参数。C++11 的 constexpr 函数只能包含一个表达式，C++14 放松了这些限制，支持诸如 if 和 switch 等条件语句，支持循环，其中包括基于区间（range）的 for 循环。</p>

<p>如：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// C++11中不可，C++14中可以</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="类型推导">类型推导</h1>

<p>C++11 仅支持 Lambda 函数的类型推导，C++14 对其加以扩展，支持所有函数的返回类型推导：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">auto</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">func</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>也可以模板中使用 <code class="language-plaintext highlighter-rouge">auto</code>  如：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">auto</span> <span class="nf">func</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">func</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">func</span><span class="p">(</span><span class="mf">3.4</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">auto</code>  做为函数的返回值要注意的地方：</p>

<p>1、函数如果有多个return，返回的类型必须是相同的，否则编译失败。</p>

<p>2、如果return语句返回初始化列表，返回值类型推导也会失败。</p>

<p>3、如果函数是虚函数，不能使用返回值类型推导。</p>

<p>4、返回类型推导可以用在前向声明中，但是在使用它们之前，翻译单元中必须能够得到函数定义。</p>

<p>5、返回类型推导可以用在递归函数中，但是递归调用必须以至少一个返回语句作为先导，以便编译器推导出返回类型。</p>

<h1 id="二进制字面量与整形字面量分隔符">二进制字面量与整形字面量分隔符</h1>

<p>C++14引入了二进制字面量，也引入了分隔符</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mb">0b0001'0011'1010</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">3.14'1234'1234'1234</span><span class="p">;</span>
</code></pre></div></div>

<h1 id="deprecated-标记">[[deprecated]] 标记</h1>

<p>C++14 中增加了deprecated标记，修饰类、变、函数等，当程序中使用到了被其修饰的代码时，编译时被产生警告，用户提示开发者该标记修饰的内容将来可能会被丢弃，尽量不要使用。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="p">[[</span><span class="n">deprecated</span><span class="p">]]</span> <span class="n">A</span> <span class="p">{</span> <span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
	
</code></pre></div></div>

<h1 id="stdmake_unique">std::make_unique</h1>

<p>C++11中有std::make_shared，却没有std::make_unique，在C++14 添加上了。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">A</span> <span class="p">{};</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div></div>

<h1 id="其他">其他</h1>

<p>1、<code class="language-plaintext highlighter-rouge">std::shared_timed_mutex</code> 和 <code class="language-plaintext highlighter-rouge">std::shared_lock</code> 来实现读写锁，保证多个线程可以同时读，但是写线程必须独立运行，写操作不可以同时和读操作一起进行。</p>

<p>2、<code class="language-plaintext highlighter-rouge">std::integer_sequence</code></p>

<p>3、<code class="language-plaintext highlighter-rouge">std::exchange</code> 和 <code class="language-plaintext highlighter-rouge">stl</code> 的 <code class="language-plaintext highlighter-rouge">std::swap</code> 类似。不同的是 <code class="language-plaintext highlighter-rouge">std::swap</code> 是交换，而 <code class="language-plaintext highlighter-rouge">std::exchange</code> 是把后面的值赋给前面的，同时把旧值返回。</p>

<p>4、<code class="language-plaintext highlighter-rouge">std::quoted</code> 用于给字符串添加双引号。</p>

<hr />
<p>reference :</p>

<p>1、<a href="https://www.infoq.cn/article/2014/09/cpp14-here-features">C++14 新特性总结</a></p>

<p>2、<a href="https://segmentfault.com/a/1190000023441427">C++14新特性的所有知识点全在这儿啦！</a></p>

<p>3、 <a href="https://stackoverflow.com/questions/17424477/implementation-c14-make-integer-sequence">Implementation C++14 make_integer_sequence</a></p>

  		
	  </article>
    </div>

</div>





	<div class="article-author">
    <div class="avatar">
    <img width="50" height="50" src="/images/header.png" alt=" Avatar"/>
    </div>
    <div class="name">
        <h4><b>carlos</b> </h4>
        Just for fun!
    </div>
</div>


	<!--
	
	    <!--
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = '';
	(function() {
	    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	    dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
	    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
 -->
	
    -->


<!--
<div class="cnzz"><script src="http://s4.cnzz.com/z_stat.php?id=1255123325&web_id=1255123325" language="JavaScript"></script> </div>
 -->

        </div>
      </div>
    </div>

    </body>
</html>
