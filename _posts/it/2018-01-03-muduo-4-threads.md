---
layout: post
title: muduo笔记 第四章 c++多线程系统编程精要
date: 2018-01-03 20:08:12
categories: muduo
tags:  技术学习笔记  系统编程 muduo 
excerpt: 多线程系统编程精要
---

学习多线程编程面临的最大的思维方式的转变有两点：

- 当前线程可能随时会被切换出去，或者说被抢占（preempt）了。 
- 多线程程序中事件的发生顺序不再有全局统一的先后关系 。

# 基本线程原语的选用

`POSIX threads ` 的函数有 110 多个，真正常用的不过十几个。而且在 C++ 程序中通常会有更为易用的 wrapper，不会直接调用 Pthreads 函数。这 11 个最基本的Pthreads函数是： 
 
- 2个：线程的创建和等待结束（join）。封装为 `muduo::Thread`。 
- 4个：`mutex` 的创建、销毁、加锁、解锁。封装为 `muduo::MutexLock`。
- 5个：条件变量的创建、销毁、等待、通知、广播。封装为 `muduo::Condition`。

这些封装 class 都很直截了当，加起来也就一两百行代码，却已经构成了多线程编程的全部必备原语。用这三样东西（`thread`、`mutex`、`condition`）可以完成任何多线程编程任务。

# c/c++ 系统库的线程安全性

c++11 宣言了一个线程库。（std::thread）
对于标准而言，关键的不是定义线程库，而是规定 内存模型（memory model）。特别是规定一个线程对某个共享变量的修改何时能被其他线程看到，这称为内存序（memory ordering）或者内存能见度（memory visibility）。

** 这句话有三个名词：内存模型，内存有序，内存能见度。可以查找这方面的资料。**

编写线程安全程序的一个难点在于线程安全是不可组合的（ `composable` ），一个函数 `foo()` 用了两个线程安全的函数，而这个foo() 函数本身很可能不是线程安全的。即便现在大多数 `glibc` 库函数是线程安全的，我们也不能像写单线程程序那样编写代码。

C++ 的标准库容器和 `std::string` 都不是线程安全的，只有 `std::allocator` 保证是线程安全的。一方面的原因是为了避免不必要的性能开销，另一方面的原因是单个成员函数的线程安全并不具备可组合性（composable）

# Linux 上的线程标识

`pthread_t` 并不适合用作程序中对线程的标识符。 `pthread_t` 不一定是一个数值类型（整数或指针），也有可能是一个结构体

无法打印输出 `pthread_t` ，因为不知道其确切类型。也就没法在日志中用它表示当前线程的 id。

无法比较 `pthread_t` 的大小或计算其 hash 值，因此无法用作关联容器的 key。 

无法定义一个非法的 `pthread_t` 值，用来表示绝对不可能存在的线程 id，因此 `MutexLock class` 没有办法有效判断当前线程是否已经持有本锁。

`pthread_t` 值只在进程内有意义，与操作系统的任务调度之间无法建立有效关联。比方说在 /proc 文件系统中找不到 `pthread_t` 对应的 `task`。

在 Linux 上，我建议使用 `gettid(2)` 系统调用的返回值作为线程id，这么做的好处有： 

它的类型是 `pid_t`，其值通常是一个小整数，便于在日志中输出。 

在现代 `Linux` 中，它直接表示内核的任务调度 id，因此在 /proc 文件系统中可以轻易找到对应项：`/proc/tid` 或 `/prod/pid/task/tid`。 

在其他系统工具中也容易定位到具体某一个线程，例如在 `top(1)` 中我们可以按线程列出任务，然后找出CPU使用率最高的线程id，再根据程序日志判断到底哪一个线程在耗用 CPU。

任何时刻都是全局唯一的，并且由于 Linux 分配新 `pid` 采用递增轮回办法，短时间内启动的多个线程也会具有不同的线程id。

0是非法值，因为操作系统第一个进程 `init` 的 `pid` 是 1。


# 线程的创建与销毁的守则 

线程的创建比销毁要容易得多，只需要遵循几条简单的原则：

- 程序库不应该在未提前告知的情况下创建自己的“背景线程”。
- 尽量用相同的方式创建线程，例如muduo::Thread。
- 在进入main()函数之前不应该启动线程。 程序中线程的创建最好能在初始化阶段全部完成。（C++保证在进入main()之前完成全局对象 ）

# 线程的销毁有几种方式  

- 自然死亡。从线程主函数返回，线程正常退出。 
- 非正常死亡。从线程主函数抛出异常或线程触发segfault信号等非法操作 。 
- 自杀。在线程中调用pthread_exit()来立刻退出线程。 
- 他杀。其他线程调用pthread_cancel()来强制终止某个线程。


# 善用 __thread 关键字

`__thread` 使用规则27：只能用于修饰 `POD` 类型，不能修饰 `class` 类型， 因为无法自动调用构造函数和析构函数。 `__thread` 可以用于修饰全局变量、函数内的静态变量，但是不能用于修饰函数的局部变量或者 `class` 的普通成员变量。另外， `__thread` 变量的初始化只能用编译期常量。 

例如： 

```c
__thread string t_obj1("Chen Shou");    // 错误 不能对象的构造函数
__thread string * t_obj2= new string;   // 错误 初始化必须用编译期常量
__thread string * t_obj3= NULL;         // 正常 但是需要手工初始化并销毁对象

```
`__thread` 变量是每个线程有一份独立实体，各个线程的变量值互不干扰。除了这个主要用途， 它还可以修饰那些"值可能会变，带有全局性，但是又不值得用全局锁保护"的变量。muduo代码中用到了 好几处 `__thread` ，简单列举如下：

 - muduo/base/Logging.cc 缓存最近一条日志时间的年月日时分秒，如果一秒之内输出多条日志，可避免重复格式化。另外，muduo::strerror_tl把strerror_r(3)做成如同strerror(3)一样好用，而且是线程安全的。 
 - muduo/base/ProcessINfo.cc 用线程局部变量来简化`::scandir(3)`的使用。
 - muduo/base/Thread.cc 缓存每个线程的id。 
 - 用于判断当前线程是否只有一个EventLoop对象。

# 多线程 与 IO

为了简单起见，我认为多线程程序应该遵循的原则是：每个文件描述符只由一个线程操作，从而轻松解决消息收发的顺序性问题，也避免了关闭文件描述符的各种 `race condition`。 一个线程可以操作多个文件描述符， 但一个线程不能操作别的线程拥有的文件描述符。 这一点不难做到， `muduo` 网络库已经把这些细节封装了。


# RAII 与 fork()

通常我们会用 RAII 手法来管理以上种类的资源(加锁解锁、创建销毁定时器等等).

但是在 fork() 出来的子进程中不一定正常工作，因为资源在 fork() 时已经被释放了。比方说用 RAII 技法封装 `timer_create()` /`timer_delete()`，在子进程中析构函数调用timer_delete()可能会出错。

因为试图释放一个不存在的资源。或者更糟糕地把其他对象持有的 `timer` 给释放了（如果碰巧新建的 `timer_t` 与之重复的话）。

#  多线程与 fork()

`fork()` 是单线程的产物。当有了多线程之后，`fork()` 就变得有一些不适应了。

`fork()` 一般不能在多线程程序中调用 ，因为 Linux 的 fork() 只克隆当前线程的 `thread of control`，不克隆其他线程。

`fork()` 之后，除了当前线程之外，其他线程都消失了。也就是说不能一下子 fork() 出一个和父进程一样的多线程子进程。

Linux 没有 forkall() 这样的系统调用，forkall() 其实也是很难办的（从语意上），因为其他线程可能等在 condition。

所以最好不要在多线程当中调用 fork(), 除非你调用后马上调用 exec()。彻底断了子进程和父进程的关系。

# 多线程与 signal

在多线程程序中， 使用signal的第一原则是不要使用 signal。

关于多线程与signal关系。可以看[linux signal and threads](http://blog.xyecho.com/linux-signal/)


---
1、《Linux多线程服务端编程：使用muduo C++ 网络库》 陈硕. 电子工业出版社. Kindle 版本.











