---
layout: post
title: c++ 内存分配
date: 2017-04-10 17:12:15
categories: c++
tags: c++  
excerpt: c++ 内存一共被分为5个区：栈区、堆区、BSS、数据区、代码区
---

### 一共被分为5个区：

1、 **栈区** （stack） 从高地址向低地址增长。由编译器自动管理分配。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 

2、**堆区** （heap）动态内存分配。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多，存在忘记释放导致内存泄漏。

3、**BSS** 存放**未初始化**的全局和静态变量。（默认设为0）

4、**数据区** （Data Segment） 存放已初始化的全局和静态变量， 常量数据（如字符串常量）。

5、**代码区（Code Segment）** 也称Text Segment，存放可执行程序的机器码。


![](./assets/programming-language/cplusplus-memory-2022-12-13_21-49-22.png)


### new 和 malloc

1、`new` 和 `malloc` 如何判断是否申请到内存？

- `malloc` ：成功申请到内存，返回指向该内存的指针；分配失败，返回 NULL 指针。
- `new` ：内存分配成功，返回该对象类型的指针；分配失败，抛出 bad_alloc 异常。

可以使用 `std::nothrow` 让 `new` 在申请内存失败时也同 `malloc`  一样返回 `NULL` 指针，而不是抛出 `std::bad_alloc`   异常。

```c++
A *a = new (std::nothrow) A();
if (a == nullptr) {
    // add logs here
    return false;
}
```

2、 `delete` 实现原理？`delete` 和 `delete[]` 的区别？

`delete` 的实现原理：首先执行该对象所属类的析构函数；进而通过调用 `operator delete` 的标准库函数来释放所占的内存空间。

`delete` 和 `delete []` 的区别：
- `delete` 用来释放单个对象所占的空间，只会调用一次析构函数；
- `delete []` 用来释放数组空间，会对数组中的每个成员都调用一次析构函数。
		
对于像 `int` 、`char` 、`long`  、`int*` 等等简单数据类型，由于对象没有析构函数，所以用 `delete` 和 `delete []` 是一样的！都不会造成内存泄露！ 但通常为了规范起见，`new []`都配套使用 `delete []`。

但是如果是 C++ 自定义对象数组就不同了！由于 `delete p` 只调用了一次析构函数，剩余的对象不会调用析构函数，所以剩余对象中如果有申请了新的内存或者其他系统资源，那么这部分内存和资源就无法被释放掉了，因此会造成内存泄露或者更严重的问题。

3、`new` 和 `malloc` 的区别，`delete` 和 `free `的区别

- `malloc`、`free` 是库函数，而 `new`、`delete` 是关键字。
- `new` 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；`malloc` 在申请空间时，需要确定所申请空间的大小。
- `new` 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；`malloc` 申请空间时，返回的是 `void*` 类型，需要进行强制类型的转换，转换为对象类型的指针。
- `new` 分配失败时，会抛出 `bad_alloc` 异常，`malloc` 分配失败时返回空指针。
- 对于自定义的类型，`new `首先调用 `operator new()` 函数申请空间（底层通过 `malloc` 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；
- `delete` 首先调用析构函数，然后调用 `operator delete()` 释放空间（底层通过 `free` 实现）。`malloc`、`free` 无法进行自定义类型的对象的构造和析构。
- `new` 操作符从自由存储区上为对象动态分配内存，而 `malloc` 函数从堆上动态分配内存。（自由存储区不等于堆）

**这里的自由存储区应该怎么理解？** 

[C++ 自由存储区是否等价于堆？](https://cloud.tencent.com/developer/article/1155154)

从技术上来说，堆（heap）是 C 语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用 `malloc()` 时就会从中分配，稍后调用`free()`可把内存交还。

而自由存储是 C++ 中通过 `new()`和 `delete()` 动态分配和释放对象的抽象概念，通过`new()` 来申请的内存区域可称为自由存储区。基本上，所有的 C++ 编译器默认使用堆来实现自由存储，也即是缺省的全局运算符 `new()` 和 `delete()` 也许会按照`malloc()` 和 `free()` 的方式来被实现，这时藉由 `new()` 运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。我们所需要记住的就是：

**堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。**

4、malloc 的底层实现？

**malloc 的原理:**

当开辟的空间小于 128K 时，调用 `brk()` 函数，通过移动 `_enddata` 来实现；当开辟空间大于 128K 时，调用 `mmap() `函数，通过在虚拟地址空间中开辟一块内存空间来实现。

`brk()` 函数实现原理：向高地址的方向移动指向数据段的高地址的指针 `_enddata。`

`mmap()` 内存映射原理：

进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域；

调用内核空间的系统调用函数` mmap()`，实现文件物理地址和进程虚拟地址的一一映射关系；进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝。


**内存分配的原理**

从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：`brk()` 和 `mmap()`（不考虑共享内存）。

1、`brk()` 是将数据段(`.data`)的最高地址指针`_edata`往高地址推；

2、`mmap()` 是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。

这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。

在标准C库中，提供了`malloc/free` 函数分配释放内存，这两个函数底层是由 `brk，mmap，munmap` 这些系统调用实现的。


----
参考：

1、[深度阅读：深入 C++ 内存管理](https://zhuanlan.zhihu.com/p/344377490)

2、[C++ 自由存储区是否等价于堆？](https://cloud.tencent.com/developer/article/1155154)
    