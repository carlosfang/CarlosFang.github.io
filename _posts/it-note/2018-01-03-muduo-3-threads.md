---
layout: post
title: muduo笔记 第三章 多线程服务器的适用场合与常用编程模型
date: 2018-01-03 19:08:12
categories: Linux muduo
tags: 技术阅读笔记 系统编程 muduo笔记 tcp network thread
excerpt: 线程同步的要点
---


"网络应用程序" 的基本功能可以简单归纳为"收到数据，算一算，再发出去"。

#### 单线程服务器的常用编程模型

在高性能的网络程序中，使用得最为广泛的是“non-blocking IO＋IO multiplexing”这种模型，即Reactor模式。

- lighttpd，单线程服务器。（Nginx与之类似，每个工作进程有一个event loop。）
- libevent，libev。 
- ACE，Poco C++ libraries。 
- Java NIO，包括Apache Mina和Netty。
- POE（Perl）。 
- Twisted（Python）。

在"non-blocking IO＋IO multiplexing"这种模型中，程序的基本结构是一个事件循环（event loop），以事件驱动（event-driven）和事件回调的方式实现业务逻辑：

![](/assets/muduo/3-threads.png) 

**gethostbyname(3)是阻塞的，对陌生域名解析的耗时可长达数秒。**

基于事件驱动的编程模型也有其本质的缺点，它要求事件回调函数必须是非阻塞的。对于涉及网络IO的请求响应式协议，它容易割裂业务逻辑，使其散布于多个回调函数之中，相对不容易理解和维护。现代的语言有一些应对方法（例如coroutine 协程），但是本书只关注C++这种传统语言，因此就不展开讨论了。**[后继可以看看协程方面技术和GO的]**

#### 多线程服务器的常用编程模型

##### 1 One loop per thread

此种模型下，程序里的每个IO线程有一个event loop（或者叫Reactor），用于处理读写和定时事件（无论周期性的还是单次的）。

这种方式的好处是： 

- 线程数目基本固定，可以在程序启动的时候设置，不会频繁创建与销毁。
- 可以很方便地在线程间调配负载。
- IO事件发生的线程是固定的，同一个TCP连接不必考虑事件并发。

##### 2 线程池

##### 3 推荐的服务模式

推荐的C++多线程服务端编程模式为：one (event) loop per thread+ thread pool。

##### 4 进程间通信只用TCP 

Linux下进程间通信（IPC）的方式数不胜数，有：匿名管道（pipe）、具名管道（FIFO）、POSIX消息队列、共享内存、信号（signals），Sockets。其实贵精不贵多，认真用熟其中几种就可以。之所以选择socket是因为它可以跨主机，具有伸缩性。另外：

1.程序上意外退出， 不会组系统留下垃圾，程序重启之后比较容易地恢复。

2.port是独占，可以防止程序重复启动，避免造成意料之外的结果。

3.当一个进程崩溃了，操作系统会关闭连接，另一个进程可立刻感知。，可快速处理。（有心跳的情况）

4.还可以跨语言。

5.会涉及用字节流方式通信。会有marshal/unmarshal的开销。

6.用tcp的好处。容易定位分布式系统中的服务之前的依赖关系，`netstat -tpna | grep :port` 二通过接收和发送队列的长度也较容易定位网络 或程序故障。

在正常运行的时候，netstat打印的Recv-Q和Send-Q都应该接近0，或者在0附近摆动。

如果Recv-Q保持不变或持续增加，则通常意味着服务进程的处理速度变慢，可能发生了死锁或阻塞。

如果Send-Q保持不变或持续增加，有可能是对方服务器太忙、来不及处理，也有可能是网络中间某个路由器或交换机故障造成丢包，甚至对方服务器掉线，

这些因素都可能表现为数据发送不出去。通过持续监控Recv-Q和Send-Q就能及早预警性能或可用性故障。以下是服务端线程阻塞造成Recv-Q和客户端Send-Q激增的例子。


#### 多线程服务的适用应用

开发服务端程序的一个基本任务是处理并发连接，现在服务端网络编程处理并发连接主要有两种方式： 

当"线程"很廉价时，一台机器上可以创建远高于CPU数目的"线程"。这时一个线程只处理一个TCP连接（甚至半个），通常使用阻塞IO（至少看起来如此）。例如，Python gevent、Go goroutine、

Erlang actor。这里的"线程"由语言的runtime自行调度，与操作系统线程不是一回事。（也就是说协程做并发是可以用阻塞IO的）

当线程很宝贵时，一台机器上只能创建与CPU数目相当的线程。这时一个线程要处理多个TCP连接上的IO，通常使用非阻塞IO和IO multiplexing。例如，libevent、muduo、Netty。这是原生线程，能被操作系统的任务调度器看见。 

#### 必须用单线程的场合

有两种场合必须使用单线程：

- 程序可能会fork
- 限制程序的CPU占用率

##### 单线程程序的优缺点：

单线程程序的优势：简单。程序的结构一般可是一个基于IO multiplexing的event loop。或者直接用阻塞IO。event loop也有一个明显的缺点：非抢占的。

多线程没有什么绝对意义上的性能优势。 这句话是说，如果用很少的CPU负载就能让IO跑满，或者用很少的IO流量就能让CPU跑满，那么多线程没啥用处。

多线程的适用场景是：提高响应速度，让IO和"计算"相互重叠，降低latency。虽然多线程不能提高绝对性能，但能提高平均响应性能。

#### 线程的分类 

一个多线程服务程序中的线程大致可分为3类： 

1.IO线程，这类线程的主循环是IO multiplexing，阻塞地等在select/poll/epoll_wait系统调用上。这类线程也处理定时事件。当然它的功能不止IO，有些简单计算也可以放入其中，比如消息的编码或解码。

2.计算线程，这类线程的主循环是blockingqueue，阻塞地等在conditionvariable上。这类线程一般位于thread pool中。这种线程通常不涉及IO，一般要避免任何阻塞操作。 

3.第三方库所用的线程，比如logging，又比如database connection。

#### Linux 能同时启动多少个线程

---
 \--- 《Linux多线程服务端编程：使用muduo C++ 网络库》 陈硕. 电子工业出版社. Kindle 版本.