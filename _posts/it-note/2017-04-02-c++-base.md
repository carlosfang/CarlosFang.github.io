---
layout: post
title: c++ 基础知识
date: 2017-04-02 16:12:15
categories: c++ 
tags: c++  
excerpt: c++ 常遇到的基础问题  
---


# 一 变量

## 1.1  全局变量

具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量。

## 1.2 局部变量 

具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。

## 1.3 静态全局变量

有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。
一般被分配在到栈中。

-   静态存储区：全局变量，静态局部变量，静态全局变量。
-   栈：局部变量。
-   静态变量和全局变量的区别：静态变量用 `static` 告知编译器，自己仅仅在变量的作用范围内可见。

如果在头文件中定义全局变量，当该头文件被多个文件 `include` 时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能在头文件中定义全局变量。

这个重复定义是在链接时就报错误的。

在头文件中定义全局变量即使用 `#ifndef`  是解决同一个 cpp 文件 include 多次头文件。而不是多个 cpp 文件 include 同一个应文件。 

## 1.4 几种制类型转换

**static_cast**：用于数据的强制类型转换，强制将一种数据类型转换为另一种数据类型。

用于基本数据类型的转换： 

1、  用于类层次之间的基类和派生类之间 指针或者引用 的转换（不要求必须包含虚函数，但必须是有相互联系的类），进行上行转换（派生类的指针或引用转换成基类表示）是安全的；进行下行转换（基类的指针或引用转换成派生类表示）由于没有动态类型检查，所以是不安全的，最好用 dynamic_cast 进行下行转换。

2、 可以将空指针转化成目标类型的空指针。

3、 可以将任何类型的表达式转化成 void 类型。

4、 **const_cast**：强制去掉常量属性，不能用于去掉变量的常量性，只能用于去除指针或引用的常量性，将常量指针转化为非常量指针或者将常量引用转化为非常量引用（注意：表达式的类型和要转化的类型是相同的）。

**reinterpret_cast**：改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转化为指针或引用类型。

 **dynamic_cast**：

1、 其他三种都是编译时完成的，动态类型转换是在程序运行时处理的，运行时会进行类型检查。

2、 只能用于带有虚函数的基类或派生类的指针或者引用对象的转换，转换成功返回指向类型的指针或引用，转换失败返回 NULL；不能用于基本数据类型的转换。

3、 在向上进行转换时，即派生类类的指针转换成基类类的指针和 static_cast 效果是一样的，（注意：这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）。

4、在下行转换时，基类的指针类型转化为派生类类的指针类型，只有当要转换的指针指向的对象类型和转化以后的对象类型相同时，才会转化成功。

## 1.5  参数传递时，值传递、引用传递、指针传递的区别

参数传递的三种方式：

1、 值传递：形参是实参的拷贝，函数对形参的所有操作不会影响实参。

2、 指针传递：本质上是值传递，只不过拷贝的是指针的值，拷贝之后，实参和形参是不同的指针，通过指针可以间接的访问指针所指向的对象，从而可以修改它所指对象的值。

3、 引用传递：当形参是引用类型时，我们说它对应的实参被引用传递。


# 二 c++11 的新特性

## 2.1  `auto` 自动类型推导
如： 
```c++ 
auto var = a + b ; 

for (auto item : list){

}
```


## 2.2 `decltype` 类型推导

和 auto 的功能一样，都用来在编译时期进行自动类型推导。如果希望从表达式中推断出要定义的变量的类型，但是不想用该表达式的值初始化变量，这时就不能再用 auto。decltype 作用是选择并返回操作数的数据类型。

```c++
auto var = a + b; 
decltype(a + b) var = 0;
```

## 2.3 `lambda` 表达式 

`lambda` 函数或者 `lambda` 匿名函数。
```c++
// 表达式：
// capture list：捕获列表，指 lambda 所在函数中定义的局部变量的列表，通常为空。
// return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。


[capture list] (parameter list) -> return type
{ 
	function body; 
};

// 例子

#include <iostream>
#include <algorithm>
using namespace std;

int main()
{
    int arr[4] = {4, 2, 3, 1};
    //对 a 数组中的元素进行升序排序
    sort(arr, arr+4, [=](int x, int y) -> bool{ return x < y; } );
    for(int n : arr){
        cout << n << " ";
    }
    return 0;
}

```

用来捕获上下文或者作用域中变量到lamda表达式函数体中使用，［=］意思是全部按值捕获变量，[&]全部按引用捕获变量。 

## 2.4 范围 `for` 语句
```c++ 
// 表达式：
// expression：必须是一个序列，例如用花括号括起来的初始值列表、数组、vector ，string 等，
// 这些类型的共同特点是拥有能返回迭代器的 beign、end 成员。
// declaration：此处定义一个变量，序列中的每一个元素都能转化成该变量的类型，常用 auto 类型说明符。


for (declaration : expression)
{ 
	statement 
}


#include <iostream>
#include <vector>
using namespace std;
int main() {
    char arr[] = "hello world!";
    for (char c : arr) {
        cout << c;
    }  
    return 0;
}
/*
程序执行结果为：
hello world!
*/
```


## 2.5 `delete` 函数和 `default` 函数
-   `delete` 函数：`= delete` 表示该函数不能被调用。
-   `default` 函数：`= default` 表示编译器生成默认的函数，例如：生成默认的构造函数。

```c++
#include <iostream>
using namespace std;

class A
{
public:
	A() = default; // 表示使用默认的构造函数
	~A() = default;	// 表示使用默认的析构函数
	A(const A &) = delete; // 表示类的对象禁止拷贝构造
	A &operator=(const A &) = delete; // 表示类的对象禁止拷贝赋值
};

int main()
{
	A ex1;
	A ex2 = ex1; // error: use of deleted function 'A::A(const A&)'
	A ex3;
	ex3 = ex1; // error: use of deleted function 'A& A::operator=(const A&)'
	return 0;
}

```


## 2.5  右值引用
-   左值引用的对象是变量
-   右值引用的对象是常量

```c++
int &&rr1 = 42;        //正确，字面值常量是右值
int &&rr2 = rr1;        //错误，表达式rr1是左值
int &&rr3 = std::move(rr1);    //正确

```

## 2.6 其他 `constexpr`, `final`, `override`，`move()`, 

# 三 面向对象

## 3.1 面向对象的三大特性

- **封装**：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。
- **继承**：子类继承父类的特征和行为。
- **多态**：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。


这篇讲多态和虚继承讲得非常透彻。 [https://zhuanlan.zhihu.com/p/65410057](https://zhuanlan.zhihu.com/p/65410057) 

## 3.2 重载、重写、隐藏的区别

- **重载**：是指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。
- **隐藏**：是指派生类的函数屏蔽了与其同名的基类函数，主要只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。
- **重写(覆盖)**：是指派生类中存在重新定义的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 virtual 修饰。


**重写和重载的区别**

范围区别：对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间（子类和父类之间）。

参数区别：重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有 virtual 修饰。

virtual 关键字：重写的函数基类中必须有 virtual关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有。

**隐藏和重写，重载的区别**

范围区别：隐藏与重载范围不同，隐藏发生在不同类中。

参数区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被 virtual 修饰，基类函数都是被隐藏，而不是重写。

### 3.3 多态

多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。

在基类的函数前加上 virtual 关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。

如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

实现方法：**多态是通过虚函数实现的，虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中**。

**实现过程**：

在类中用 virtual 关键字声明的函数叫做虚函数；

存在虚函数的类都有一个虚函数表，当创建一个该类的对象时，该对象有一个指向虚函数表的虚表指针（虚函数表和类对应的，虚表指针是和对象对应）；
当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。

# 四 其他


## 4.1 include `" "` 和` <> `的区别


查找文件的位置：`include<文件名>` 在标准库头文件所在的目录中查找，如果没有，再到当前源文件所在目录下查找；#include"文件名" 在当前源文件所在目录中进行查找，如果没有；再到系统目录中查找。

使用习惯：对于标准库中的头文件常用` include<文件名>`，对于自己定义的头文件，常用 `#include"文件名"`

---
from leetcode [C++ 面试突破 https://leetcode.cn/leetbook/detail/cmian-shi-tu-po/](https://leetcode.cn/leetbook/detail/cmian-shi-tu-po/)
