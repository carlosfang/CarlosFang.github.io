---
layout: post
title: 缓存
date: 2020-08-20 16:12:15
categories: 学习笔记
tags: 系统设计
excerpt: 缓存
---




学习资料：
[缓存](https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E7%BC%93%E5%AD%98)

缓存可以提高页面的加载数据速度，减少服务器和数据库的负担。一般是先查询缓存中是否存在，不存在则向数据源请求，然后缓存在本地。

数据库分征均匀分布的读取是最好的，但存在热门数据，均匀分布读取就变成不可能的事，所以，缓存有效的缓解这一问题。 

缓存分类：

1. 客户端缓存
2. CDN缓存
3. Web服务器缓存 

### 客户端缓存

一般指的是请求的缓存在本地的方式，可以位于客户端（操作系统，浏览器），服务器（当作客户端看待）另一个角度上看可以是进程内。
 
 ### CDN缓存
 
 可以当做一种缓存，主要缓存静态文件。

### Web服务器缓存

请求的数据被缓存在web服务器上，当发现这url命中缓存时，直接返回，不再向应用服务器请求数据。反向代理和缓存varnish。（查一下）

### 数据库缓存

大部分数据库是可以配置内存缓存，如mysql [[玩转MySQL之四]MySQL缓存机制](https://zhuanlan.zhihu.com/p/55947158)。
针对一般用例进行了优化。调整配置，在不同情况下使用不同的模式可以进一步提高性能。
 
### 应用缓存

基于内存的缓存比如 Memcached 和 Redis 是应用程序和数据存储之间的一种键值存储。由于数据保存在 RAM 中，它比存储在磁盘上的典型数据库要快多了。RAM 比磁盘限制更多，所以例如 least recently used (LRU) 的缓存无效算法可以将「热门数据」放在 RAM 中，而对一些比较「冷门」的数据不做处理。

Redis 有下附加功能：

* 持久性选项
* 内置数据结构（有序集合和列表）

有多个缓存级别，分为两大类： **数据库查询**和**对象**

* 行级别
* 查询级别
* 完整的可序列化对象
* 完全渲染的HTML

一般来说，你应该尽量避免基于文件的缓存，因为这使得复制和自动缩放很困难。

对象级别的缓存

将数据视为对象，就像对待你的应用代码一样，让应用程序数据从数据库中的组合到类实例或数据结构中：

* 如果查对象的基础数据已经更改了。那么从缓存中删掉这个对象。（一般很难知道基础数据是否已经更新了）
* 异步处理： workers 通过使用最新的缓存对象来组装对象。（监控基础数据是否有更新，有则更新缓存，注意必要时加锁）

建议缓存的内容： 什么数据应该缓存，还是要看具体的场景，是否提高访问速度，减少服务器或数据库压力。换个说法，建议什么内容不要用缓存，事务性要求比较高，涉及交易数据等（后续想到添加....）

### 何时更新缓存

#### 缓存模式 

应用从存储器读写。缓存不和存储器直接交互，执行如下：

* 在缓存中查询记录，没命中
* 从存储器中加载所需内容
* 将查找到的结果存储到缓存中
* 返回所需内容

```python 

def get_user(self, user_id):
    user = cache.get("user.{0}", user_id)
    if user is None:
        user = db.query("SELECT * FROM users WHERE user_id = {0}", user_id)
        if user is not None:
            key = "user.{0}".format(user_id)
            cache.set(key, json.dumps(user))
    return user
```
这种方式一般都有设置缓存有效期。当过了有效期则重新从存储器上读取。
缺点：

* 请求数据不在缓存中，就需要经过三个步骤来获取数据，会有明显的延迟。
* 存储器上的数据被更新了，会导致缓存中的数据成为旧数据。请求没能及时拿到最新的数据，可能通过设计有效时间，或直写的模式来缓解这种情况。 

#### 直写模式

应用使用缓存作为说要的数据存储，将数据读写到缓存中，而缓存负责从数据库中读写数据。 

* 应用向缓存中添加/更新数据
* 缓存同步地写入数据存储
* 返回所需内容

即，应用层只关心写缓存就可以了，同步数据库由缓存机制自己完成。

应用代码： 

```python 
set_user(12345, {"foo":"bar"})
```
缓存代码： 

```python 
def set_user(user_id, values):
    user = db.query("UPDATE Users WHERE id = {0}", user_id, values)
    cache.set(user_id, user)
```

直写模式的缺点： 

* 写入的大多数数据可能永远不会被读取，用TTL（生存时间值）可以最小化这种情况。
* 存写操作比较慢，但读取刚写的数据很快。 

#### 回写模式

先写入缓存中，然后通过MQ，把数据发给另一个模块，由它写入数据库。 

* 在缓存中增加或更新条目。 
* 异步写入数据，提高写入性能。

缺点：

* 可能存在缓存写入成功，写入数据库失败，导致数据不一致。
* 方式比直写模式或缓存更复杂一些。

###  相关资源和延伸阅读

[缓存替换策略](https://en.wikipedia.org/wiki/Cache_replacement_policies)
[可缩放系统构架介绍](https://lethain.com/introduction-to-architecting-systems-for-scale/)
[维基百科](https://en.wikipedia.org/wiki/Cache_(computing))

