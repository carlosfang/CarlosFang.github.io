---
layout: post
title: 缓存
date: 2020-08-20 16:12:15
categories: 系统设计
tags: 工作经验
excerpt: 缓存
---

# 一、概述

缓存可以提高页面的加载数据速度，减少服务器和数据库的负担。一般是先查询缓存中是否存在，不存在则向数据源请求，然后缓存在本地。

数据库均匀分布的读取当然是最好的，但是现实中存在热门数据，均匀分布读取就变成不可能的事，所以，缓存有效的缓解这一问题。

# 二、缓存分类

  
1、**客户端缓存**  一般指的是请求的缓存在本地的方式，可以位于客户端（操作系统，浏览器），服务器（当作客户端看待）另一个角度上看可以是进程内。

nginx 缓存配置： [Nginx缓存配置 ：https://www.cnblogs.com/itzgr/p/13321980.html](https://www.cnblogs.com/itzgr/p/13321980.html) 

2、**CDN缓存** 可以当做一种缓存，主要缓存静态文件。

3、**Web服务器缓存**  请求的数据被缓存在web服务器上，当发现这url命中缓存时，直接返回，不再向应用服务器请求数据。反向代理和缓存varnish。

  4、**数据库缓存** 大部分数据库是可以配置内存缓存，如 ； mysql [[玩转MySQL之四]MySQL缓存机制](https://zhuanlan.zhihu.com/p/55947158)。 针对一般用例进行了优化。调整配置，在不同情况下使用不同的模式可以进一步提高性能。

  5、 **应用缓存** 基于内存的缓存比如 `Memcached` 和 `Redis` 是应用程序和数据存储之间的一种键值存储。由于数据保存在内存中，它比存储在磁盘上的典型数据库要快多了。内存比磁盘容量小得多，所以例如 least recently used (LRU) 的缓存无效算法可以将「热门数据」放在 RAM 中，而对一些比较「冷门」的数据不做处理。

Redis 有下附加功能：

- 持久性选项
* 内置数据结构（有序集合和列表）


# 三、缓存级别

缓存时，数据大小范围要缓存到什么级别，这个要依据具体的业务。

1、**对象级别** 一般以对象为单位进行缓存。对象可以是具体业务中的对象，如：玩家的信息 `UserInfo`。也可以是数据库中一行数据。

2、**聚合数据** 把一个业务的数据聚合起来缓存。如：直播栏目页中，可能包含了不同业务的数据，把不同的业务数据聚合后缓存起来。 

3、**文件缓存** 一般是要放在到CDN上，如前端一些静态页面， 一些兜底用的数据文件。

4、**数据库行数据** 即所数据库中一行的数据完整的缓存起来。 

缓存到什么样的级别，要看具体的业务场景，标准是：**提高性能，减少服务器的数据库的压力**。 


# 四、缓存更新

缓存可能会导致数据一致问题，对更新缓存的方式要看运用业务的场景。

1、**多读少写**  

这是一种很普通的场景，要业务对数据延迟性有一定的包容。 

写操作可以直接写入 db 中。读操作先读缓存，如果缓存没有，则回源读 db，然后写入缓存。

要注意的是，要根据业务设置缓存的有效时间。最好可配置，方便运营过程随时调整。

这种方式，缓存的数据存在延迟性。即 db 已更新，而缓存的数据还是旧的。要等待缓存的数据过期后，再回源才能是最新的数据。

解决这个问题的方法是，在缓存的数据中加入**脏标**。

写操作更新 db 时，同时如果存在缓存，则更新缓存的脏标。

读操作先读缓存时，如果存在脏标，则回源 db 的数据，写入缓存，去掉脏标。

这个可以解决缓存的延迟性的问题。

如下图：

![](/assets/system-design/service-cache_2022-09-24_15-33-40.png)


以上的方式，业务服务直接操作了 db ，这个方式我们叫 “直接回源”。当数据回源时可能会对服务的性能造成影响。  

可以通过 “异步回源” 来解决这个问题。

1、当服务从缓存中读不到数据时，可以通过 MQ 发送消息通知 daemon 从 db 中，把数据加载到缓存中。

2、这样服务第二次读时就可以从缓存中就可以请求到数据了。

这种方式去掉了服务直接读 db 操作提高性能。但是也引入另一个问题，即第一次请求可能返回空。这要求业务对数据的延迟有一定的包容性。

如下图：

![](/assets/system-design/service-cache-2022-09-24_16-43-23.png)

我做过系统中，有把“异步回源” 和 “直接回源” 这两个都用到上的。这样对于数据要求高的，可以请求的参数来控制是否用“直接回源”。

2、 **多读多写**

有的场景对于写和读的要求都比较高。此时读写都应该在缓存中。

写操作直接写入缓存中，然后把数据通过 MQ 写入 db。引入 MQ 主要是操作 db 很影响性能。可以把同步写换成异步写。

这种方式的缺点是：用 MQ 写时，可能会丢消息。即写入 db 失败，导致缓存有数据，db 没有数据。最终数据不一致的问题。 

如下图：

![](/assets/system-design/service-cache-2022-09-24_16-13-54.png)

解决这个问题的方式是：

1、把数据写入缓存中，并设置标志。同时通过  MQ 通知 daemon 处理 缓存中的数据。 

2、daemon 把 缓存中的数据拿出写入 db 中。然后设置缓存中的标示可读。 

3、如果写入 db  失败，可能通过再次发送  MQ 再次写入 db。方式可以是：对缓存进行扫描查询有那些数据的标示长时间没有更新可读。

这个方案中，当数据被写到 db 中时，缓存中的数据才可以被读。保证了数据一致性。 同时对于数据丢失做了兜底处理。 

如下图：

![](/assets/system-design/service-cache-2022-09-24_16-28-28.png)

多读多写的场景中，很多场景的数据是可以分**冷数据**和**热数据**的。即，一条业务数据到了终态则这个数据可能是冷数据，也就没有必要保存在缓存中了。而热数据则一直在缓存中。 

1、数据写入缓存中，设置长期有效。

2、数据每一次更新到缓存中，都要通过 MQ 通知 daemon 处理数据。 

3、daemon 接到通知后，如果发现缓存中的数据已经终态，则把数据写入 db 中。

4、当数据写入 db 中后，更新缓存中的数据的有效期。以节约缓存空间。

这个方案，要求缓存中的数据不能出现问题。所以对于数据要求高的业务，最好是要有双缓存，且在不同的机房。

另外，可以增加兜底的 daemon 定时扫描缓存。如果数据已经是终态而没有被处理，则兜底处理它。 

如下图：

![](/assets/system-design/service-cache-2022-09-24_16-59-55.png)

缓存应该怎么用，还是要看具体的业务形态。分析出业务的特点，选择出合适的方案。是开发者的专业要求。 

# 五、常遇到的问题

1、**缓存洞穿问题**  

即请求缓存时没有数据，要去db 请求数据，db 也没有数据。不断请求就会把流量压到 db s上。造成性能问题。

解决方法是缓存中写入空标。当请求到空标时则直接返回。

对于空标的有效时间最好比数据有效时间短一些。在该业务时被更时，记得要重写入数据覆盖掉空标。

2、**热点 KEY 问题**

缓存一个聚合数据。可能请求会出现热点现象。如：直播栏目页的数据。放到同一个 key 中。这时很多请求都落到同一个KEY中。这会造成 redis 实例的压力。

解决方法是可以把同一份数据用不同 KEY 写入到不同实例中。 如：`KEY_%d (d = [1,10])`  这样可以把数据分到10个实例中去。 

3、**大 KEY 问题**

缓存一个聚合数据。如果数据过大。可能会对网络的流量造成压力。对于聚合数据，要设置好约束条件，防止数据膨胀。

解决方案是对聚数据时行拆分，分成多个 key 缓存。

4、**缓存雪崩的问题**

当把缓存中的大量数据设置的有效一样时，可能会同时失效，导致同时去回源，从而造成瞬间压力。 所以如果业务上有可能存在这个大量数据被设置同时失效时，则最好把有效时间用正太分布的方式散列开来。 


  

---

 1、 [缓存：https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E7%BC%93%E5%AD%98](https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E7%BC%93%E5%AD%98)

2、[缓存替换策略：https://en.wikipedia.org/wiki/Cache_replacement_policies](https://en.wikipedia.org/wiki/Cache_replacement_policies)

3、[可缩放系统构架介绍：https://lethain.com/introduction-to-architecting-systems-for-scale/](https://lethain.com/introduction-to-architecting-systems-for-scale/)

4、[维基百科：[维基百科](https://en.wikipedia.org/wiki/Cache_(computing)](https://en.wikipedia.org/wiki/Cache_(computing))
