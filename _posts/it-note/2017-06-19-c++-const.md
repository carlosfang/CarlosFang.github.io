---
layout: post
title: c++ const 常量 
date: 2017-06-19 16:12:15
categories: c++  
tags: c++  技术学习笔记
excerpt: const 常量，面试准备知识
---

1、 `const` 修饰成员变量，定义成 `const` 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。

2、 `const` 修饰函数参数，使得传递过来的函数参数的值不能改变。

3、 `const` 修饰成员函数，使得成员函数不能修改任何类型的成员变量（ `mutable` 修饰的变量除外），也不能调用非 `const` 成员函数，因为非 `const` 成员函数可能会修改成员变量。

4、`define `和 `const` 的区别：

- 编译阶段：`define` 是在编译预处理阶段进行替换，`const` 是在编译阶段确定其值。
- 安全性：`define` 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；`const` 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误。
- 内存占用：define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的空间；`const` 定义的常量占用静态存储区的空间，程序运行过程中只有一份。
- 调试：define 定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；`const` 定义的常量可以进行调试。

5、 `const` 的优点：
- 有数据类型，在定义式可进行安全性检查。
- 可调试。
- 占用较少的空间。

6、`define` 和 `typedef` 的区别：

- 原理：`#define` 作为预处理指令，在编译预处理时进行替换操作，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。`typedef` 是关键字，在编译时处理，有类型检查功能，用来给一个已经存在的类型一个别名，但不能在一个函数定义里面使用 `typedef` 。
- 功能：`typedef` 用来定义类型的别名，方便使用。`#define` 不仅可以为类型取别名，还可以定义常量、变量、编译开关等。
- 作用域：`#define` 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而 `typedef` 有自己的作用域。

7、用宏实现比较大小，以及两个数中的最小值

```c++
#include <iostream>
#define MAX(X, Y) ((X)>(Y)?(X):(Y))
#define MIN(X, Y) ((X)<(Y)?(X):(Y))
using namespace std;

int main ()
{
    int var1 = 10, var2 = 100;
    cout << MAX(var1, var2) << endl;
    cout << MIN(var1, var2) << endl;
    return 0;
}
/*
程序运行结果：
100
10
*/
```