---
layout: post
title: c++11 移动语义 浅拷贝 深拷贝
date: 2017-05-01 17:12:15
categories: 编程语言 c++ 
tags: 编程语言 c++  技术阅读笔记
excerpt: c++11 移动语义 浅拷贝 深拷贝
---

移动语义 指的就是用move函数解决深拷贝的问题。

类中的拷贝构造函数，有深拷贝和浅拷贝之分。

当类实例A给另一个实例赋值B时，就会调用拷贝构造函数。

如果类中有申请到大片内存的问题。

浅拷贝，就只是把指针指向同一个内存， 这样就会有问题，当A析构时，B的指针就悬空了。

深拷贝，就是把指针指向的内存拷贝一份，这种方式的问题是，但内存大时，太好效率的。

而用移动构造函数时就是，在发生拷贝时，把指针指向同一个内存，再把另一个指针断开。这样就把这个内存给偷起了。


#### 判断左值与右值的方法：

一个最为典型的判别方法就是， 在赋值表达式中， 出现在等号左边的就是“左值”， 而在等号右边的， 则称为“右 值”。

不过 C++ 中 还有 一个被 广泛认同的说法，那就是可以取地址的、有名字的就是左 值，反之，不能取地址的、没有名字的就是右值。


### 最后的总结：
---

引入右值是为了移动语义，引入移动语义是为了解决大数据的复制问题。

通过构造复制构造函数和移动构造函数来实现复制和移动语义。复制构造使用const &引用，而移动构造函数使用非const && 引用。

被移动语义的数据交出了所有权，为了不出现析构两次同一数据区，要将交出所有权的数据的指向动态申请内存去的指针赋值位nullptr，即空指针，对空指针执行delete[]是合法的。

强制移动，就是让左值使用移动构造函数，强制让其交出所有权。Utility文件中声明，std::move()函数。

利用匿名的变量，让其交出所有权，避免复制数据，可以提高程序的效率，

因此，如果一个临时变量再也用不着了，可以让其强制移动语义，这样，程序不用再进行大量的数据复制了，尤其是在vector作为返回值的时候。

---
\--《深入理解C++11：C++11新特性解析与应用》
