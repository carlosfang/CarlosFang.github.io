---
layout: post
title: unix标准IO库
date: 2014-10-13 20:08:12
categories: Linux
tags: 系统编程
excerpt: unix about stream 
---

### 一 流和FILE对象
(1)当用标准 I/O库打开或创建一个文件时，我们已使一个流与一个文件相结合。

(2)当打开一个流时，标准 I/O函数fopen返回一个指向FILE对象的指针。该对象通常是一个结构，它包含了I/O 库为管理该流所需要的所有信息：用于实际 I/O的文件描述符，指向流缓存的指针，缓存的长度，当前在缓存中的字符数，出错标志等等。

(3)对于ASCII字符集， 一个字符用一个字节表示。对于国际字符集，一个字符可用多个字节表示。标准I/O文件流可用于单字节或多字节的。当一个流最初被创建时，它并没有定向。如若在未定向的流上使用一个多字节I/O函数，则将该流的定向设置 宽定向的。若在未定向的流上使用一个单节I/O函数，则将该流的定向设置为字节定向的。只有两个函数可以改变的定向。freopen函数清除一个流的定向。fwide函数设置流的定向。

```c
#include <stdio.h>
#include <wchar.h>
int fwide(FILE *fp, int mode);
// 返回值：若流是宽定向的则返回正值，若流是字节定向的则返回负值，或者流是未定向的则返回0
```

根据mode参数的不同值，fwide函数执行不同的工作：

a)如若mode参数值为负，fwide将试图使指定的流是字节定向的。

b)如若mode参数值为正，fwide将试图使指定的流是宽定向的。

c)如若mode参数值为0，fwide将不试图设置流的定向，但返回标识流定向的值。

d)注意，fwide并不改变忆定向流的定向。还应注意的是，fwide无出错返回。在调用fwide前先清除error，从fwide返回时检查errorno的值。

### 二 标准输入、标准输出和标准出错

对一个进程预定义了三个流，它们自动地可为进程使用：标准输入、标准输出和标准出错。
我们可以用文件描述符 STDIN_FILENO,STDOUT_FILENO和STDERR_FILENO分别表示它们。
这三个标准I/O流通过预定义文件指针 stdin,stdout和stderr加以引用。这三个文件指针同样定义在头文件<stdio.h>中。

### 三 缓存

1 标准I/O提供缓存的目的是尽可能减少使用 read和write调用的数量。

2 标准I/O提供了三种类型的缓存：

#### 全缓存。

在这种情况下，当填满标准I/O缓存后才进行实际I/O操作。对于驻在磁盘上的文件通常是由标准IO库实施全缓存的。
在一个流上执行第一次 I/O操作时，相关标准I/O函数通常调用malloc获得需使用的缓存。术语刷新（flush）说明标准 I/O缓存的写操作。
缓存可由标准 I/O例程自动地刷新（例如当填满一个缓存时），或者可以调用函数fflush刷新一个流。值得引起注意的是在UNIX环境中，刷新有两种意思。在标准 I/O库方面，刷新意味着将缓存中的内容写到磁盘上（该缓存可以只是局部填写的） 。在终端驱动程序方面（例如在第 11章中所述的 tcflush函数），刷新表示丢弃已存在缓存中的数据。

#### 行缓存

在这种情况下，当在输入和输出中遇到新行符时，标准I/O库执行IO操作。这允许我们一次输出一个字符（用标准 I/O fputc函数），但只有在写了一行之后才进行实际 I/O操作。
当流涉及一个终端时（例如标准输入和标准输出），典型地使用行缓存。对于行缓存有两个限制。
第一个是：因为标准IO库用来收集每一行的缓存的长度是固定的，所以只要填满了缓存，那么即使还没有写一个新行符，也进行 I/O操作。
第二个是：任何时候只要通过标准输入输出库要求从 ( a ) 一个不带缓存的流，或者 ( b ) 一个行缓存的流（它预先要求从内核得到数据）得到输入数据，那么就会造成刷新所有行缓存输出流。在 ( b )中带了一个在括号中的说明的理由是，所需的数据可能已在该缓存中，它并不要求内核在需要该数据时才进行该操作。很明显，从不带缓存的一个流中进行输入（ ( a )项）要求当时从内核得到数据。
 
####  不带缓存

标准 I/O库不对字符进行缓存。如果用标准 I/O函数写若干字符到不带缓存的流中，则相当于用write系统调用函数将这些字符写至相关联的打开文件上。标准出错流stderr通常是不带缓存的，这就使得出错信息可以尽快显示出来，而不管它们是否含有一个新行字符。

3 标准出错是不带缓冲的，打开 到终端设备的流是行缓冲的，其他所有流则是全缓冲的。

4 对于流的缓冲可能通来两个函数更改缓冲类型：

```c
#include <stdio.h>
void setbuf(FILE * restrict fp, char * restrict buf);
int setvbut(FILE * restrict fp, char * restrict buf, int mode, size_t size);
//返回值：若成功则返回0，若出错则返回非0值
```

这些函数一定要在流已被打开后调用。
强制刷新一个流。

```c
#include <stdio.h >
int fflush(FILE * f p) ;
//返回：若成功则为0，若出错则为EOF
```

此函数使该流所有未写的数据都被传递至内核。作为一种特殊情形，如若 fp是NULL，则此函数刷新所有输出流。

#### 四、打开流

下列三个函数可用于打开一个标准 I/O流。

```c
#include <stdio.h>
FILE *fopen(const char * pathname, const char * type) ;
FILE *freopen(const char * pathname, const char * type, FILE * fp);
FILE *fdopen(int  filedes, const char * type) ;
// 三个函数的返回：若成功则为文件指针，若出错则为 NULL
```

这三个函数的区别是：

(1) fopen 打开路径名由pathname 指示的一个文件。

(2) freopen在一个特定的流上 (由f p指示)打开一个指定的文件（其路径名由pathname  指示），如若该流已经打开，则先关闭该流。此函数一般用于将一个指定的文件打开为一个预定义的流：标准输入、标准输出或标准出错。

(3) fdopen 取一个现存的文件描述符（我们可能从open,dup,dup2,fcntl或pipe函数得到此文件描述符）并使一个标准的I/O流与该描述符相结合。此函数常用于由创建管道和网络通信通道函数获得的插述符。因为这些特殊类型的文件不能用标准 I/O fopen 函数打开，首先必须先调用设备专用函数以获得一个文件描述符，然后用 fdopen使一个标准I/O流与该描述符相结合。
type参数指定对该I/O 流的读、写方式，ANSI C规定type参数可以有15种不同的值

![](/assets/linux/linux-io-stream-1.png) 

当以读和 写类型打开一文件时，（type中+符号）， 具胡下列限制：

(1) 如果中间没有fflush、fseek、fsetpos或rewind，则在输出的后面不能直接跟随。

(2) 如果中间没有fseek、fsetpos或rewind，或者一个输入操作没有到达文件尾端，则在输入操作之后不能直接跟随输出。

