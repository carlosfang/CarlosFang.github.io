I"]<h3 id="memmove-函数">memmove 函数</h3>

<p><code class="language-plaintext highlighter-rouge">memmove</code>  和 <code class="language-plaintext highlighter-rouge">memcpy</code> 都是 c 语言的库函数， 定义在 <code class="language-plaintext highlighter-rouge">string.h</code> 中， 他们的作用一样，惟一的区别是：当内部发生重叠后，<code class="language-plaintext highlighter-rouge">memmove</code> 可以保证数据正确性。</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">memcpy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">dst</span><span class="p">,</span> <span class="n">cosnt</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dst</span><span class="p">;</span> 
	<span class="kt">char</span> <span class="o">*</span> <span class="n">s_str</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="p">;</span> 

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">){</span>
		<span class="o">*</span><span class="n">tmp</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">s_str</span><span class="o">++</span><span class="p">;</span> 
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">dst</span><span class="p">;</span> 
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">memmove</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">psrc</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">pdst</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">dst</span> <span class="o">||</span> <span class="nb">NULL</span> <span class="o">==</span> <span class="n">src</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">src</span> <span class="o">&lt;</span> <span class="n">dst</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">src</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dst</span><span class="p">)</span> <span class="c1">// 出现地址重叠的情况，自后向前拷贝</span>
    <span class="p">{</span>
        <span class="n">psrc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">src</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">pdst</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dst</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">size</span><span class="o">--</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="o">*</span><span class="n">pdst</span><span class="o">--</span> <span class="o">=</span> <span class="o">*</span><span class="n">psrc</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">psrc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="p">;</span>
        <span class="n">pdst</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dst</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">size</span><span class="o">--</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="o">*</span><span class="n">pdst</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">psrc</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">dst</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="strcpy-函数有什么缺陷"><code class="language-plaintext highlighter-rouge">strcpy</code> 函数有什么缺陷？</h3>

<p><code class="language-plaintext highlighter-rouge">trcpy</code> 函数不检查目的缓冲区的大小边界，而是将源字符串逐一的全部赋值给目的字符串地址起始的一块连续的内存空间，同时加上字符串终止符，会导致其他变量被覆盖。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span><span class="o">*</span> <span class="nf">strcpy</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">des</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">source</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">r</span><span class="o">=</span><span class="n">des</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">des</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">source</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">));</span>
    <span class="k">while</span><span class="p">((</span><span class="o">*</span><span class="n">r</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">source</span><span class="o">++</span><span class="p">)</span><span class="o">!=</span><span class="sc">'\0'</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">des</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
:ET